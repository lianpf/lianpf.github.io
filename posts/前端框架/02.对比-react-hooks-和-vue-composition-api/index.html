<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="ie=edge"><title>对比 React Hooks 和 Vue Composition API | 曜灵（SUN）Site</title><link href=/img-common/favicon.png rel="shortcut icon" type=image/x-icon><meta name=author content="曜灵"><meta name=description content="目录 场景 hook 的时代意义 React Hooks Vue Composition API 差别 总结 场景 先理解&amp;hellip;"><meta name=generator content="Hugo 0.74.2"><link rel=canonical href=/posts/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/02.%E5%AF%B9%E6%AF%94-react-hooks-%E5%92%8C-vue-composition-api/><meta property="og:title" content="对比 React Hooks 和 Vue Composition API"><meta property="og:description" content="目录 场景 hook 的时代意义 React Hooks Vue Composition API 差别 总结 场景 先理解&mldr;"><meta property="og:type" content="article"><meta property="og:url" content="/posts/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/02.%E5%AF%B9%E6%AF%94-react-hooks-%E5%92%8C-vue-composition-api/"><meta property="article:published_time" content="2020-07-06T00:00:00+00:00"><meta property="article:modified_time" content="2020-09-04T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="对比 React Hooks 和 Vue Composition API"><meta name=twitter:description content="目录 场景 hook 的时代意义 React Hooks Vue Composition API 差别 总结 场景 先理解&mldr;"><link rel=stylesheet href=/css/semantic.min.css><link rel=stylesheet href=/css/OverlayScrollbars.min.css><link rel=stylesheet href=/css/github-markdown.css><link rel=stylesheet href=/css/site.css><style>.inverted a{color:#8fbc8f!important}</style><style>body{background-image:url(/img-common/background.jpg)}</style><link rel=stylesheet data-highlight href=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/styles/gruvbox-light.min.css></head><body><nav class="ui secondary inverted menu dream-menu"><div class=item><i class="large link bullseye icon dream-flip-toggle" title=翻转！></i></div><div class=item><i class="large link home icon" title=首页 onclick="window.location.href='\/'"></i></div><div class=item><i class="large link icon theme-switch" onclick=themeSwitch()></i></div><div class=item><i class="large link search icon" onclick=toggleSearch()></i></div></nav><div class=flip-container><div class=flipper><section class=front><div class=dream-max-width><div class="ui centered relaxed grid dream-grid"><div class="sixteen wide mobile sixteen wide tablet twelve wide computer column markdown-body dream-single" id=dream-save-post-as-img><section class="ui top attached segment cover"><div class=cover-img style=background-image:url()></div></section><section class="ui attached segment"><header><h1 class="ui large header">对比 React Hooks 和 Vue Composition API<div class="sub header">@
曜灵
· Monday, Jul 6, 2020
· 10 分钟阅读
· 更新于 Sep 4, 2020</div></h1></header><article style=margin-top:2rem><p>目录 场景 hook 的时代意义 React Hooks Vue Composition API 差别 总结 场景 先理解&mldr;</p><p><img src=/img-blogs/20200706-001.png alt="对比 React Hooks 和 Vue Composition API"></p><p><strong>目录</strong></p><ul><li>场景</li><li>hook 的时代意义</li><li>React Hooks</li><li>Vue Composition API</li><li>差别</li><li>总结</li></ul><hr><h2 id=场景>场景</h2><p>先理解什么是hook，拿react的介绍来看，它的定义是：</p><blockquote><p>它可以让你在不编写 class 的情况下，让你在函数组件里“钩入” React state 及生命周期等特性的函数</p></blockquote><p>对于 Vue 提出的新的书写 Vue 组件的 API：Composition API RFC，作用也是类似，所以我们也可以像react一样叫做 vue hooks</p><ul><li>该 API 受到 React Hooks 的启发</li><li>但有一些有趣的差异，规避了一些react的问题</li></ul><h2 id=hook的时代意义>hook的时代意义</h2><p>框架是服务于业务的，业务中很难避免的一个问题就是 &ndash; 逻辑复用，同样的功能，同样的组件，在不一样的场合下，我们有时候不得不去写2+次，为了避免耦合，后来各大框架纷纷想出了一些办法，比如 minix, render props, 高阶组件等实现逻辑上的复用，但是都有一些额外的问题</p><ul><li>minix 与组件之间存在隐式依赖，可能产生冲突。倾向于增加更多状态，降低了应用的可预测性</li><li>高阶组件 多层包裹嵌套组件，增加了复杂度和理解成本，对于外层是黑盒</li><li>Render Props 使用繁琐，不好维护, 代码体积过大，同样容易嵌套过深</li><li>&mldr;</li></ul><p>hook的出现是划时代的，通过function抽离的方式，实现了复杂逻辑的内部封装：</p><ul><li>逻辑代码的复用</li><li>减小了代码体积</li><li>没有this的烦恼</li></ul><h2 id=react-hooks>React Hooks</h2><p>React Hooks 允许你 &ldquo;勾入&rdquo; 诸如组件状态和副作用处理等 React 功能中。Hooks 只能用在函数组件中，并允许我们在不需要创建类的情况下将状态、副作用处理和更多东西带入组件中。</p><p>React 核心团队奉上的采纳策略是不反对类组件，所以你可以升级 React 版本、在新组件中开始尝试 Hooks，并保持既有组件不做任何更改</p><p>例子：</p><pre><code>import React, { useState, useEffect } from &quot;react&quot;;

const NoteForm = ({ onNoteSent }) =&gt; {
  const [currentNote, setCurrentNote] = useState(&quot;&quot;);
  useEffect(() =&gt; {
    console.log(`Current note: ${currentNote}`);
  });
  return (
    &lt;form
      onSubmit={e =&gt; {
        onNoteSent(currentNote);
        setCurrentNote(&quot;&quot;);
        e.preventDefault();
      }}
    &gt;
      &lt;label&gt;
        &lt;span&gt;Note: &lt;/span&gt;
        &lt;input
          value={currentNote}
          onChange={e =&gt; {
            const val = e.target.value &amp;&amp; e.target.value.toUpperCase()[0];
            const validNotes = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot;];
            setCurrentNote(validNotes.includes(val) ? val : &quot;&quot;);
          }}
        /&gt;
      &lt;/label&gt;
      &lt;button type=&quot;submit&quot;&gt;Send&lt;/button&gt;
    &lt;/form&gt;
  );
};
</code></pre><ul><li>useState 和 useEffect 是 React Hooks 中的一些例子，使得函数组件中也能增加状态和运行副作用</li><li>还有更多其他 hooks， 甚至能自定义一个，hooks 打开了代码复用性和扩展性的新大门</li></ul><h3 id=vue-composition-api>Vue Composition API</h3><p>Vue Composition API 围绕一个新的组件选项 setup 而创建。<code>setup()</code> 为 Vue 组件提供了状态、计算值、watcher 和生命周期钩子</p><p>API 并没有让原来的 API（现在被称作 &ldquo;Options-based API&rdquo;）消失。允许开发者 结合使用新旧两种 APIs。可以在 Vue 2.x 中通过 <code>@vue/composition-api</code> 插件尝试新 API</p><p>例子：</p><pre><code>&lt;template&gt;
  &lt;form @submit=&quot;handleSubmit&quot;&gt;
    &lt;label&gt;
      &lt;span&gt;Note:&lt;/span&gt;
      &lt;input v-model=&quot;currentNote&quot; @input=&quot;handleNoteInput&quot;&gt;
    &lt;/label&gt;
    &lt;button type=&quot;submit&quot;&gt;Send&lt;/button&gt;
  &lt;/form&gt;
&lt;/template&gt;
&lt;script&gt;
import { ref, watch } from &quot;vue&quot;;
export default {
  props: [&quot;divRef&quot;],
  setup(props, context) {
    const currentNote = ref(&quot;&quot;);
    const handleNoteInput = e =&gt; {
      const val = e.target.value &amp;&amp; e.target.value.toUpperCase()[0];
      const validNotes = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot;];
      currentNote.value = validNotes.includes(val) ? val : &quot;&quot;;
    };
    const handleSubmit = e =&gt; {
      context.emit(&quot;note-sent&quot;, currentNote.value);
      currentNote.value = &quot;&quot;;
      e.preventDefault();
    };
    return {
      currentNote,
      handleNoteInput,
      handleSubmit,
    };
  }
};
&lt;/script&gt;
</code></pre><h2 id=差别>差别</h2><h3 id=原理>原理</h3><p>React hook 底层是基于链表实现，调用的条件是每次组件被render的时候都会顺序执行所有的hooks，所以下面的代码会报错</p><pre><code>function App(){
  const [name, setName] = useState('demo');
  if(condition){
    const [val, setVal] = useState('');    
  }
}
</code></pre><p>因为底层是链表，每一个hook的next是指向下一个hook的，if会导致顺序不正确，从而导致报错，所以react是不允许这样使用hook的。</p><p>vue hook 只会被注册调用一次，vue 能避开这些麻烦的问题，原因在于它对数据的响应是基于proxy的，对数据直接代理观察。这种场景下，只要任何一个更改data的地方，相关的function或者template都会被重新计算，因此避开了react可能遇到的性能上的问题</p><blockquote><p>react数据更改的时候，会导致重新render，重新render又会重新把hooks重新注册一次，所以react的上手难度更高一些</p></blockquote><p>当然react对这些都有自己的解决方案，比如useCallback，useMemo等hook的作用，这些官网都有介绍</p><h3 id=代码的执行>代码的执行</h3><p>Vue 中，“钩子”就是一个生命周期方法</p><ol><li>Vue Composition API 的 setup() 晚于 beforeCreate 钩子，早于 created 钩子被调用</li><li>React hooks 会在组件每次渲染时候运行，而 Vue setup() 只在组件创建时运行一次</li></ol><p>由于 React hooks 会多次运行，所以 render 方法必须遵守某些规则，比如: 不要在循环内部、条件语句中或嵌套函数里调用 Hooks</p><pre><code>// React 文档中的示例代码：
function Form() {
  // 1. Use the name state variable
  const [name, setName] = useState('Mary');

  // 2. Use an effect for persisting the form
  if (name !== '') {
    useEffect(function persistForm() {
      localStorage.setItem('formData', name);
    });
  }
  // 3. Use the surname state variable
  const [surname, setSurname] = useState('Poppins');

  // 4. Use an effect for updating the title
  useEffect(function updateTitle() {
    document.title = `${name} ${surname}`;
  });
  // ...
}
</code></pre><p>如果想要在 name 为空时也运行对应的副作用, 可以简单的将条件判断语句移入 useEffect 回调内部：</p><pre><code>useEffect(function persistForm() {
  if (name !== '') {
    localStorage.setItem('formData', name);
  }
});
</code></pre><p>对于以上的实现，Vue 写法如下：</p><pre><code>export default {
  setup() {
    // 1. Use the name state variable
    const name = ref(&quot;Mary&quot;);
    // 2. Use a watcher for persisting the form
    if(name.value !== '') {
      watch(function persistForm() =&gt; {
        localStorage.setItem('formData', name.value);
      });
    }
   // 3. Use the surname state variable
   const surname = ref(&quot;Poppins&quot;);
   // 4. Use a watcher for updating the title
   watch(function updateTitle() {
     document.title = `${name.value} ${surname.value}`;
   });
  }
}
</code></pre><p>Vue 中 setup() 只会运行一次，可以将 Composition API 中不同的函数 (reactive、ref、computed、watch、生命周期钩子等) 作为循环或条件语句的一部分</p><p>但 if 语句 和 react hooks 一样只运行一次，所以它在 name 改变时也无法作出反应，除非我们将其包含在 watch 回调的内部</p><pre><code>watch(function persistForm() =&gt; {
  if(name.value !== '') {
    localStorage.setItem('formData', name.value);
  }
});
</code></pre><h3 id=声明状态declaring-state>声明状态(Declaring state)</h3><h5 id=react>react</h5><p>useState 是 React Hooks 声明状态的主要途径</p><ul><li>可以向调用中传入一个初始值作为参数</li><li>如果初始值的计算代价比较昂贵，也可以将其表达为一个函数，就只会在初次渲染时才会被执行</li></ul><p>useState() 返回一个数组，第一项是 state，第二项是一个 setter 函数</p><pre><code>const [name, setName] = useState(&quot;Mary&quot;);
const [age, setAge] = useState(25);
console.log(`${name} is ${age} years old.`);
</code></pre><p>useReducer 是个有用的替代选择，其常见形式是接受一个 Redux 样式的 reducer 函数和一个初始状态：</p><pre><code>const initialState = {count: 0};

function reducer(state, action) {
  switch (action.type) {
    case 'increment':
      return {count: state.count + 1};
    case 'decrement':
      return {count: state.count - 1};
    default:
      throw new Error();
  }
}
const [state, dispatch] = useReducer(reducer, initialState);

dispatch({type: 'increment'}); // state 就会变为 {count: 1}
</code></pre><blockquote><p>useReducer 还有一种 延迟初始化 的形式，传入一个 init 函数作为第三个参数</p></blockquote><h5 id=vue>Vue</h5><p>Vue 使用两个主要的函数来声明状态：ref 和 reactive。</p><p>ref() 返回一个反应式对象，其内部值可通过其 value 属性被访问到。可以将其用于基本类型，也可以用于对象</p><pre><code>const name = ref(&quot;Mary&quot;);
const age = ref(25);
watch(() =&gt; {
  console.log(`${name.value} is ${age.value} years old.`);
});
</code></pre><p>reactive() 只将一个对象作为其输入并返回一个对其的反应式代理</p><pre><code>const state = reactive({
  name: &quot;Mary&quot;,
  age: 25,
});
watch(() =&gt; {
  console.log(`${state.name} is ${state.age} years old.`);
});
</code></pre><p><strong>注意</strong>：</p><ul><li>使用 ref 时需要 用 value 属性访问其包含的值（除非在 template 中，Vue 允许你省略它）</li><li>用 reactive 时，要注意如果使用了对象解构（destructure），会失去其反应性。所以需要定义一个指向对象的引用，并通过其访问状态属性。</li></ul><p>总结使用这两个函数的处理方式：</p><ul><li>像在正常的 JavaScript 中声明基本类型变量和对象变量那样去使用 ref 和 reactive 即可</li><li>只要用到 reactive 的时候，要记住从 composition 函数中返回反应式对象时得使用 toRefs()。这样做减少了过多使用 ref 时的开销</li></ul><pre><code>// toRefs() 则将反应式对象转换为普通对象，该对象上的所有属性都自动转换为 ref
function useFeatureX() {
  const state = reactive({
    foo: 1,
    bar: 2
  })
 
  return toRefs(state)
}
 
const {foo, bar} = useFeatureX();
</code></pre><h3 id=如何跟踪依赖how-to-track-dependencies>如何跟踪依赖(How to track dependencies)</h3><blockquote><p>React 中的 useEffect hook 允许在每次渲染之后运行某些副作用（如请求数据或使用 storage 等 Web APIs），并在下次执行回调之前或当组件卸载时运行一些清理工作</p></blockquote><p>默认情况下，所有用 useEffect 注册的函数都会在每次渲染之后运行，但可以定义真实依赖的状态和属性，以使 React 在相关依赖没有改变的情况下（如由 state 中的其他部分引起的渲染）跳过某些 useEffect hook 执行</p><pre><code>// 传递一个依赖项的数组作为 useEffect hook 的第二个参数，只有当 name 改变时才会更新 localStorage
function Form() {
  const [name, setName] = useState('Mary');
  const [surname, setSurname] = useState('Poppins');
  useEffect(function persistForm() {
      localStorage.setItem('formData', name);
  }, [name]);

  // ...
}
</code></pre><p>显然，使用 React Hooks 时忘记在依赖项数组中详尽地声明所有依赖项很容易发生，会导致 useEffect 回调 &ldquo;以依赖和引用了上一次渲染的陈旧数据而非最新数据&rdquo; 从而无法被更新而告终</p><p>解决方案：</p><ul><li>eslint-plugin-react-hooks 包含了一条 lint 提示关于丢失依赖项的规则</li><li>useCallback 和 useMemo 也使用依赖项数组参数，以分别决定其是否应该返回缓存过的（ memoized）与上一次执行相同的版本的回调或值。</li></ul><p>在 Vue Composition API 的情况下，可以使用 watch() 执行副作用以响应状态或属性的改变。依赖会被自动跟踪，注册过的函数也会在依赖改变时被反应性的调用</p><pre><code>export default {
  setup() {
    const name = ref(&quot;Mary&quot;);
    const lastName = ref(&quot;Poppins&quot;);
    watch(function persistForm() =&gt; {
      localStorage.setItem('formData', name.value);
    });
  }
}
</code></pre><h3 id=访问组件生命周期access-to-the-lifecycle-of-the-component>访问组件生命周期(Access to the lifecycle of the component)</h3><p>Hooks 在处理 React 组件的生命周期、副作用和状态管理时表现出了心理模式上的完全转变。 React 文档中也指出：</p><blockquote><p>如果你熟悉 React 类生命周期方法，那么可以将 useEffect Hook 视为 componentDidMount、componentDidUpdate 及 componentWillUnmount 的合集</p></blockquote><pre><code>useEffect(() =&gt; {
  console.log(&quot;This will only run after initial render.&quot;);
  return () =&gt; { console.log(&quot;This will only run when component will unmount.&quot;); };
}, []);
</code></pre><p>强调的是，使用 React Hooks 时停止从生命周期方法的角度思考，而是考虑副作用依赖什么状态，才更符合习惯</p><p>Vue Component API 通过 onMounted、onUpdated 和 onBeforeUnmount：</p><pre><code>setup() {
  onMounted(() =&gt; {
    console.log(`This will only run after initial render.`); 
  });
  onBeforeUnmount(() =&gt; {
    console.log(`This will only run when component will unmount.`);
  });
}
</code></pre><p>故在 Vue 的情况下的心理模式转变更多在停止通过组件选项（data、computed, watch、methods、生命周期钩子等）管理代码，要转向用不同函数处理对应的特性</p><h3 id=自定义代码custom-code>自定义代码(Custom code)</h3><blockquote><p>React 团队聚焦于 Hooks 上的原因之一，Custom Hooks 是可以替代之前社区中采纳的诸如 Higher-Order Components 或 Render Props 等提供给开发者编写可复用代码的，一种更优秀的方式</p></blockquote><p>Custom Hooks 就是普通的 JavaScript 函数，在其内部利用了 React Hooks。它遵守的一个约定是其命名应该以 use 开头，以明示这是被用作一个 hook 的。</p><pre><code>// custom hook - 用于当 value 改变时向控制台打印日志
export function useDebugState(label, initialValue) {
  const [value, setValue] = useState(initialValue);
  useEffect(() =&gt; {
    console.log(`${label}: `, value);
  }, [label, value]);
  return [value, setValue];
}

// 调用 
const [name, setName] = useDebugState(&quot;Name&quot;, &quot;Mary&quot;);
</code></pre><p>Vue 中，组合式函数（Composition Functions）与 Hooks 在逻辑提取和重用的目标上是一致的在 Vue 中实现一个类似的 useDebugState 组合式函数</p><pre><code>export function useDebugState(label, initialValue) {
  const state = ref(initialValue);
  watch(() =&gt; {
    console.log(`${label}: `, state.value);
  });
  return state;
}

// elsewhere:
const name = useDebugState(&quot;Name&quot;, &quot;Mary&quot;);
</code></pre><blockquote><p>注意：根据约定，组合式函数也像 React Hooks 一样使用 use 作为前缀以明示作用，并且表面该函数用于 setup() 中</p></blockquote><h3 id=refs>Refs</h3><p>React 的 useRef 和 Vue 的 ref 都允许你引用一个子组件 或 要附加到的 DOM 元素。</p><p>React：</p><pre><code>const MyComponent = () =&gt; {
  const divRef = useRef(null);
  useEffect(() =&gt; {
    console.log(&quot;div: &quot;, divRef.current)
  }, [divRef]);

  return (
    &lt;div ref={divRef}&gt;
      &lt;p&gt;My div&lt;/p&gt;
    &lt;/div&gt;
  )
}
</code></pre><p>Vue:</p><pre><code>export default {
  setup() {
    const divRef = ref(null);
    onMounted(() =&gt; {
      console.log(&quot;div: &quot;, divRef.value);
    });

    return () =&gt; (
      &lt;div ref={divRef}&gt;
        &lt;p&gt;My div&lt;/p&gt;
      &lt;/div&gt;
    )
  }
}
</code></pre><h3 id=附加的函数additional-functions>附加的函数(Additional functions)</h3><p>React Hooks 在每次渲染时都会运行，没有 一个等价于 Vue 中 computed 函数的方法。所以你可以自由地声明一个变量，其值基于状态或属性，并将指向每次渲染后的最新值：</p><pre><code>const [name, setName] = useState(&quot;Mary&quot;);
const [age, setAge] = useState(25);
const description = `${name} is ${age} years old`;
</code></pre><p>Vue 中，setup() 只运行一次。因此需要定义计算属性，其应该观察某些状态更改并作出相应的更新：</p><pre><code>const name = ref(&quot;Mary&quot;);
const age = ref(25);
const description = computed(() =&gt; `${name.value} is ${age.value} years old`);
</code></pre><p>计算一个值开销比较昂贵。你不会想在组件每次渲染时都计算它。React 包含了针对这点的 <code>useMemo hook</code>：</p><pre><code>function fibNaive(n) {
  if (n &lt;= 1) return n;
  return fibNaive(n - 1) + fibNaive(n - 2);
}
const Fibonacci = () =&gt; {
  const [nth, setNth] = useState(1);
  const nthFibonacci = useMemo(() =&gt; fibNaive(nth), [nth]);
  return (
    &lt;section&gt;
      &lt;label&gt;
        Number:
        &lt;input
          type=&quot;number&quot;
          value={nth}
          onChange={e =&gt; setNth(e.target.value)}
        /&gt;
      &lt;/label&gt;
      &lt;p&gt;nth Fibonacci number: {nthFibonacci}&lt;/p&gt;
    &lt;/section&gt;
  );
};
</code></pre><p><strong>React 建议你使用 useMemo 作为一个性能优化手段, 而非一个任何一个依赖项改变之前的缓存值</strong></p><blockquote><p>React advice you to use useMemo as a performance optimization and not as a guarantee that the value will remain memoized</p></blockquote><p>Vue 的 computed 执行自动的依赖追踪，所以它不需要一个依赖项数组</p><h3 id=context-和-provideinject>Context 和 provide/inject</h3><p>React 中的 useContext hook，可以作为一种读取特定上下文当前值的新方式。返回的值通常由最靠近的一层 <code>&lt;MyContext.Provider></code> 祖先树的 value 属性确定</p><pre><code>// context object
const ThemeContext = React.createContext('light');

// provider
&lt;ThemeContext.Provider value=&quot;dark&quot;&gt;

// consumer
const theme = useContext(ThemeContext);
</code></pre><p>Vue 中类似的 API 叫 <code>provide/inject</code>。在 Vue 2.x 中作为组件选项存在，在 Composition API 中增加了一对用在 setup() 中的 <code>provide 和 inject</code> 函数：</p><pre><code>// key to provide
const ThemeSymbol = Symbol();

// provider
provide(ThemeSymbol, ref(&quot;dark&quot;));

// consumer
const value = inject(ThemeSymbol);
</code></pre><blockquote><p>如果你想保持反应性，必须明确提供一个 ref/reactive 作为值</p></blockquote><h3 id=在渲染上下文中暴露值exposing-values-to-render-context>在渲染上下文中暴露值(Exposing values to render context)</h3><p><strong>在 React 的情况下</strong></p><ul><li>所有 hooks 代码都在组件中定义</li><li>且你将在同一个函数中返回要渲染的 React 元素</li></ul><p>所以你对作用域中的任何值拥有完全访问能力，就像在任何 JavaScript 代码中的一样：</p><pre><code>const Fibonacci = () =&gt; {
  const [nth, setNth] = useState(1);
  const nthFibonacci = useMemo(() =&gt; fibNaive(nth), [nth]);
  return (
    &lt;section&gt;
      &lt;label&gt;
        Number:
        &lt;input
          type=&quot;number&quot;
          value={nth}
          onChange={e =&gt; setNth(e.target.value)}
        /&gt;
      &lt;/label&gt;
      &lt;p&gt;nth Fibonacci number: {nthFibonacci}&lt;/p&gt;
    &lt;/section&gt;
  );
};
</code></pre><p><strong>Vue 的情况下</strong></p><ul><li>第一，在 template 或 render 选项中定义模板</li><li>第二，使用单文件组件，就要从 setup() 中返回一个包含了你想输出到模板中的所有值的对象</li></ul><blockquote><p>由于要暴露的值很可能过多，返回语句也容易变得冗长</p></blockquote><pre><code>&lt;template&gt;
  &lt;section&gt;
    &lt;label&gt;
      Number:
      &lt;input
        type=&quot;number&quot;
        v-model=&quot;nth&quot;
      /&gt;
    &lt;/label&gt;
    &lt;p&gt;nth Fibonacci number: {{nthFibonacci}}&lt;/p&gt;
  &lt;/section&gt;
&lt;/template&gt;
&lt;script&gt;
export default {
  setup() {
    const nth = ref(1);
    const nthFibonacci = computed(() =&gt; fibNaive(nth.value));
    return { nth, nthFibonacci };
  }
};
&lt;/script&gt;
}
</code></pre><blockquote><p>要达到 React 同样简洁表现的一种方式是从 setup() 自身中返回一个渲染函数。不过，模板在 Vue 中是更常用的一种做法，所以暴露一个包含值的对象，是你使用 Vue Composition API 时必然会多多遭遇的情况。</p></blockquote><h3 id=总结conclusion>总结(Conclusion)</h3><p>React 和 Vue都有属于属于自己的“惊喜”，无优劣之分，自 React Hooks 在 2018 年被引入，社区利用其产出了很多优秀的作品，自定义 Hooks 的可扩展性也催生了许多开源贡献。</p><p>Vue 受 React Hooks 启发将其调整为适用于自己框架的方式，这也成为这些<strong>不同的技术如何拥抱变化且分享灵感和解决方案的成功案例</strong></p><hr><h3 id=参考>参考</h3><ul><li><a href=https://composition-api.vuejs.org/#summary>Composition API RFC</a></li><li><a href=https://reactjs.org/docs/hooks-intro.html>React hooks</a></li><li><a href=https://dev.to/voluntadpear/comparing-react-hooks-with-vue-composition-api-4b32>Comparing React Hooks with Vue Composition API</a></li></ul><hr><p><strong>最后， 希望大家早日实现：成为前端高手的伟大梦想！</strong>
<strong>欢迎交流~</strong></p><p></p></article></section><footer class="ui attached segment dream-tags" data-html2canvas-ignore><a class="ui label" href=/tags/javascript title=JavaScript>JavaScript</a>
<a class="ui label" href=/tags/react%E6%8A%80%E6%9C%AF%E6%A0%88 title=React技术栈>React技术栈</a>
<a class="ui label" href=/tags/vue%E6%8A%80%E6%9C%AF%E6%A0%88 title=Vue技术栈>Vue技术栈</a><div class="ui label" style=float:right;cursor:pointer onclick=savePostAsImg()><i class="save icon"></i>保存为图片</div></footer><footer class="ui bottom attached stacked segment post-disqus-area" data-html2canvas-ignore><div id=disqus_thread></div><script>var disqus_config=function(){this.page.url='\/posts\/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6\/02.%E5%AF%B9%E6%AF%94-react-hooks-%E5%92%8C-vue-composition-api\/';this.page.identifier='\/posts\/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6\/02.%E5%AF%B9%E6%AF%94-react-hooks-%E5%92%8C-vue-composition-api\/';};(function(){var d=document,s=d.createElement('script');s.src='https://'+'...'+'.disqus.com/embed.js';s.setAttribute('data-timestamp',+new Date());(d.head||d.body).appendChild(s);})();</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript></footer><div class="ui segment utterances-comments" data-html2canvas-ignore><script src=https://utteranc.es/client.js repo=lianpf/lianpf.github.io issue-term=og:title theme=github-light crossorigin=anonymous async></script></div></div><div class="sixteen wide mobile sixteen wide tablet four wide computer column"><article class=dream-header><section class="ui top attached center aligned segment"><div class="ui small circular image"><img src=/img-common/favicon.png></div><div class="ui medium header">曜灵 的博客<div class="sub header" style=margin-top:.5rem>带着 "偏见" 去理解技术的世界！</div></div><div class="ui horizontal list"><a class=item href=/posts><i class="archive icon" title=归档></i></a><a class=item href=/tags><i class="tags icon" title=所有标签></i></a><a class=item href=/categories><i class="th list icon" title=所有分类></i></a></div></section><section class="ui attached center aligned segment dream-tags"><a class="ui label" href=/tags/css title=css>css</a>
<a class="ui label" href=/tags/git title=git>git</a>
<a class="ui label" href=/tags/github-action title=github-action>github-action</a>
<a class="ui label" href=/tags/http title=http>http</a>
<a class="ui label" href=/tags/hugo title=hugo>hugo</a>
<a class="ui label" href=/tags/javascript title=javascript>javascript</a>
<a class="ui label" href=/tags/nginx title=nginx>nginx</a>
<a class="ui label" href=/tags/node title=node>node</a>
<a class="ui label" href=/tags/npm title=npm>npm</a>
<a class="ui label" href=/tags/react%E6%8A%80%E6%9C%AF%E6%A0%88 title=react技术栈>react技术栈</a>
<a class="ui label" href=/tags/vue%E6%8A%80%E6%9C%AF%E6%A0%88 title=vue技术栈>vue技术栈</a>
<a class="ui label" href=/tags/%E6%B5%8F%E8%A7%88%E5%99%A8 title=浏览器>浏览器</a>
<a class="ui label" href=/tags/%E7%AE%97%E6%B3%95 title=算法>算法</a>
<a class="ui label" href=/tags/%E7%BC%93%E5%AD%98 title=缓存>缓存</a>
<a class="ui label" href=/tags/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86 title=网络原理>网络原理</a>
<a class="ui label" href=/tags/%E8%84%9A%E6%89%8B%E6%9E%B6 title=脚手架>脚手架</a>
<a class="ui label" href=/tags/%E8%87%AA%E5%8A%A8%E5%8C%96 title=自动化>自动化</a>
<a class="ui label" href=/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F title=设计模式>设计模式</a>
<a class="ui label" href=/tags/%E8%AE%BE%E8%AE%A1%E6%B3%9B%E5%9E%8B title=设计泛型>设计泛型</a></section><section class="ui attached segment dream-categories"><div class="ui accordion"><div class=title><i class="dropdown icon"></i><a href=/categories/server class=item>server</a></div><div class=content><div class="ui list"><div class=item><div class=content><a href=/posts/server/01.nginx%E8%83%BD%E5%81%9A%E4%BB%80%E4%B9%88/ class=item>nginx能做什么</a></div></div></div></div><div class=title><i class="dropdown icon"></i><a href=/categories/%E5%85%B6%E4%BB%96 class=item>其他</a></div><div class=content><div class="ui list"><div class=item><div class=content><a href=/posts/%E5%85%B6%E4%BB%96/01.%E5%AD%A9%E5%AD%90-%E4%BD%A0%E8%A6%81%E8%B7%91%E5%95%8A/ class=item>孩子, 你要跑啊 - 待发布</a></div></div><div class=item><div class=content><a href=/posts/%E5%85%B6%E4%BB%96/02.%E5%86%8D%E4%B9%9F%E7%9C%8B%E4%B8%8D%E6%83%AF%E6%82%B2%E5%89%A7%E7%9A%84%E6%88%91%E4%BB%AC/ class=item>再也看不惯悲剧的我们-《飞驰人生》</a></div></div></div></div><div class=title><i class="dropdown icon"></i><a href=/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80 class=item>前端基础</a></div><div class=content><div class="ui list"><div class=item><div class=content><a href=/posts/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/01.%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84this/ class=item>JavaScript之你不知道的this</a></div></div><div class=item><div class=content><a href=/posts/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/02.css%E5%B7%A6%E5%8F%B3div%E5%85%83%E7%B4%A0%E8%87%AA%E9%80%82%E5%BA%94%E7%AD%89%E9%AB%98/ class=item>CSS: 左右div元素自适应等高</a></div></div></div></div><div class=title><i class="dropdown icon"></i><a href=/categories/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6 class=item>前端框架</a></div><div class=content><div class="ui list"><div class=item><div class=content><a href=/posts/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/02.%E5%AF%B9%E6%AF%94-react-hooks-%E5%92%8C-vue-composition-api/ class=item>对比 React Hooks 和 Vue Composition API</a></div></div><div class=item><div class=content><a href=/posts/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/01.diff%E7%AE%97%E6%B3%95/ class=item>聊一聊Diff算法（React、Vue）</a></div></div></div></div><div class=title><i class="dropdown icon"></i><a href=/categories/%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0 class=item>开发日记</a></div><div class=content><div class="ui list"><div class=item><div class=content><a href=/posts/%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0/01.%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%84%E5%BB%BA%E5%8D%9A%E5%AE%A2/ class=item>GitHub Action + Hugo 自动构建发布个人博客</a></div></div><div class=item><div class=content><a href=/posts/%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0/08.npm-publish-%E5%8F%91%E5%B8%83npm%E5%8C%85/ class=item>Node: npm publish 发布npm包</a></div></div><div class=item><div class=content><a href=/posts/%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0/05.nginx-%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E9%85%8D%E7%BD%AE/ class=item>nginx 反向代理配置</a></div></div><div class=item><div class=content><a href=/posts/%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0/07.node%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84node-server/ class=item>Node: 最简单的node server</a></div></div><div class=item><div class=content><a href=/posts/%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0/06.git%E4%B8%ADssh%E4%B8%8Ehttps/ class=item>git中ssh与https</a></div></div></div></div><div class=title><i class="dropdown icon"></i><a href=/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86 class=item>计算机原理</a></div><div class=content><div class="ui list"><div class=item><div class=content><a href=/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/03.%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5url%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/ class=item>浏览器输入url发生了什么(http)</a></div></div><div class=item><div class=content><a href=/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/01.%E5%BD%BBjavascript%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6event-loop/ class=item>彻底弄懂JavaScript执行机制（Event Loop）</a></div></div><div class=item><div class=content><a href=/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/04.http%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/ class=item>http缓存机制及其原理</a></div></div><div class=item><div class=content><a href=/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/05.%E8%B0%88%E8%B0%88js%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%B3%9B%E5%9E%8B/ class=item>谈谈 JS 和 设计泛型</a></div></div><div class=item><div class=content><a href=/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/02.javascript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%80/ class=item>聊一聊JavaScript设计模式（一）</a></div></div></div></div></div></section><section class="ui attached segment header-socials"><nav class="ui secondary menu dream-menu dream-socials"><div class=item><a href=mailto:wanderlian@foxmail.com><i class="mail icon" title=Email></i></a></div><div class=item><a href=https://github.com/lianpf target=_blank><i class="github icon" title=GitHub></i></a></div></nav></section><section class="ui bottom attached center aligned segment"><p>© 2016 - 2020 曜灵（SUN）Site</p><p>Powered by <a href=https://gohugo.io/ target=_blank>Hugo</a> with theme <a href=https://github.com/g1eny0ung/hugo-theme-dream target=_blank>Dream</a>.</p></section></article></div></div></div></section><section class=back><div class=dream-max-width><div class="ui centered relaxed grid dream-grid dream-back"><section class="sixteen wide mobile eight wide tablet four wide computer column dream-column"><article><div class="ui top attached segment"><h3 class="ui header">关于我</h3></div><div class="ui bottom attached segment markdown-body"><p>大家好，欢迎来到“曜灵”的个人博客。</p><p>博主是中通快递集团上海总部，平台工具组的一名软件</p><p>开发工程师。涉及前端 React技术栈、Vue技术栈、设计模式、算法，webpack、node自动构建打包工程化等，以及node相关的领域。
工作之余，也期望投入一些公关的领域为社区做一些自己的贡献，现有两个独立的开源项目</p><ul><li>react PC 组件库<a href=https://www.npmjs.com/package/react-pc-ui>react-pc-ui</a></li><li>脚手架：选择 template 快速搭建 webpack + react + vue项目 <a href=https://www.npmjs.com/package/@lianpf/create-app-cli>@lianpf/create-app-cli</a></li></ul><p>希望和大家一起成长，以下是我个人的社交类账号：</p><ul><li><a href=https://github.com/lianpf>gitHub</a></li><li>微信公众号：连先生有猫病</li><li>掘金：曜灵</li></ul><p>欢迎大家关注我的微信公众号，有好的文章可以关注公众号，获取博主个人微信投稿。文章内容不局限于技术！</p></div></article></section><section class="sixteen wide mobile eight wide tablet four wide computer column dream-column"><article><div class="ui top attached segment"><h3 class="ui header">社交链接</h3></div><div class="ui bottom attached segment"><nav class="ui secondary menu dream-menu dream-socials"><div class=item><a href=mailto:wanderlian@foxmail.com><i class="large mail icon" title=Email></i></a></div><div class=item><a href=https://github.com/lianpf target=_blank><i class="large github icon" title=GitHub></i></a></div></nav></div></article></section><section class="sixteen wide mobile eight wide tablet four wide computer column dream-column"></section></div></div></section></div></div><script>window.darkNav=true</script><script src=/js/jquery.min.js></script><script src=/js/semantic.min.js></script><script src=/js/jquery.overlayScrollbars.min.js></script><script src=/js/header.js></script><script src=/js/main.js></script><script src=/js/theme.js></script><script src=/js/html2canvas.min.js></script><script src=/js/post.js></script><script src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/highlight.min.js></script><script src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/languages/ocaml.min.js></script><script>hljs.initHighlightingOnLoad()
setHighlightTheme()
function setHighlightTheme(){var isDark=localStore.getItem('hugo-theme-dream-is-dark')
var lightTheme="gruvbox-light"
var darkTheme="gruvbox-dark"
var theme=isDark?darkTheme:lightTheme
$('link[data-highlight]').attr('href','https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/styles/'+theme+'.min.css')
$('pre').css('background',isDark?'#333':'')}</script><div class="ui inverted segment" id=dream-search><div class="ui search"><div class="ui transparent input"><input class=prompt type=text placeholder=搜索></div><div class=results></div></div></div><script>$(document).ready(function(){$.getJSON('\//index.json',function(data){$('.ui.search').search({source:data,searchFields:['title'],showNoResults:true,})})})</script><script src=/js/search.js></script></body></html>