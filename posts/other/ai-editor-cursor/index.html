<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Cursor AI 编辑器完全指南 - 革命性的 AI 代码编辑器 | 曜灵（SUN）Site</title><meta name=keywords content="Cursor,AI编辑器"><meta name=description content="Cursor AI 编辑器完全功能指南，包含1.0.0-1.3.0版本核心功能、AI 模式、快捷键操作及最新配置选项详细介绍"><meta name=author content="曜灵"><link rel=canonical href=https://lianpf.github.io/posts/other/ai-editor-cursor/><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.js onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://lianpf.github.io/img-common/favicon.png><link rel=icon type=image/png sizes=16x16 href=https://lianpf.github.io/img-common/favicon.png><link rel=icon type=image/png sizes=32x32 href=https://lianpf.github.io/img-common/favicon.png><link rel=apple-touch-icon href=https://lianpf.github.io/img-common/avatar.jpeg><link rel=mask-icon href=https://lianpf.github.io/img-common/avatar.jpeg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script defer src=https://unpkg.com/mermaid@8.8.1/dist/mermaid.min.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css><script src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script>
<script src=https://cdn.jsdelivr.net/npm/jquery@3.6.3/dist/jquery.min.js></script>
<script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script><style>.fa-commenting-o,#post_meta_style_8,#comment_count,.comment-count,.comment-icon,svg[class*=comment],a[aria-label*=comment]{display:none!important}</style><meta property="og:title" content="Cursor AI 编辑器完全指南 - 革命性的 AI 代码编辑器"><meta property="og:description" content="Cursor AI 编辑器完全功能指南，包含1.0.0-1.3.0版本核心功能、AI 模式、快捷键操作及最新配置选项详细介绍"><meta property="og:type" content="article"><meta property="og:url" content="https://lianpf.github.io/posts/other/ai-editor-cursor/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-07-07T10:31:49+08:00"><meta property="article:modified_time" content="2025-08-12T15:30:00+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Cursor AI 编辑器完全指南 - 革命性的 AI 代码编辑器"><meta name=twitter:description content="Cursor AI 编辑器完全功能指南，包含1.0.0-1.3.0版本核心功能、AI 模式、快捷键操作及最新配置选项详细介绍"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"📚文章","item":"https://lianpf.github.io/posts/"},{"@type":"ListItem","position":2,"name":"📚 其他","item":"https://lianpf.github.io/posts/other/"},{"@type":"ListItem","position":3,"name":"Cursor AI 编辑器完全指南 - 革命性的 AI 代码编辑器","item":"https://lianpf.github.io/posts/other/ai-editor-cursor/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Cursor AI 编辑器完全指南 - 革命性的 AI 代码编辑器","name":"Cursor AI 编辑器完全指南 - 革命性的 AI 代码编辑器","description":"Cursor AI 编辑器完全功能指南，包含1.0.0-1.3.0版本核心功能、AI 模式、快捷键操作及最新配置选项详细介绍","keywords":["Cursor","AI编辑器"],"articleBody":"Cursor AI 是一款革命性的 AI 驱动代码编辑器，基于 VS Code 构建，集成了强大的人工智能功能，可以显著提升开发效率和代码质量。本指南将从基础概念到实际配置，全面介绍如何高效使用 Cursor AI。\n一、Cursor AI 简介 1、什么是 Cursor AI？ Cursor AI 是基于 Visual Studio Code 构建的 AI 驱动代码编辑器，由 Anysphere 公司开发。它不仅保留了 VS Code 的所有优秀特性，还深度集成了多种先进的 AI 模型，为开发者提供智能化的编程体验。\n2、主要特点 VS Code 兼容性：完全兼容 VS Code 插件生态系统 多模型支持：集成 GPT-4、Claude、Gemini 等多种 AI 模型 智能上下文理解：自动理解整个代码库的结构和逻辑 多模态交互：支持文本、图像等多种输入方式 实时协作：支持团队级别的 AI 协作功能 3、核心功能概览 智能代码补全：Tab 功能提供多行预测和智能重写 AI 对话助手：Chat 模式提供代码解释和建议 自动代码生成：Composer/Agent 模式直接生成和修改代码 终端命令执行：AI 可以自动生成和执行终端命令 上下文感知搜索：智能理解代码库结构，提供精准建议 重构优化：对现有代码进行重构和优化 错误修复：自动检测并修复代码错误 二、核心功能详解 1、快捷键 Ctrl/Cmd + L 打开聊天面板 编辑器： 修改代码：选择代码后，使用 Cmd + K 快捷键进行修改 生成新代码：在空白处使用 Cmd + K 快捷键生成新代码 发送到聊天：使用 Cmd + L 将选中的代码发送到聊天 新建聊天: Cmd + N 模型切换: Cmd + Option + / 聊天切换：上一个聊天Cmd + [、上一个聊天Cmd + ] 关闭聊天：Cmd + W 消息切换：Tab 切换到下一条消息、Shift + Tab 切换到上一条消息 终端：使用 Cmd + K 在底部打开提示栏 取消AI生成： Cmd + Shift + Delete 接受所有更改：Cmd + Enter 拒绝所有更改：Cmd + Delete 其他\nCmd + Shift + J 打开Cursor Setting Cmd + , 打开通用设置 Cmd + Shift + P 打开命令面板 更多快捷键，参考 Cursor编辑器 / 快捷键\n2、Tab 智能补全 多行预测：预测接下来多行代码的编写 智能重写：自动修正代码错误和不规范写法 光标预测：预测光标的下一个最佳位置 上下文感知：基于最近修改提供相关建议 配置选项：可调整补全的激进程度和触发条件 设置 描述 Cursor Tab 基于最近编辑的上下文感知多行建议，围绕您的光标位置 Partial Accepts 通过 Cmd → 接受建议的下一个单词 Suggestions While Commenting 在注释块内启用 Tab Whitespace-Only Suggestions 允许仅影响格式的编辑 Imports\t为 TypeScript 启用自动导入 Auto Import for Python (beta) 为 Python 项目启用自动导入 3、AI 智能体（聊天窗口） 3.1 聊天窗口 窗口管理：\n新增上下文：通过 @ 符号或拖拽文件添加 切换上下文：点击 Tab 在不同的上下文集合间切换 历史记录：（时钟符号）查看和管理Agent过去的聊天对话 注意：后台Background代理聊天不在常规历史记录中，而是存储在远程数据库中（使用⌘ + E来查看） 聊天窗口核心功能：\n检查点（Agent对代码库更改的自动快照）：点击之前请求上的Restore Checkpoint按钮，撤销 Agent 的修改 导出Agent聊天记录：点击上下文菜单 → “Export Chat” 复制/分叉聊天：从对话中的任意点创建分支，以探索替代解决方案，而不会丢失当前对话 操作：点击消息上的三个点 / 选择”Duplicate Chat” Todos规划：Agent 自动为复杂任务创建待办事项列表 实际使用示例\n# 代码解释请求 @component.tsx 解释这个组件的工作原理 # 文档查询 @Web React 18 的最佳实践是什么？ # 多文件分析 @src/utils @src/components 这两个模块之间的依赖关系如何？ 3.2 选择AI 工作模式 工作模式简述：\nAgent 模式：最智能和自主的模式。AI 可以主动选择上下文和使用工具、能够执行复杂的多步骤任务，可以访问终端、搜索代码库、创建和修改多个文件、具有\"推理\"能力，可以制定和执行计划 场景：多个文件的复杂重构、从零到一的完整功能模块开发、跨文件分析和修复bug的复杂调试、项目结构调整和代码分析 —— 重点\"跨文件\" Ask 模式：主要用于问答和解释、可以搜索代码库获取上下文、不会主动修改代码、专注于提供信息和建议 场景：非常适合在修改代码之前理解代码。理解某段代码的工作原理、项目中的设计模式或架构、查找特定功能的实现位置、实现某个功能的建议、文档查询和最佳实践 Manual 模式（1.0版本）：传统的编辑器模式、AI 功能被限制，主要依赖手动编程、保持对代码的完全控制、类似于普通的 VS Code 体验 场景：完全手动控制的精细代码修改、安全敏感或关键业务逻辑、简单的代码修改、审查代码 Background Agents（1.3版本新增）：后台运行的智能助手、持续监控代码质量、自动优化和建议、云端处理能力。 场景：持续代码质量监控、自动化优化建议、后台分析和改进 选择策略：\n从大到小：复杂任务用 Agent，问答用 Ask，简单编辑用 Manual 根据自主性：需要 AI 主动行动则选 Agent；需要信息则选 Ask；需要完全控制选 Manual 根据影响范围：多文件操作用 Agent，单文件查询用 Ask，局部编辑用 Manual 工作流建议：\n项目开始 → Agent 模式（架构设计、基础代码） ↓ 开发过程 → Ask 模式（疑问解答、方案咨询） ↓ 精细调试 → Manual 模式（精确控制、最终优化） 4、规则 规则为Agent和内联编辑，提示提供持久的、可重用的一致性上下文，用于生成代码、解释编辑或协助工作流程。\n注意：Cmd + K 不会应用【项目规则】的上下文\n支持三种类型的规则\n项目规则：存储在 .cursor/rules 中，受版本控制并作用于你的代码库。 用户规则： Cursor Settings → Rules中设置全局偏好设置，始终应用于你的 Cursor 环境。 .cursorrules（旧版）：仍然支持，但已弃用。请改用项目规则。 4.1 项目规则 *.mdc 本身就是md文档，加上一些自己的语法\n使用Cursor Settings \u003e Rules，会在项目根目录下创建.cursor/rules/xxx.mdc格式的项目规则。 项目规则的作用：\n编码关于代码库的领域特定知识 自动化项目特定的工作流程或模板 标准化样式或架构决策 最佳实践\n好的规则应该是专注的、可操作的和有明确范围的 保持规则在500行以内 将大型规则拆分为多个可组合的规则 提供具体的示例或引用文件 避免模糊的指导。编写规则时要像清晰的内部文档一样 在聊天中重复提示时重用规则 4.1.1 规则结构 I. 规则 规则以.mdc编写，核心元数据：description、globs、alwaysApply。下面是与 UI 下拉选项的对应关系：\nUI 选项 规则类型 触发时机 关键字段 Always Apply Always 始终包含到模型上下文,无论何时都会生效 alwaysApply: true Apply Intelligently Agent Requested 由 AI 判定是否需要 alwaysApply: false 且需 description Apply to Specific Files Auto Attached 引用匹配 globs 的文件时自动包含 globs 列表、alwaysApply: false Apply Manually Manual 仅在聊天中 @规则名 时包含 alwaysApply: false .mdc 通用模板：\n--- description: 用一句话概述这条规则做什么 globs: - path/pattern/**/* alwaysApply: false --- - 列出应遵循的要点 - 可以多条 @some-file-or-template.ext 示例（整理版）：\n--- description: 内部 RPC Service 规范 globs: alwaysApply: false --- - 使用内部 RPC 模式定义服务 - 服务名一律使用 snake_case @service-template.ts # 引用文件在规则触发时作为额外上下文包含 若选择“Apply Manually”，需在对话中 @规则名 才会包含。 选择“Apply to Specific Files”时应补充 globs，引用匹配文件即自动启用。 选择“Always Apply”则将 alwaysApply 设为 true。 II. 规则场景示例 几种规则类型汇总与适用场景：\nAlways（总是）：规则始终注入到所有对话中，适合“团队必须遵守的核心规范”。\n适用场景：通用编码规范（代码风格、命名、安全）、文档格式约定、项目全局约束 示例：禁止硬编码密钥；统一使用 TypeScript；React 组件命名与导出规范 Auto Attached（自动附加）：当引用到匹配 globs 的文件时才包含，减少不必要的规则负载。\n适用场景：与文件类型/路径强相关的实践与模板 示例：*.test.ts 中的测试风格；/api/** 的 RESTful 设计规范；某技术栈的 hooks 使用准则 Agent Requested（代理判断）：只有在智能体认为需要时才会包含，适合“需要深入思考的高级模式或架构决策”。\n适用场景：复杂任务的分解策略、性能优化手段、系统设计原则 示例：微服务架构设计原则；复杂算法优化策略；数据库设计模式 Manual（手动）：必须在对话中 @规则名 明确提及才包含，适合“新规、敏感或仅作参考的材料”。\n适用场景：部署/安全清单、非常见或实验性的写法指南、临时作业说明 示例：特定客户的定制要求；实验性的新框架使用规范；安全审计检查清单 项目初期推荐配置（建议）：\nAlways：基础编码规范与项目约定 Auto Attached：文件类型相关规则（测试、API、组件等） Agent Requested：架构/复杂设计类指引 Manual：特殊需求与参考文档 团队协作最佳实践：\nAlways → 团队必须遵守的核心规范 Auto Attached → 智能上下文附加的领域规则 Agent Requested → 复杂决策支持 Manual → 灵活的参考资源 4.1.2 嵌套规则 在整个项目的 .cursor/rules 目录中组织规则。当引用其目录中的文件时，嵌套规则会自动附加。\nproject/ .cursor/rules/ # 项目范围的规则 backend/ server/ .cursor/rules/ # 后端特定规则 frontend/ .cursor/rules/ # 前端特定规则 4.1.3 生成规则 当代理行为做出决策，你希望从聊天中生成项目规则。使用 /Generate Cursor Rules 命令直接在对话中生成规则\n4.2 用户规则 在 Cursor Settings → Rules 中定义的全局偏好设置，适用于所有项目。它们是纯文本格式，适合设置首选的沟通风格或编码约定.\n1. 请使用中文回答问题。 2. 请保证最小化改动代码。 5、记忆（1.3.0新增） 记忆是基于你在聊天中的对话自动生成的规则。作用范围限定在你的项目内，并在会话之间保持上下文。\n当您明确要求 Agent 记住某些内容或当它注意到应该为未来会话保留的重要信息时，Agent 可以直接使用工具调用创建记忆。\nMemory created生成 或Memory updated更新记忆 View Memories 查看记忆 管理记忆：Cursor Setting → 规则中管理记忆： 三、上下文 1、代码库索引Codebase Indexing 当你打开一个项目时，Cursor自动为每个文件计算嵌入向量，来索引代码库。目的是为了提高 AI 生成的和你代码相关的答案质量。\n检查索引状态：Cursor Settings \u003e Indexing \u0026 Docs。如上图中【1】位置 默认索引新文件：图中【位置2】-\u003e Index New Folders。新增文件会增量索引 查看已索引的文件: 图中【位置2】-\u003e Ignore Files in .cursorignore -\u003e View included files，会打开一个列出所有已索引文件的 .txt 文件。 忽略文件：忽略文件（例如 .gitignore、.cursorignore、.cursorindexingignore）中指定的所有文件，不会被索引。 .cursorignore: 图中【位置2】-\u003e Ignore Files in .cursorignore 使用.cursorindexingignore仅从索引中排除文件。文件仍可被 AI 功能访问，但不会出现在代码库搜索中。 全局忽略文件：Cmd + ,(用户设置) -\u003e 搜索： Global Cursor Ignore List，设置所有项目的忽略模式 其他默认的忽略文件，参考：Cursor上下文/忽略文件 团队仓库控制范围：图中【位置2】-\u003e Team-Level Repository Control。团队设置仓库范围的控制模式，用于确定哪些文件包含在索引中 2、MCP Model Context Protocol (MCP)使 Cursor 能够连接到外部工具和数据源。\nMCP服务器：Cursor文档 / MCP服务器 添加 MCP 到 Cursor: 项目中创建 .cursor/mcp.json 用于项目特定的工具。或在主目录中创建 ~/.cursor/mcp.json 全局工具的配置 { \"mcpServers\": { \"server-name\": { \"command\": \"npx\", \"args\": [\"-y\", \"mcp-server\"], \"env\": { \"API_KEY\": \"value\" } } } } 3、@符号 常用功能：\n@Files文件名 - 引用项目中的特定文件 @Folders - 引用整个文件夹以获得更广泛的上下文 @Code - 引用代码库中的特定代码片段或符号 @Past Chats - 引用其他标签页或之前会话的上下文(聊天记录) @Cursor Rules - 使用 cursor 规则 @Docs - 访问文档和指南 @Web - 搜索外部网络资源和文档 @LibraryName - 引用流行库的官方文档 其他功能：\n@Git - 访问 git 历史记录和更改\n@Link (paste) - 创建指向特定代码或文档的链接，并获取内容作为上下文使用。\n要将URL用作纯文本而不获取其内容： 方式1：点击标记的链接并选择Unlink 方式2：在粘贴时按住Shift 键，以防止自动标记 @Recent Changes - 将最近的10次（时间顺序）代码更改，作为上下文包含在 AI 对话中\n@Lint Errors - 自动捕获并提供当前活动文件中，代码检查错误和警告的上下文信息\n# Files - 将文件添加到上下文中而不引用\n/command - 支持添加\"激活的文件\"（编辑器中已打开标签页）到上下文中 /Reset Context: 将上下文重置为默认状态 /Generate Cursor Rules: 为 Cursor 生成要遵循的规则 /Disable Iterate on Lints: 不会尝试修复代码检查错误和警告 /Add Open Files to Context: 引用当前打开的所有编辑器标签页 /Add Active Files to Context: 引用当前视图中的所有编辑器标签页（在分屏布局中很有用） 四、模型Models 1、基础概念：上下文窗口 上下文窗口是LLM一次可以共同考虑的最大token范围（包含输入与模型输出）。 在 Cursor 中，默认可用约 200k tokens（约 1.5 万行代码）；开启 Max Mode 可将上下文扩展到所选模型的最大上限，但速度更慢、成本更高。\n2、模式选择 Max Mode：将上下文扩展到模型上限，适合跨仓库/跨多文件的大型重构、复杂架构设计、长文档推理；权衡是更慢、更贵。 Auto：由 Cursor 按任务自动选择更合适的高级模型，适合日常开发与通用场景；权衡是偶尔不够“稳”。 3、任务-模型选型建议 可用模型列表:\nClaude-4-Sonnet：Anthropic 的旗舰模型，擅长代码生成 o3：OpenAI 的推理模型，适合复杂问题解决 Gemini-2.5-Pro：Google 的多模态模型 GPT-4.1：OpenAI 的通用模型 Claude-3.7-Sonnet：平衡性能和成本的选择 Cursor-Small：Cursor 自有模型，无限制使用 o4-Mini：轻量级快速响应模型 模型选择建议：\n高复杂度任务：使用 Max Mode 搭配 o3 / Claude 4（复杂架构、算法/设计） 中等复杂度任务：Claude 3.5 / GPT-4.1（常规开发、重构） 轻量/快速任务：Auto 模式（代码补全、局部小改动） 模型使用提示：\n带 🧠 脑洞图标的大模型：表示具有高级推理能力的模型；适用于复杂逻辑推理、数学计算、架构设计，常消耗更多 tokens 高级模型：Claude / GPT-4o（会扣除“快速调用”的次数） 轻量模型：cursor-small、o4-mini（适合 Cmd + K、函数级优化、行内修改） 模型侧重：Claude 更擅长代码推理与重构；GPT-4o 更擅长通用问答与多媒体理解 局部修改优先小模型；若输出不稳定，可切换 Auto 或较新的大模型 追求稳定与一致性：优先选择最新可用模型版本 注意：Cursor AI 持续快速发展，功能和界面会不断更新。建议定期查看官方文档获取最新信息，并根据实际需求调整使用策略。\n附录 设置Cursor工具栏方向 Cursor设置（快捷键Cmd + ,） -\u003e 搜索 Workbench › Activity Bar: Orientation， 选择 vertical\n常用的Cursor Settings（1.3.0） Cursor Tab Cursor Chat 默认模式 Default Mode（Agent）：新会话默认 Agent；写长文/精准改写可切 Composer。 默认位置 Default Location（Pane）：在侧边面板打开；需要在编辑器区域打开用 Editor。 文本大小 Text Size（Default）：调整聊天字体；演示时调大一档。 自动清理会话 Auto-Clear Chat（开启）：闲置后新开会话更干净；要持续上下文则关闭。 自动滚动到新消息 Scroll to New Messages（开启）：新回复自动滚动到底部，建议保持。 完成音效 Completion Sound（关闭）：回复完成提示音；需要提醒时再开启。 待办清单 To-Do List（开启）：允许跟踪任务进度，长任务建议开启。 消息排队 Queue Messages（开启）：流式回复排队防乱序；需要即时打断时可关闭。 自定义模式 Custom Modes（开启，Beta）：可建模型/工具/指令预设；建议建\"重构TS/写文档/单测生成\"等。 Context上下文\nInclude Full-Folder Context（开）：将文件夹内所有文件纳入上下文，便于全局理解，但更耗资源。 Web Search Tool（开）：允许联网查询补充信息，涉及隐私时可关闭。 Hierarchical Cursor Ignore（关）：让 .cursorignore的忽略规则向下继承，作用到所在目录的所有子目录与文件。切换该开关后需要重启 Cursor 生效。 Backspace Removes Context（开）：当光标在输入框“最开头”时，按下Backspace / Delete不会删文字，而是“弹出”最后一个上下文胶囊（context pill）。相当于用键盘快速移除最近添加的上下文，按一次删一个，顺序是后进先出。 Applying Changes应用变更\nOut-of-Context Edits in Review Mode（开）：Review Mode模式下，允许修改不在当前选中上下文/文件列表的其他文件。即许跨文件、跨目录地联动修改。 Auto-Fix Lints（开）：自动应用可修复的 Lint 规则 Auto-Accept on Commit（关）：文件提交时，自动接受聊天中的变更 Auto-Run自动执行配置\nAuto-Run Mode（开）：允许 Agent 在无需确认的情况下，执行命令、写文件。适用于连续构建/测试/重构等流水作业，但存在误执行风险。 Command Allowlist（空）：白名单内的命令可被自动执行；未在名单内的命令仍需确认。开启自动运行时务必配置白名单，只放安全、幂等命令。 npm ci npm run build go test ./... File-Deletion Protection（关）：阻止 Agent 自动删除文件。关闭状态风险较高，团队项目建议开启。 MCP Tools Protection（关）：阻止 Agent 自动调用 MCP 工具。关闭可能触发外部副作用，生产环境建议开启。 Dotfile Protection（开）：阻止自动修改点文件（如 .gitignore、.npmrc）。避免全局配置被意外改动，建议保持开启。 External-File Protection（开）：阻止在工作区外创建/修改文件。防止越权写入，强烈建议保持开启。 Inline Editing行内编辑器 \u0026 Terminal终端配置\n工具栏高亮 Toolbar on Selection（开）：选中代码时显示“Add to Chat/Quick Edit”快捷按钮，建议开启。 自动解析链接 Auto-Parse Links（关）：自动将粘贴到输入框中的URL转为上下文，担心隐私时保持关闭。 自动选区 Auto-Select Code Regions for Quick Edit（开）：Cmd + K时，自动框定代码（模）块，建议开启。 主题化差异背景 Themed Diff Backgrounds（开）：使用主题色背景显示差异，建议开启。 字符级差异 Character-Level Diffs（开）：显示具体字符变更高亮，建议开启。 终端提示 Terminal Tooltips（开）：终端显示\"Add to chat\"等提示，建议开启。 终端快捷提示 Terminal Hint（开）：终端提示可用⌘K，建议开启。 终端预览框 Preview Box for Terminal ⌘K（关）：AI回复先在预览框展示，避免命令直接流入shell执行，安全需求时可开启。 集成Bugbot代码审查、Slack和Github Background Agents 后台代理\nGitHub 连接：连接 GitHub 进行代码库分析和 PR 协助 Slack 集成：直接在 Slack 中使用 Cursor 功能 持续集成：与 CI/CD 流程集成 参考资源 Cursor 官方网站 Cursor 官方文档 Cursor.Directory - 规则和插件目录 CursorList - 最佳实践集合 DotCursorRules - 规则文档 Cursor AI 模式对比教程 Cursor AI 工作流程最佳实践 最后， 希望大家早日实现：成为编程高手的伟大梦想！ 欢迎交流~\n本文版权归原作者曜灵所有！未经允许，严禁转载！对非法转载者, 原作者保留采用法律手段追究的权利！ 若需转载，请联系微信公众号：连先生有猫病，可获取作者联系方式！\n","wordCount":"7405","inLanguage":"zh","datePublished":"2025-07-07T10:31:49+08:00","dateModified":"2025-08-12T15:30:00+08:00","author":[{"@type":"Person","name":"曜灵"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://lianpf.github.io/posts/other/ai-editor-cursor/"},"publisher":{"@type":"Organization","name":"曜灵（SUN）Site","logo":{"@type":"ImageObject","url":"https://lianpf.github.io/img-common/favicon.png"}}}</script></head><body id=top><script>(function(){let e,t=new RegExp("(^| )change-themes=([^;]*)(;|$)");(e=document.cookie.match(t))||((new Date).getHours()>=19||(new Date).getHours()<6?(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark")):(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")))})(),localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://lianpf.github.io/ accesskey=h title="曜灵（SUN）Site (Alt + H)"><img src=https://lianpf.github.io/img-common/avatar.jpeg alt=logo aria-label=logo height=35>曜灵（SUN）Site</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://lianpf.github.io/search title="🔍 搜索 (Alt + /)" accesskey=/><span>🔍 搜索</span></a></li><li><a href=https://lianpf.github.io/ title="🏠 主页"><span>🏠 主页</span></a></li><li><a href=https://lianpf.github.io/archives/ title="⏱️ 归档"><span>⏱️ 归档</span></a></li><li><a href=https://lianpf.github.io/tags title="🧩 标签"><span>🧩 标签</span></a></li><li><a href=https://lianpf.github.io/about title="🙋🏻‍♂️ 关于"><span>🙋🏻‍♂️ 关于</span></a></li></ul></nav></header><main class="main page"><style>i[id*=post_meta_style]{display:flex;align-items:center;margin:0 0 10px}</style><article class=post-single><div id=single-content><header class=post-header><div class=breadcrumbs><a href=https://lianpf.github.io/>🏠 主页</a>&nbsp;»&nbsp;<a href=https://lianpf.github.io/posts/>📚文章</a>&nbsp;»&nbsp;<a href=https://lianpf.github.io/posts/other/>📚 其他</a></div><h1 class=post-title>Cursor AI 编辑器完全指南 - 革命性的 AI 代码编辑器</h1><div class=post-description>Cursor AI 编辑器完全功能指南，包含1.0.0-1.3.0版本核心功能、AI 模式、快捷键操作及最新配置选项详细介绍</div><div class=post-meta><style>i[id*=post_meta_style]{display:flex;align-items:center;margin:0 0 10px}.parent-post-meta{display:flex;flex-wrap:wrap;opacity:.8}</style><span class=parent-post-meta><span id=post_meta_style_1><span class="fa fa-calendar-check-o"></span>
<span>&nbsp;创建&nbsp;2025-07-07
&nbsp;&nbsp;</span></span>
<span id=post_meta_style_2><span class="fa fa-calendar-plus-o"></span>
<span>&nbsp;更新&nbsp;2025-08-12
&nbsp;&nbsp;</span></span>
<span id=post_meta_style_5><span class="fa fa-user-o"></span>
<span>曜灵
&nbsp;&nbsp;</span></span>
<span id=post_meta_style_6><span class="fa fa-tags" style=opacity:.8></span>
<span><span class=post-tags-meta><a href=https://lianpf.github.io/tags/%E5%B7%A5%E5%85%B7/ style=color:var(--secondary)!important>工具</a>
&nbsp;<a href=https://lianpf.github.io/tags/ai/ style=color:var(--secondary)!important>AI</a></span></span></span></span>
<span style=opacity:.8><span id=post_meta_style_7>&nbsp;&nbsp;
<span class="fa fa-eye"></span>
<span><span id=busuanzi_container_page_pv><span id=busuanzi_value_page_pv></span></span>
&nbsp;&nbsp;</span></span></span></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#%e4%b8%80cursor-ai-%e7%ae%80%e4%bb%8b aria-label="一、Cursor AI 简介">一、Cursor AI 简介</a><ul><li><a href=#1%e4%bb%80%e4%b9%88%e6%98%af-cursor-ai aria-label="1、什么是 Cursor AI？">1、什么是 Cursor AI？</a></li><li><a href=#2%e4%b8%bb%e8%a6%81%e7%89%b9%e7%82%b9 aria-label=2、主要特点>2、主要特点</a></li><li><a href=#3%e6%a0%b8%e5%bf%83%e5%8a%9f%e8%83%bd%e6%a6%82%e8%a7%88 aria-label=3、核心功能概览>3、核心功能概览</a></li></ul></li><li><a href=#%e4%ba%8c%e6%a0%b8%e5%bf%83%e5%8a%9f%e8%83%bd%e8%af%a6%e8%a7%a3 aria-label=二、核心功能详解>二、核心功能详解</a><ul><li><a href=#1%e5%bf%ab%e6%8d%b7%e9%94%ae aria-label=1、快捷键>1、快捷键</a></li><li><a href=#2tab-%e6%99%ba%e8%83%bd%e8%a1%a5%e5%85%a8 aria-label="2、Tab 智能补全">2、Tab 智能补全</a></li><li><a href=#3ai-%e6%99%ba%e8%83%bd%e4%bd%93%e8%81%8a%e5%a4%a9%e7%aa%97%e5%8f%a3 aria-label="3、AI 智能体（聊天窗口）">3、AI 智能体（聊天窗口）</a><ul><li><a href=#31-%e8%81%8a%e5%a4%a9%e7%aa%97%e5%8f%a3 aria-label="3.1 聊天窗口">3.1 聊天窗口</a></li><li><a href=#32-%e9%80%89%e6%8b%a9ai-%e5%b7%a5%e4%bd%9c%e6%a8%a1%e5%bc%8f aria-label="3.2 选择AI 工作模式">3.2 选择AI 工作模式</a></li></ul></li><li><a href=#4%e8%a7%84%e5%88%99 aria-label=4、规则>4、规则</a><ul><li><a href=#41-%e9%a1%b9%e7%9b%ae%e8%a7%84%e5%88%99 aria-label="4.1 项目规则">4.1 项目规则</a><ul><li><a href=#411-%e8%a7%84%e5%88%99%e7%bb%93%e6%9e%84 aria-label="4.1.1 规则结构">4.1.1 规则结构</a><ul><li><a href=#i-%e8%a7%84%e5%88%99 aria-label="I. 规则">I. 规则</a></li><li><a href=#ii-%e8%a7%84%e5%88%99%e5%9c%ba%e6%99%af%e7%a4%ba%e4%be%8b aria-label="II. 规则场景示例">II. 规则场景示例</a></li></ul></li><li><a href=#412-%e5%b5%8c%e5%a5%97%e8%a7%84%e5%88%99 aria-label="4.1.2 嵌套规则">4.1.2 嵌套规则</a></li><li><a href=#413-%e7%94%9f%e6%88%90%e8%a7%84%e5%88%99 aria-label="4.1.3 生成规则">4.1.3 生成规则</a></li></ul></li><li><a href=#42-%e7%94%a8%e6%88%b7%e8%a7%84%e5%88%99 aria-label="4.2 用户规则">4.2 用户规则</a></li></ul></li><li><a href=#5%e8%ae%b0%e5%bf%86130%e6%96%b0%e5%a2%9e aria-label=5、记忆（1.3.0新增）>5、记忆（1.3.0新增）</a></li></ul></li><li><a href=#%e4%b8%89%e4%b8%8a%e4%b8%8b%e6%96%87 aria-label=三、上下文>三、上下文</a><ul><li><a href=#1%e4%bb%a3%e7%a0%81%e5%ba%93%e7%b4%a2%e5%bc%95codebase-indexing aria-label="1、代码库索引Codebase Indexing">1、代码库索引<code>Codebase Indexing</code></a></li><li><a href=#2mcp aria-label=2、MCP>2、<code>MCP</code></a></li><li><a href=#3%e7%ac%a6%e5%8f%b7 aria-label=3、@符号>3、<code>@</code>符号</a></li></ul></li><li><a href=#%e5%9b%9b%e6%a8%a1%e5%9e%8bmodels aria-label=四、模型Models>四、模型<code>Models</code></a><ul><li><a href=#1%e5%9f%ba%e7%a1%80%e6%a6%82%e5%bf%b5%e4%b8%8a%e4%b8%8b%e6%96%87%e7%aa%97%e5%8f%a3 aria-label=1、基础概念：上下文窗口>1、基础概念：上下文窗口</a></li><li><a href=#2%e6%a8%a1%e5%bc%8f%e9%80%89%e6%8b%a9 aria-label=2、模式选择>2、模式选择</a></li><li><a href=#3%e4%bb%bb%e5%8a%a1-%e6%a8%a1%e5%9e%8b%e9%80%89%e5%9e%8b%e5%bb%ba%e8%ae%ae aria-label=3、任务-模型选型建议>3、任务-模型选型建议</a></li></ul></li><li><a href=#%e9%99%84%e5%bd%95 aria-label=附录>附录</a><ul><li><a href=#%e8%ae%be%e7%bd%aecursor%e5%b7%a5%e5%85%b7%e6%a0%8f%e6%96%b9%e5%90%91 aria-label=设置Cursor工具栏方向>设置Cursor工具栏方向</a></li><li><a href=#%e5%b8%b8%e7%94%a8%e7%9a%84cursor-settings130 aria-label="常用的Cursor Settings（1.3.0）">常用的<code>Cursor Settings</code>（1.3.0）</a><ul><li><a href=#cursor-tab aria-label="Cursor Tab"><code>Cursor Tab</code></a></li><li><a href=#cursor-chat aria-label="Cursor Chat"><code>Cursor Chat</code></a></li></ul></li><li><a href=#%e9%9b%86%e6%88%90bugbot%e4%bb%a3%e7%a0%81%e5%ae%a1%e6%9f%a5slack%e5%92%8cgithub aria-label=集成Bugbot代码审查、Slack和Github>集成<code>Bugbot</code>代码审查、<code>Slack</code>和<code>Github</code></a></li></ul></li><li><a href=#%e5%8f%82%e8%80%83%e8%b5%84%e6%ba%90 aria-label=参考资源>参考资源</a></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{elements&&(activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")}))},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><p>Cursor AI 是一款革命性的 AI 驱动代码编辑器，基于 VS Code 构建，集成了强大的人工智能功能，可以显著提升开发效率和代码质量。本指南将从基础概念到实际配置，全面介绍如何高效使用 Cursor AI。</p><hr><h2 id=一cursor-ai-简介>一、Cursor AI 简介<a hidden class=anchor aria-hidden=true href=#一cursor-ai-简介>#</a></h2><h3 id=1什么是-cursor-ai>1、什么是 Cursor AI？<a hidden class=anchor aria-hidden=true href=#1什么是-cursor-ai>#</a></h3><p>Cursor AI 是基于 Visual Studio Code 构建的 AI 驱动代码编辑器，由 Anysphere 公司开发。它不仅保留了 VS Code 的所有优秀特性，还深度集成了多种先进的 AI 模型，为开发者提供智能化的编程体验。</p><h3 id=2主要特点>2、主要特点<a hidden class=anchor aria-hidden=true href=#2主要特点>#</a></h3><ul><li><strong>VS Code 兼容性</strong>：完全兼容 VS Code 插件生态系统</li><li><strong>多模型支持</strong>：集成 GPT-4、Claude、Gemini 等多种 AI 模型</li><li><strong>智能上下文理解</strong>：自动理解整个代码库的结构和逻辑</li><li><strong>多模态交互</strong>：支持文本、图像等多种输入方式</li><li><strong>实时协作</strong>：支持团队级别的 AI 协作功能</li></ul><h3 id=3核心功能概览>3、核心功能概览<a hidden class=anchor aria-hidden=true href=#3核心功能概览>#</a></h3><ul><li><strong>智能代码补全</strong>：Tab 功能提供多行预测和智能重写</li><li><strong>AI 对话助手</strong>：Chat 模式提供代码解释和建议</li><li><strong>自动代码生成</strong>：Composer/Agent 模式直接生成和修改代码</li><li><strong>终端命令执行</strong>：AI 可以自动生成和执行终端命令</li><li><strong>上下文感知搜索</strong>：智能理解代码库结构，提供精准建议</li><li><strong>重构优化</strong>：对现有代码进行重构和优化</li><li><strong>错误修复</strong>：自动检测并修复代码错误</li></ul><hr><h2 id=二核心功能详解>二、核心功能详解<a hidden class=anchor aria-hidden=true href=#二核心功能详解>#</a></h2><h3 id=1快捷键>1、快捷键<a hidden class=anchor aria-hidden=true href=#1快捷键>#</a></h3><ul><li><code>Ctrl/Cmd + L</code> 打开聊天面板</li><li><strong>编辑器</strong>：<ul><li>修改代码：选择代码后，使用 <code>Cmd + K</code> 快捷键进行修改</li><li>生成新代码：在空白处使用 <code>Cmd + K</code> 快捷键生成新代码</li><li>发送到聊天：使用 <code>Cmd + L</code> 将选中的代码发送到聊天</li><li>新建聊天: <code>Cmd + N</code></li><li>模型切换: <code>Cmd + Option + /</code></li><li>聊天切换：上一个聊天<code>Cmd + [</code>、上一个聊天<code>Cmd + ]</code></li><li>关闭聊天：<code>Cmd + W</code></li><li>消息切换：<code>Tab</code> 切换到下一条消息、<code>Shift + Tab</code> 切换到上一条消息</li></ul></li></ul><ul><li><strong>终端</strong>：使用 <code>Cmd + K</code> 在底部打开提示栏</li><li><strong>取消AI生成</strong>： <code>Cmd + Shift + Delete</code></li><li><strong>接受所有更改</strong>：<code>Cmd + Enter</code></li><li><strong>拒绝所有更改</strong>：<code>Cmd + Delete</code></li></ul><p><strong>其他</strong></p><ul><li><code>Cmd + Shift + J</code> 打开<code>Cursor Setting</code></li><li><code>Cmd + ,</code> 打开通用设置</li><li><code>Cmd + Shift + P</code> 打开命令面板</li></ul><p>更多快捷键，参考 <a href=https://docs.cursor.com/zh/configuration/kbd>Cursor编辑器 / 快捷键</a></p><h3 id=2tab-智能补全>2、Tab 智能补全<a hidden class=anchor aria-hidden=true href=#2tab-智能补全>#</a></h3><ul><li><strong>多行预测</strong>：预测接下来多行代码的编写</li><li><strong>智能重写</strong>：自动修正代码错误和不规范写法</li><li><strong>光标预测</strong>：预测光标的下一个最佳位置</li><li><strong>上下文感知</strong>：基于最近修改提供相关建议</li><li><strong>配置选项</strong>：可调整补全的激进程度和触发条件</li></ul><table><thead><tr><th style=text-align:left>设置</th><th style=text-align:left>描述</th></tr></thead><tbody><tr><td style=text-align:left>Cursor Tab</td><td style=text-align:left>基于最近编辑的上下文感知多行建议，围绕您的光标位置</td></tr><tr><td style=text-align:left>Partial Accepts</td><td style=text-align:left>通过 <code>Cmd →</code> 接受建议的下一个单词</td></tr><tr><td style=text-align:left>Suggestions While Commenting</td><td style=text-align:left>在注释块内启用 Tab</td></tr><tr><td style=text-align:left>Whitespace-Only Suggestions</td><td style=text-align:left>允许仅影响格式的编辑</td></tr><tr><td style=text-align:left>Imports 为 TypeScript</td><td style=text-align:left>启用自动导入</td></tr><tr><td style=text-align:left>Auto Import for Python (beta)</td><td style=text-align:left>为 Python 项目启用自动导入</td></tr></tbody></table><h3 id=3ai-智能体聊天窗口>3、AI 智能体（聊天窗口）<a hidden class=anchor aria-hidden=true href=#3ai-智能体聊天窗口>#</a></h3><h4 id=31-聊天窗口>3.1 聊天窗口<a hidden class=anchor aria-hidden=true href=#31-聊天窗口>#</a></h4><img src=https://cdn.jsdelivr.net/gh/lianpf/image-bed@main/blog/2025/20250813-001@2x.png alt=窗口管理 width=450><p><strong>窗口管理：</strong></p><ul><li><strong>新增上下文</strong>：通过 <code>@</code> 符号或拖拽文件添加</li><li><strong>切换上下文</strong>：点击 <code>Tab</code> 在不同的上下文集合间切换</li><li><strong>历史记录</strong>：（<code>时钟符号</code>）查看和管理Agent过去的聊天对话<ul><li>注意：后台<code>Background</code>代理聊天不在常规历史记录中，而是存储在远程数据库中（使用<code>⌘ + E</code>来查看）</li></ul></li></ul><p><strong>聊天窗口核心功能</strong>：</p><ul><li>检查点（Agent对代码库更改的自动快照）：点击之前请求上的<code>Restore Checkpoint</code>按钮，撤销 Agent 的修改</li><li>导出Agent聊天记录：点击上下文菜单 → “Export Chat”
<img src=https://cdn.jsdelivr.net/gh/lianpf/image-bed@main/blog/2025/20250813-002@2x.png alt=导出Agent聊天记录 width=400></li><li>复制/分叉聊天：从对话中的任意点创建分支，以探索替代解决方案，而不会丢失当前对话<ul><li>操作：<code>点击消息上的三个点 / 选择”Duplicate Chat”</code>
<img src=https://cdn.jsdelivr.net/gh/lianpf/image-bed@main/blog/2025/20250807-001@2x.png alt=导出Agent聊天记录 width=400></li></ul></li><li><code>Todos</code>规划：Agent 自动为复杂任务创建待办事项列表
<img src=https://cdn.jsdelivr.net/gh/lianpf/image-bed@main/blog/2025/20250813-009.webp alt=Todo事项 width=420></li></ul><p><strong>实际使用示例</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-markdown data-lang=markdown><span style=display:flex><span># 代码解释请求
</span></span><span style=display:flex><span>@component.tsx 解释这个组件的工作原理
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span># 文档查询
</span></span><span style=display:flex><span>@Web React 18 的最佳实践是什么？
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span># 多文件分析
</span></span><span style=display:flex><span>@src/utils @src/components 这两个模块之间的依赖关系如何？
</span></span></code></pre></div><h4 id=32-选择ai-工作模式>3.2 选择AI 工作模式<a hidden class=anchor aria-hidden=true href=#32-选择ai-工作模式>#</a></h4><img src=https://cdn.jsdelivr.net/gh/lianpf/image-bed@main/blog/2025/20250813-003@2x.png alt=AI工作模式 width=400><p><strong>工作模式简述</strong>：</p><ul><li><code>Agent 模式</code>：最智能和自主的模式。AI 可以主动选择上下文和使用工具、能够执行复杂的多步骤任务，可以访问终端、搜索代码库、创建和修改多个文件、具有"推理"能力，可以制定和执行计划<ul><li>场景：多个文件的复杂重构、从零到一的完整功能模块开发、跨文件分析和修复bug的复杂调试、项目结构调整和代码分析 —— 重点"跨文件"</li></ul></li><li><code>Ask 模式</code>：主要用于问答和解释、可以搜索代码库获取上下文、不会主动修改代码、专注于提供信息和建议<ul><li>场景：非常适合在修改代码之前理解代码。理解某段代码的工作原理、项目中的设计模式或架构、查找特定功能的实现位置、实现某个功能的建议、文档查询和最佳实践</li></ul></li><li><code>Manual 模式</code>（1.0版本）：传统的编辑器模式、AI 功能被限制，主要依赖手动编程、保持对代码的完全控制、类似于普通的 VS Code 体验<ul><li>场景：完全手动控制的精细代码修改、安全敏感或关键业务逻辑、简单的代码修改、审查代码</li></ul></li><li><code>Background Agents</code>（1.3版本新增）：后台运行的智能助手、持续监控代码质量、自动优化和建议、云端处理能力。<ul><li>场景：持续代码质量监控、自动化优化建议、后台分析和改进</li></ul></li></ul><p><strong>选择策略</strong>：</p><ul><li>从大到小：复杂任务用 Agent，问答用 Ask，简单编辑用 Manual</li><li>根据自主性：需要 AI 主动行动则选 Agent；需要信息则选 Ask；需要完全控制选 Manual</li><li>根据影响范围：多文件操作用 Agent，单文件查询用 Ask，局部编辑用 Manual</li></ul><p><strong>工作流建议</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>项目开始 → Agent 模式（架构设计、基础代码）
</span></span><span style=display:flex><span>↓
</span></span><span style=display:flex><span>开发过程 → Ask 模式（疑问解答、方案咨询）
</span></span><span style=display:flex><span>↓
</span></span><span style=display:flex><span>精细调试 → Manual 模式（精确控制、最终优化）
</span></span></code></pre></div><h3 id=4规则>4、规则<a hidden class=anchor aria-hidden=true href=#4规则>#</a></h3><p><strong><font color=Tomato>规则为<code>Agent</code>和内联编辑，提示提供持久的、可重用的一致性上下文，用于生成代码、解释编辑或协助工作流程。</font></strong></p><blockquote><p>注意：<code>Cmd + K</code> 不会应用【项目规则】的上下文</p></blockquote><p>支持三种类型的规则</p><ul><li>项目规则：存储在 <code>.cursor/rules</code> 中，受版本控制并作用于你的代码库。</li><li>用户规则：<code> Cursor Settings → Rules</code>中设置全局偏好设置，始终应用于你的 Cursor 环境。</li><li><code>.cursorrules</code>（旧版）：仍然支持，但已弃用。请改用项目规则。</li></ul><h4 id=41-项目规则>4.1 项目规则<a hidden class=anchor aria-hidden=true href=#41-项目规则>#</a></h4><blockquote><p><code>*.mdc</code> 本身就是<code>md</code>文档，加上一些自己的语法</p></blockquote><p>使用<code>Cursor Settings > Rules</code>，会在项目根目录下创建<code>.cursor/rules/xxx.mdc</code>格式的项目规则。 项目规则的作用：</p><ul><li>编码关于代码库的领域特定知识</li><li>自动化项目特定的工作流程或模板</li><li>标准化样式或架构决策</li></ul><p><strong><font color=Tomato>最佳实践</font></strong></p><ul><li>好的规则应该是专注的、可操作的和有明确范围的</li><li>保持规则在500行以内</li><li>将大型规则拆分为多个可组合的规则</li><li>提供具体的示例或引用文件</li><li>避免模糊的指导。编写规则时要像清晰的内部文档一样</li><li>在聊天中重复提示时重用规则</li></ul><h5 id=411-规则结构>4.1.1 规则结构<a hidden class=anchor aria-hidden=true href=#411-规则结构>#</a></h5><h6 id=i-规则>I. 规则<a hidden class=anchor aria-hidden=true href=#i-规则>#</a></h6><p>规则以<code>.mdc</code>编写，核心元数据：<code>description</code>、<code>globs</code>、<code>alwaysApply</code>。下面是与 UI 下拉选项的对应关系：</p><table><thead><tr><th style=text-align:left>UI 选项</th><th style=text-align:left>规则类型</th><th style=text-align:left>触发时机</th><th style=text-align:left>关键字段</th></tr></thead><tbody><tr><td style=text-align:left>Always Apply</td><td style=text-align:left>Always</td><td style=text-align:left>始终包含到模型上下文,无论何时都会生效</td><td style=text-align:left><code>alwaysApply: true</code></td></tr><tr><td style=text-align:left>Apply Intelligently</td><td style=text-align:left>Agent Requested</td><td style=text-align:left>由 AI 判定是否需要</td><td style=text-align:left><code>alwaysApply: false</code> 且需 <code>description</code></td></tr><tr><td style=text-align:left>Apply to Specific Files</td><td style=text-align:left>Auto Attached</td><td style=text-align:left>引用匹配 <code>globs</code> 的文件时自动包含</td><td style=text-align:left><code>globs</code> 列表、<code>alwaysApply: false</code></td></tr><tr><td style=text-align:left>Apply Manually</td><td style=text-align:left>Manual</td><td style=text-align:left>仅在聊天中 <code>@规则名</code> 时包含</td><td style=text-align:left><code>alwaysApply: false</code></td></tr></tbody></table><p><code>.mdc</code> 通用模板：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-md data-lang=md><span style=display:flex><span>---
</span></span><span style=display:flex><span>description: 用一句话概述这条规则做什么
</span></span><span style=display:flex><span>globs:
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>-</span> path/pattern/**/*
</span></span><span style=display:flex><span>alwaysApply: false
</span></span><span style=display:flex><span>---
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>-</span> 列出应遵循的要点
</span></span><span style=display:flex><span><span style=color:#66d9ef>-</span> 可以多条
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>@some-file-or-template.ext
</span></span></code></pre></div><p>示例（整理版）：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-md data-lang=md><span style=display:flex><span>---
</span></span><span style=display:flex><span>description: 内部 RPC Service 规范
</span></span><span style=display:flex><span>globs:
</span></span><span style=display:flex><span>alwaysApply: false
</span></span><span style=display:flex><span>---
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>-</span> 使用内部 RPC 模式定义服务
</span></span><span style=display:flex><span><span style=color:#66d9ef>-</span> 服务名一律使用 snake_case
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>@service-template.ts # 引用文件在规则触发时作为额外上下文包含
</span></span></code></pre></div><ul><li>若选择“Apply Manually”，需在对话中 <code>@规则名</code> 才会包含。</li><li>选择“Apply to Specific Files”时应补充 <code>globs</code>，引用匹配文件即自动启用。</li><li>选择“Always Apply”则将 <code>alwaysApply</code> 设为 <code>true</code>。</li></ul><h6 id=ii-规则场景示例>II. 规则场景示例<a hidden class=anchor aria-hidden=true href=#ii-规则场景示例>#</a></h6><p>几种规则类型汇总与适用场景：</p><ul><li><p><strong>Always（总是）</strong>：规则始终注入到所有对话中，适合“团队必须遵守的核心规范”。</p><ul><li><strong>适用场景</strong>：通用编码规范（代码风格、命名、安全）、文档格式约定、项目全局约束</li><li><strong>示例</strong>：禁止硬编码密钥；统一使用 TypeScript；React 组件命名与导出规范</li></ul></li><li><p><strong>Auto Attached（自动附加）</strong>：当引用到匹配 <code>globs</code> 的文件时才包含，减少不必要的规则负载。</p><ul><li><strong>适用场景</strong>：与文件类型/路径强相关的实践与模板</li><li><strong>示例</strong>：<code>*.test.ts</code> 中的测试风格；<code>/api/**</code> 的 RESTful 设计规范；某技术栈的 hooks 使用准则</li></ul></li><li><p><strong>Agent Requested（代理判断）</strong>：只有在智能体认为需要时才会包含，适合“需要深入思考的高级模式或架构决策”。</p><ul><li><strong>适用场景</strong>：复杂任务的分解策略、性能优化手段、系统设计原则</li><li><strong>示例</strong>：微服务架构设计原则；复杂算法优化策略；数据库设计模式</li></ul></li><li><p><strong>Manual（手动）</strong>：必须在对话中 <code>@规则名</code> 明确提及才包含，适合“新规、敏感或仅作参考的材料”。</p><ul><li><strong>适用场景</strong>：部署/安全清单、非常见或实验性的写法指南、临时作业说明</li><li><strong>示例</strong>：特定客户的定制要求；实验性的新框架使用规范；安全审计检查清单</li></ul></li></ul><p>项目初期推荐配置（建议）：</p><ol><li>Always：基础编码规范与项目约定</li><li>Auto Attached：文件类型相关规则（测试、API、组件等）</li><li>Agent Requested：架构/复杂设计类指引</li><li>Manual：特殊需求与参考文档</li></ol><p>团队协作最佳实践：</p><ul><li><strong>Always →</strong> 团队必须遵守的核心规范</li><li><strong>Auto Attached →</strong> 智能上下文附加的领域规则</li><li><strong>Agent Requested →</strong> 复杂决策支持</li><li><strong>Manual →</strong> 灵活的参考资源</li></ul><h5 id=412-嵌套规则>4.1.2 嵌套规则<a hidden class=anchor aria-hidden=true href=#412-嵌套规则>#</a></h5><p>在整个项目的 <code>.cursor/rules</code> 目录中组织规则。当引用其目录中的文件时，嵌套规则会自动附加。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>project/
</span></span><span style=display:flex><span>  .cursor/rules/        # 项目范围的规则
</span></span><span style=display:flex><span>  backend/
</span></span><span style=display:flex><span>    server/
</span></span><span style=display:flex><span>      .cursor/rules/    # 后端特定规则
</span></span><span style=display:flex><span>  frontend/
</span></span><span style=display:flex><span>    .cursor/rules/      # 前端特定规则
</span></span></code></pre></div><h5 id=413-生成规则>4.1.3 生成规则<a hidden class=anchor aria-hidden=true href=#413-生成规则>#</a></h5><p>当代理行为做出决策，你希望从聊天中生成项目规则。使用 <code>/Generate Cursor Rules</code> 命令直接在对话中生成规则</p><img src=https://cdn.jsdelivr.net/gh/lianpf/image-bed@main/blog/2025/20250813-017@2x.png alt=生成规则 width=400><h4 id=42-用户规则>4.2 用户规则<a hidden class=anchor aria-hidden=true href=#42-用户规则>#</a></h4><p>在 <code>Cursor Settings → Rules</code> 中定义的全局偏好设置，适用于所有项目。它们是纯文本格式，适合设置首选的沟通风格或编码约定.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>1. 请使用中文回答问题。
</span></span><span style=display:flex><span>2. 请保证最小化改动代码。
</span></span></code></pre></div><h3 id=5记忆130新增>5、记忆（1.3.0新增）<a hidden class=anchor aria-hidden=true href=#5记忆130新增>#</a></h3><p>记忆是基于你在聊天中的对话自动生成的规则。作用范围限定在你的项目内，并在会话之间保持上下文。</p><p>当您明确要求 Agent 记住某些内容或当它注意到应该为未来会话保留的重要信息时，Agent 可以直接使用工具调用创建记忆。</p><ul><li><code>Memory created</code>生成 或<code>Memory updated</code>更新<code>记忆</code></li><li><code>View Memories</code> 查看<code>记忆</code></li></ul><img src=https://cdn.jsdelivr.net/gh/lianpf/image-bed@main/blog/2025/20250813-007@2x.png alt=产生记忆 width=800><p><strong>管理记忆</strong>：<code>Cursor Setting → 规则</code>中管理<code>记忆</code>：
<img src=https://cdn.jsdelivr.net/gh/lianpf/image-bed@main/blog/2025/20250813-006@2x.png alt=窗口管理 width=600></p><hr><h2 id=三上下文>三、上下文<a hidden class=anchor aria-hidden=true href=#三上下文>#</a></h2><h3 id=1代码库索引codebase-indexing>1、代码库索引<code>Codebase Indexing</code><a hidden class=anchor aria-hidden=true href=#1代码库索引codebase-indexing>#</a></h3><p>当你打开一个项目时，<code>Cursor</code>自动为每个文件计算嵌入向量，来索引代码库。目的是为了提高 AI 生成的和你代码相关的答案质量。</p><img src=https://cdn.jsdelivr.net/gh/lianpf/image-bed@main/blog/2025/20250813-008@2x.png alt=窗口管理 width=600><ul><li>检查索引状态：<code>Cursor Settings > Indexing & Docs</code>。如上图中【1】位置</li><li>默认索引新文件：<code>图中【位置2】-> Index New Folders</code>。新增文件会增量索引</li><li>查看已索引的文件: <code>图中【位置2】-> Ignore Files in .cursorignore -> View included files</code>，会打开一个列出所有已索引文件的 .txt 文件。</li><li>忽略文件：忽略文件（例如 <code>.gitignore</code>、<code>.cursorignore</code>、<code>.cursorindexingignore</code>）中指定的所有文件，不会被索引。<ul><li><code>.cursorignore</code>: <code>图中【位置2】-> Ignore Files in .cursorignore</code></li><li>使用<code>.cursorindexingignore</code>仅从索引中排除文件。文件仍可被 AI 功能访问，但不会出现在代码库搜索中。</li><li>全局忽略文件：<code>Cmd + ,(用户设置) -> 搜索： Global Cursor Ignore List</code>，设置所有项目的忽略模式
<img src=https://cdn.jsdelivr.net/gh/lianpf/image-bed@main/blog/2025/20250813-018@2x.png alt=全局忽略文件 width=700></li><li>其他默认的忽略文件，参考：<a href=https://docs.cursor.com/zh/context/ignore-files#%E9%BB%98%E8%AE%A4%E5%BF%BD%E7%95%A5%E7%9A%84%E6%96%87%E4%BB%B6>Cursor上下文/忽略文件</a></li></ul></li><li>团队仓库控制范围：<code>图中【位置2】-> Team-Level Repository Control</code>。团队设置仓库范围的控制模式，用于确定哪些文件包含在索引中</li></ul><h3 id=2mcp>2、<code>MCP</code><a hidden class=anchor aria-hidden=true href=#2mcp>#</a></h3><p><code>Model Context Protocol (MCP)</code>使 <code>Cursor</code> 能够连接到外部工具和数据源。</p><ul><li><code>MCP</code>服务器：<a href=https://docs.cursor.com/zh/tools/mcp>Cursor文档 / MCP服务器</a></li><li>添加 <code>MCP</code> 到 <code>Cursor</code>: 项目中创建 <code>.cursor/mcp.json</code> 用于项目特定的工具。或在主目录中创建 <code>~/.cursor/mcp.json</code> 全局工具的配置<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;mcpServers&#34;</span>: {
</span></span><span style=display:flex><span>      <span style=color:#f92672>&#34;server-name&#34;</span>: {
</span></span><span style=display:flex><span>      <span style=color:#f92672>&#34;command&#34;</span>: <span style=color:#e6db74>&#34;npx&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:#f92672>&#34;args&#34;</span>: [<span style=color:#e6db74>&#34;-y&#34;</span>, <span style=color:#e6db74>&#34;mcp-server&#34;</span>],
</span></span><span style=display:flex><span>      <span style=color:#f92672>&#34;env&#34;</span>: {
</span></span><span style=display:flex><span>          <span style=color:#f92672>&#34;API_KEY&#34;</span>: <span style=color:#e6db74>&#34;value&#34;</span>
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ul><h3 id=3符号>3、<code>@</code>符号<a hidden class=anchor aria-hidden=true href=#3符号>#</a></h3><img src=https://cdn.jsdelivr.net/gh/lianpf/image-bed@main/blog/2025/20250813-005@2x.png alt=@符号 width=400><p><strong>常用功能：</strong></p><ul><li><code>@Files文件名</code> - 引用项目中的特定文件</li><li><code>@Folders</code> - 引用整个文件夹以获得更广泛的上下文</li><li><code>@Code</code> - 引用代码库中的特定代码片段或符号</li><li><code>@Past Chats</code> - 引用其他标签页或之前会话的上下文(聊天记录)</li><li><code>@Cursor Rules</code> - 使用 cursor 规则</li><li><code>@Docs</code> - 访问文档和指南</li><li><code>@Web</code> - 搜索外部网络资源和文档</li><li><code>@LibraryName</code> - 引用流行库的官方文档</li></ul><p><strong>其他功能：</strong></p><ul><li><p><code>@Git</code> - 访问 git 历史记录和更改</p></li><li><p><code>@Link (paste)</code> - 创建指向特定代码或文档的链接，并获取内容作为上下文使用。<br></p><ul><li>要将<code>URL</code>用作纯文本而不获取其内容：<ul><li>方式1：点击标记的链接并选择<code>Unlink</code>
<img src=https://cdn.jsdelivr.net/gh/lianpf/image-bed@main/blog/2025/20250813-019@2x.png alt=Unlink width=400></li><li>方式2：在粘贴时按住<code>Shift 键</code>，以防止自动标记</li></ul></li></ul></li><li><p><code>@Recent Changes</code> - 将最近的10次（时间顺序）代码更改，作为上下文包含在 AI 对话中</p></li><li><p><code>@Lint Errors</code> - 自动捕获并提供当前活动文件中，代码检查错误和警告的上下文信息</p></li><li><p><code># Files</code> - 将文件添加到上下文中而不引用</p></li><li><p><code>/command</code> - 支持添加"激活的文件"（编辑器中已打开标签页）到上下文中
<img src=https://cdn.jsdelivr.net/gh/lianpf/image-bed@main/blog/2025/20250813-017@2x.png alt=生成规则 width=400></p><ul><li><code>/Reset Context</code>: 将上下文重置为默认状态</li><li><code>/Generate Cursor Rules</code>: 为 Cursor 生成要遵循的规则</li><li><code>/Disable Iterate on Lints</code>: 不会尝试修复代码检查错误和警告</li><li><code>/Add Open Files to Context</code>: 引用当前打开的所有编辑器标签页</li><li><code>/Add Active Files to Context</code>: 引用当前视图中的所有编辑器标签页（在分屏布局中很有用）</li></ul></li></ul><hr><h2 id=四模型models>四、模型<code>Models</code><a hidden class=anchor aria-hidden=true href=#四模型models>#</a></h2><h3 id=1基础概念上下文窗口>1、基础概念：上下文窗口<a hidden class=anchor aria-hidden=true href=#1基础概念上下文窗口>#</a></h3><p><code>上下文窗口</code>是<code>LLM</code>一次可以共同考虑的最大<code>token</code>范围（包含输入与模型输出）。
在 Cursor 中，默认可用约 <code>200k tokens</code>（约 1.5 万行代码）；开启 <code>Max Mode</code> 可将上下文扩展到所选模型的最大上限，但速度更慢、成本更高。</p><h3 id=2模式选择>2、模式选择<a hidden class=anchor aria-hidden=true href=#2模式选择>#</a></h3><ul><li><strong>Max Mode</strong>：将上下文扩展到模型上限，适合跨仓库/跨多文件的大型重构、复杂架构设计、长文档推理；权衡是更慢、更贵。</li><li><strong>Auto</strong>：由 Cursor 按任务自动选择更合适的高级模型，适合日常开发与通用场景；权衡是偶尔不够“稳”。</li></ul><h3 id=3任务-模型选型建议>3、任务-模型选型建议<a hidden class=anchor aria-hidden=true href=#3任务-模型选型建议>#</a></h3><img src=https://cdn.jsdelivr.net/gh/lianpf/image-bed@main/blog/2025/20250813-004@2x.png alt=模型选择 width=360><p><strong>可用模型列表</strong>:</p><ul><li><strong>Claude-4-Sonnet</strong>：Anthropic 的旗舰模型，擅长代码生成</li><li><strong>o3</strong>：OpenAI 的推理模型，适合复杂问题解决</li><li><strong>Gemini-2.5-Pro</strong>：Google 的多模态模型</li><li><strong>GPT-4.1</strong>：OpenAI 的通用模型</li><li><strong>Claude-3.7-Sonnet</strong>：平衡性能和成本的选择</li><li><strong>Cursor-Small</strong>：Cursor 自有模型，无限制使用</li><li><strong>o4-Mini</strong>：轻量级快速响应模型</li></ul><p><strong><font color=Tomato>模型选择建议</font></strong>：</p><ul><li>高复杂度任务：使用 Max Mode 搭配 o3 / Claude 4（复杂架构、算法/设计）</li><li>中等复杂度任务：Claude 3.5 / GPT-4.1（常规开发、重构）</li><li>轻量/快速任务：Auto 模式（代码补全、局部小改动）</li></ul><p><strong>模型使用提示</strong>：</p><ul><li>带 🧠 脑洞图标的大模型：表示具有高级推理能力的模型；适用于复杂逻辑推理、数学计算、架构设计，常消耗更多 tokens</li><li>高级模型：Claude / GPT-4o（会扣除“快速调用”的次数）</li><li>轻量模型：cursor-small、o4-mini（适合 <code>Cmd + K</code>、函数级优化、行内修改）</li><li>模型侧重：Claude 更擅长代码推理与重构；GPT-4o 更擅长通用问答与多媒体理解</li><li><strong><font color=Tomato>局部修改优先小模型；若输出不稳定，可切换 Auto 或较新的大模型</font></strong></li><li><strong><font color=Tomato>追求稳定与一致性：优先选择最新可用模型版本</font></strong></li></ul><p><strong>注意：Cursor AI 持续快速发展，功能和界面会不断更新。<font color=Tomato>建议定期查看官方文档获取最新信息，并根据实际需求调整使用策略。</font></strong></p><hr><h2 id=附录>附录<a hidden class=anchor aria-hidden=true href=#附录>#</a></h2><h3 id=设置cursor工具栏方向>设置Cursor工具栏方向<a hidden class=anchor aria-hidden=true href=#设置cursor工具栏方向>#</a></h3><p><code>Cursor设置（快捷键Cmd + ,） -> 搜索 Workbench › Activity Bar: Orientation</code>， 选择 <code>vertical</code></p><img src=https://cdn.jsdelivr.net/gh/lianpf/image-bed@main/blog/2025/20250813-010@2x.png alt=设置Cursor工具栏方向 width=560><h3 id=常用的cursor-settings130>常用的<code>Cursor Settings</code>（1.3.0）<a hidden class=anchor aria-hidden=true href=#常用的cursor-settings130>#</a></h3><h4 id=cursor-tab><code>Cursor Tab</code><a hidden class=anchor aria-hidden=true href=#cursor-tab>#</a></h4><img src=https://cdn.jsdelivr.net/gh/lianpf/image-bed@main/blog/2025/20250813-011@2x.png alt="Cursor Tab" width=480><h4 id=cursor-chat><code>Cursor Chat</code><a hidden class=anchor aria-hidden=true href=#cursor-chat>#</a></h4><img src=https://cdn.jsdelivr.net/gh/lianpf/image-bed@main/blog/2025/20250813-012@2x.png alt="Cursor Chat" width=600><ul><li>默认模式 <code>Default Mode</code>（Agent）：新会话默认 Agent；写长文/精准改写可切 Composer。</li><li>默认位置 <code>Default Location</code>（Pane）：在侧边面板打开；需要在编辑器区域打开用 <code>Editor</code>。</li><li>文本大小 <code>Text Size</code>（Default）：调整聊天字体；演示时调大一档。</li><li>自动清理会话 <code>Auto-Clear Chat</code>（开启）：闲置后新开会话更干净；要持续上下文则关闭。</li><li>自动滚动到新消息 <code>Scroll to New Messages</code>（开启）：新回复自动滚动到底部，建议保持。</li><li>完成音效 <code>Completion Sound</code>（关闭）：回复完成提示音；需要提醒时再开启。</li><li>待办清单 <code>To-Do List</code>（开启）：允许跟踪任务进度，长任务建议开启。
<img src=https://cdn.jsdelivr.net/gh/lianpf/image-bed@main/blog/2025/20250813-014.webp alt="To-Do List" width=400></li><li>消息排队 <code>Queue Messages</code>（开启）：流式回复排队防乱序；需要即时打断时可关闭。</li><li>自定义模式 <code>Custom Modes</code>（开启，Beta）：可建模型/工具/指令预设；建议建"重构TS/写文档/单测生成"等。</li></ul><img src=https://cdn.jsdelivr.net/gh/lianpf/image-bed@main/blog/2025/20250813-013@2x.png alt="Context & Apply Changes" width=600><p><strong><code>Context</code>上下文</strong></p><ul><li><code>Include Full-Folder Context</code>（开）：将文件夹内所有文件纳入上下文，便于全局理解，但更耗资源。</li><li><code>Web Search Tool</code>（开）：允许联网查询补充信息，涉及隐私时可关闭。</li><li><code>Hierarchical Cursor Ignore</code>（关）：让 <code>.cursorignore</code>的忽略规则向下继承，作用到所在目录的所有子目录与文件。切换该开关后需要重启 Cursor 生效。</li><li><code>Backspace Removes Context</code>（开）：当光标在输入框“最开头”时，按下<code>Backspace / Delete</code>不会删文字，而是“弹出”最后一个上下文胶囊（<code>context pill</code>）。相当于用键盘快速移除最近添加的上下文，按一次删一个，顺序是后进先出。</li></ul><p><strong><code>Applying Changes</code>应用变更</strong></p><ul><li><code>Out-of-Context Edits in Review Mode</code>（开）：<code>Review Mode</code>模式下，允许修改不在当前选中上下文/文件列表的其他文件。即许跨文件、跨目录地联动修改。</li><li><code>Auto-Fix Lints</code>（开）：自动应用可修复的 <code>Lint</code> 规则</li><li><code>Auto-Accept on Commit</code>（关）：文件提交时，自动接受聊天中的变更</li></ul><img src=https://cdn.jsdelivr.net/gh/lianpf/image-bed@main/blog/2025/20250813-015@2x.png alt=Auto-Run width=600><p><strong><code>Auto-Run</code>自动执行配置</strong></p><ul><li><strong><code>Auto-Run Mode</code>（开）</strong>：允许 <code>Agent</code> 在无需确认的情况下，执行命令、写文件。适用于连续构建/测试/重构等流水作业，但存在误执行风险。</li><li><strong><code>Command Allowlist</code>（空）</strong>：白名单内的命令可被自动执行；未在名单内的命令仍需确认。开启自动运行时务必配置白名单，只放安全、幂等命令。<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>npm ci
</span></span><span style=display:flex><span>npm run build
</span></span><span style=display:flex><span>go test ./...
</span></span></code></pre></div></li><li><strong><code>File-Deletion Protection</code>（关）</strong>：阻止 <code>Agent</code> 自动删除文件。关闭状态风险较高，团队项目建议开启。</li><li><strong><code>MCP Tools Protection</code>（关）</strong>：阻止 <code>Agent</code> 自动调用 <code>MCP</code> 工具。关闭可能触发外部副作用，生产环境建议开启。</li><li><strong><code>Dotfile Protection</code>（开）</strong>：阻止自动修改点文件（如 <code>.gitignore</code>、<code>.npmrc</code>）。避免全局配置被意外改动，建议保持开启。</li><li><strong><code>External-File Protection</code>（开）</strong>：阻止在工作区外创建/修改文件。防止越权写入，强烈建议保持开启。</li></ul><img src=https://cdn.jsdelivr.net/gh/lianpf/image-bed@main/blog/2025/20250813-016@2x.png alt=Auto-Run width=600><p><strong><code>Inline Editing</code>行内编辑器 & <code>Terminal</code>终端配置</strong></p><ul><li>工具栏高亮 <code>Toolbar on Selection</code>（开）：选中代码时显示“Add to Chat/Quick Edit”快捷按钮，建议开启。</li><li>自动解析链接 <code>Auto-Parse Links</code>（关）：自动将粘贴到输入框中的URL转为上下文，担心隐私时保持关闭。</li><li>自动选区 <code>Auto-Select Code Regions for Quick Edit</code>（开）：<code>Cmd + K</code>时，自动框定代码（模）块，建议开启。</li><li>主题化差异背景 <code>Themed Diff Backgrounds</code>（开）：使用主题色背景显示差异，建议开启。</li><li>字符级差异 <code>Character-Level Diffs</code>（开）：显示具体字符变更高亮，建议开启。</li><li>终端提示 <code>Terminal Tooltips</code>（开）：终端显示"Add to chat"等提示，建议开启。</li><li>终端快捷提示 <code>Terminal Hint</code>（开）：终端提示可用<code>⌘K</code>，建议开启。</li><li>终端预览框 <code>Preview Box for Terminal ⌘K</code>（关）：AI回复先在预览框展示，避免命令直接流入shell执行，安全需求时可开启。</li></ul><h3 id=集成bugbot代码审查slack和github>集成<code>Bugbot</code>代码审查、<code>Slack</code>和<code>Github</code><a hidden class=anchor aria-hidden=true href=#集成bugbot代码审查slack和github>#</a></h3><p>Background Agents 后台代理</p><ul><li><strong>GitHub 连接</strong>：连接 GitHub 进行代码库分析和 PR 协助</li><li><strong>Slack 集成</strong>：直接在 Slack 中使用 Cursor 功能</li><li><strong>持续集成</strong>：与 CI/CD 流程集成</li></ul><hr><h2 id=参考资源>参考资源<a hidden class=anchor aria-hidden=true href=#参考资源>#</a></h2><ul><li><a href=https://www.cursor.com/>Cursor 官方网站</a></li><li><a href=https://docs.cursor.com/>Cursor 官方文档</a></li><li><a href=https://cursor.directory/>Cursor.Directory - 规则和插件目录</a></li><li><a href=https://cursorlist.com/>CursorList - 最佳实践集合</a></li><li><a href=https://dotcursorrules.com/>DotCursorRules - 规则文档</a></li><li><a href=https://www.thepromptwarrior.com/p/the-3-cursor-ai-modes>Cursor AI 模式对比教程</a></li><li><a href=https://medium.com/@ashinno43/cursor-ai-agents-how-to-revolutionize-your-coding-workflow-7742868f7900>Cursor AI 工作流程最佳实践</a></li></ul><hr><p><strong>最后， 希望大家早日实现：成为编程高手的伟大梦想！</strong><br><strong>欢迎交流~</strong></p><img src=/img-common/weChatPublic.jpg alt=微信公众号 width=600 height=286><p><strong>本文版权归原作者曜灵所有！未经允许，严禁转载！对非法转载者, 原作者保留采用法律手段追究的权利！</strong><br><strong>若需转载，请联系微信公众号：连先生有猫病，可获取作者联系方式！</strong></p></div><footer class=post-footer><nav class=paginav><a class=prev href=https://lianpf.github.io/posts/other/google-gemini-cli-use/><span class=title>« 上一页</span><br><span>AI：Google Gemini Cli</span></a>
<a class=next href=https://lianpf.github.io/posts/other/ai-llm-and-prompt/><span class=title>下一页 »</span><br><span>AI编程：LLM（大模型）和Prompt（提示词）工程</span></a></nav></footer></div></article></main><footer class=footer><span>Copyright
&copy;
2016-2025
<a href=https://lianpf.github.io/ style=color:#939393>曜灵（SUN）Site</a>.
基于 Hugo 引擎和 PaperMod 主题</span>
<a href=https://beian.miit.gov.cn/ target=_blank style=color:#939393></a>&nbsp;</footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><span class=topInner><svg class="topSvg" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg><span id=read_progress></span></span></a>
<script>document.addEventListener("scroll",function(){const t=document.getElementById("read_progress"),n=document.documentElement.scrollHeight,s=document.documentElement.clientHeight,o=document.documentElement.scrollTop||document.body.scrollTop;t.innerText=((o/(n-s)).toFixed(2)*100).toFixed(0)})</script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>let mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>200||document.documentElement.scrollTop>200?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{(function(){document.cookie="change-themes="+escape("false")})(),document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.body.addEventListener("copy",function(e){if(window.getSelection().toString()&&window.getSelection().toString().length>50){let t=e.clipboardData||window.clipboardData;if(t){e.preventDefault();let n=window.getSelection().toString()+`

————————————————
版权声明：本文为「曜灵（SUN）Site」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：`+location.href,s=window.getSelection().toString()+`

————————————————
版权声明：本文为「曜灵（SUN）Site」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：`+location.href;t.setData("text/html",n),t.setData("text/plain",s)}}})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const s=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="复制";function i(){t.innerText="已复制！",setTimeout(()=>{t.innerText="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){let t=e.textContent+`
————————————————
版权声明：本文为「曜灵（SUN）Site」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：`+location.href;navigator.clipboard.writeText(t),i();return}const n=document.createRange();n.selectNodeContents(e);const s=window.getSelection();s.removeAllRanges(),s.addRange(n);try{document.execCommand("copy"),i()}catch{}s.removeRange(n)});let l=e.className.replaceAll("language-",""),n=document.createElement("div"),a=document.createElement("div"),r=document.createElement("div"),c=document.createElement("div"),o=document.createElement("div");o.innerText=l,n.setAttribute("class","mac-tool"),a.setAttribute("class","mac bb1"),r.setAttribute("class","mac bb2"),c.setAttribute("class","mac bb3"),o.setAttribute("class","language-type"),n.appendChild(a),n.appendChild(r),n.appendChild(c),n.appendChild(o),s.classList.contains("highlight")?(s.appendChild(t),s.appendChild(n)):s.parentNode.firstChild==s||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?(e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t),s.appendChild(n)):(e.parentNode.appendChild(t),s.appendChild(n)))})</script></body></html>