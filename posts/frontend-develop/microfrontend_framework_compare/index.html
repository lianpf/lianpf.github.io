<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>微前端: qiankun、wujie和Micro App等框架对比 | 曜灵（SUN）Site</title><meta name=keywords content="工具"><meta name=description content="系列文章： 第一篇：微前端: qiankun、wujie和Mic"><meta name=author content="曜灵"><link rel=canonical href=https://lianpf.github.io/posts/frontend-develop/microfrontend_framework_compare/><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.js onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://lianpf.github.io/img-common/favicon.png><link rel=icon type=image/png sizes=16x16 href=https://lianpf.github.io/img-common/favicon.png><link rel=icon type=image/png sizes=32x32 href=https://lianpf.github.io/img-common/favicon.png><link rel=apple-touch-icon href=https://lianpf.github.io/img-common/avatar.jpeg><link rel=mask-icon href=https://lianpf.github.io/img-common/avatar.jpeg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script defer src=https://unpkg.com/mermaid@8.8.1/dist/mermaid.min.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css><script src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script>
<script src=https://cdn.jsdelivr.net/npm/jquery@3.6.3/dist/jquery.min.js></script>
<script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script><meta property="og:title" content="微前端: qiankun、wujie和Micro App等框架对比"><meta property="og:description" content="系列文章： 第一篇：微前端: qiankun、wujie和Mic"><meta property="og:type" content="article"><meta property="og:url" content="https://lianpf.github.io/posts/frontend-develop/microfrontend_framework_compare/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-05-15T20:37:01+08:00"><meta property="article:modified_time" content="2024-05-15T20:37:01+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="微前端: qiankun、wujie和Micro App等框架对比"><meta name=twitter:description content="系列文章： 第一篇：微前端: qiankun、wujie和Mic"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"📚文章","item":"https://lianpf.github.io/posts/"},{"@type":"ListItem","position":2,"name":"👨🏻‍💻 前端","item":"https://lianpf.github.io/posts/frontend-develop/"},{"@type":"ListItem","position":3,"name":"微前端: qiankun、wujie和Micro App等框架对比","item":"https://lianpf.github.io/posts/frontend-develop/microfrontend_framework_compare/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"微前端: qiankun、wujie和Micro App等框架对比","name":"微前端: qiankun、wujie和Micro App等框架对比","description":"系列文章： 第一篇：微前端: qiankun、wujie和Mic","keywords":["工具"],"articleBody":"系列文章：\n第一篇：微前端: qiankun、wujie和Micro App等框架对比 微前端架构主要解决单体应用（常见于企业级 Web 应用）在一个相对长的时间跨度下，由于参与的人员、团队的增多、变迁，从一个普通应用演变成一个 巨石应用(Frontend Monolith) 后，应用不可维护的问题。\n在各大微前端解决方案出现前，通常用iframe解决这类问题。本文首先从iframe和微前端架构的视角，去对比下原理。其次，对比现有的各大微前端框架\n一、iframe vs 微前端架构 1.iframe iframe提供了浏览器原生的硬隔离方案 ，不论是【巨石应用】的样式隔离、js隔离问题都能被完美解决。 但最大问题也在于iframe的隔离性无法被突破，导致应用间上下文无法被共享，带来开发和产品体验的问题：\nurl不同步: 浏览器刷新iframe url状态丢失、后退前进按钮无法使用 UI不同步: DOM结构不共享，弹窗只能在iframe内部展示，无法覆盖全局 隔离问题: 全局上下文完全隔离，内存变量不共享，iframe内外系统的通信、数据同步等需求，主应用的cookie要透传到根域名都不同的子应用中实现免登效果 慢: 每次子应用进入都是一次浏览器上下文重建、资源重新加载的过程 2.微前端架构 微前端框架内的各个应用都支持独立开发部署、不限技术框架、支持独立运行、应用状态隔离但也可共享等特征。\n二、微前端架构 框架1: single-spa single-spa是最早的微前端框架，兼容多种前端技术栈，支持将多个单页面应用聚合为一个整体应用的。\n简单来说就是【聚合】，该库可让你的应用使用多个不同的技术栈（vue、react、angular等)进行同步开发，最后使用一个公用的路由去实现完美的切换\n1.实现方案 single-spa实现了一套 【生命周期】，开发者需在相应的时机自己去加载对应的子应用。它做的事情就是：注册子应用、监听URL变化，然后加载对应的子应用js，执行对应子应用的生命周期流程。\n提供registerApplication方法，用来注册子应用列表 提供activeWhen，由开发者指定路由满足条件时，激活（挂载）子应用的js、css。 js隔离由single-spa-leaked-globals实现 本质上就是在 mount A 子应用时，正常添加全局变量，比如 jQuery 的 $, lodash 的 _。在 unmount A 子应用时，用一个对象记录之前给 window 添加的全局变量，并把 A 应用里添加 window 的变量都删掉。下一次再 mount A 应用时，把记录的全局变量重新加回来。 css隔离： 子应用之间通过single-spa-css插件提供的css生命周期函数，做到子应用mount时加载css，子应用unmount时将css unmount掉 主应用与子应用之间可通过PostCSSPrefix Selector给样式自动加前缀的方式，或Shadow DOM的形式去解决。 2.single-spa实战 i.主应用入口文件 主要通过single-spa提供的registerApplication方法注册子应用，子应用需要指定加载子应用的方法、和路由条件\nimport Vue from 'vue' import App from './App.vue' import router from './router' import { registerApplication, start } from 'single-spa' Vue.config.productionTip = false // 远程加载子应用 function createScript(url) { return new Promise((resolve, reject) =\u003e { const script = document.createElement('script') script.src = url script.onload = resolve script.onerror = reject const firstScript = document.getElementsByTagName('script')[0] firstScript.parentNode.insertBefore(script, firstScript) }) } // 加载函数，返回一个 promise function loadApp(url, globalVar) { // 支持远程加载子应用 return async () =\u003e { await createScript(url + '/js/chunk-vendors.js') await createScript(url + '/js/app.js') // 这里的return很重要，需要从这个全局对象中拿到子应用暴露出来的生命周期函数 return window[globalVar] } } // 子应用列表 const apps = [ { // 子应用名称 name: 'app1', // 子应用加载函数，是一个promise app: loadApp('http://localhost:8081', 'app1'), // 当路由满足条件时（返回true），激活（挂载）子应用 activeWhen: location =\u003e location.pathname.startsWith('/app1'), // 传递给子应用的对象 customProps: {} }, { name: 'app2', app: loadApp('http://localhost:8082', 'app2'), activeWhen: location =\u003e location.pathname.startsWith('/app2'), customProps: {} }, { // 子应用名称 name: 'app3', // 子应用加载函数，是一个promise app: loadApp('http://localhost:3000', 'app3'), // 当路由满足条件时（返回true），激活（挂载）子应用 activeWhen: location =\u003e location.pathname.startsWith('/app3'), // 传递给子应用的对象，这个很重要，该配置告诉react子应用自己的容器元素是什么，这块儿和vue子应用的集成不一样，官网并没有说这部分，或者我没找到，是通过看single-spa-react源码知道的 customProps: { domElement: document.getElementById('microApp'), // 添加 name 属性是为了兼容自己写的lyn-single-spa，原生的不需要，当然加了也不影响 name: 'app3' } } ] // 注册子应用 for (let i = apps.length - 1; i \u003e= 0; i--) { registerApplication(apps[i]) } new Vue({ router, mounted() { // 启动 start() }, render: h =\u003e h(App) }).$mount('#app') ii.子应用导出文件 子应用需要安装single-spa-react或者single-spa-vue， 将子应用传递给single-spa-react，得到子应用运行的生命周期， 子应用将生命周期导出到全局， 在主应用可以获取子应用的生命周期函数 import React from 'react'; import ReactDOM from 'react-dom'; import './index.css' import { BrowserRouter, Link, Route } from 'react-router-dom' import singleSpaReact from 'single-spa-react' // 子应用独立运行 if (!window.singleSpaNavigate) { ReactDOM.render(rootComponent(), document.getElementById('root')) } // 生命周期a const reactLifecycles = singleSpaReact({ React, ReactDOM, rootComponent, errorBoundary(err, info, props) { return \u003cdiv\u003e This renders when a catastrophic error occurs \u003c/div\u003e } }) // 这里和vue不一样，props必须向下传递 export const bootstrap = async props =\u003e { console.log('app3 bootstrap'); return reactLifecycles.bootstrap(props) } export const mount = async props =\u003e { console.log('app3 mount'); return reactLifecycles.mount(props); } export const unmount = async props =\u003e { console.log('app3 unmount'); return reactLifecycles.unmount(props) } // 根组件 function rootComponent() { return \u003cReact.StrictMode\u003e \u003cBrowserRouter\u003e \u003cdiv\u003e \u003cLink to=\"/app3\"\u003eHome\u003c/Link\u003e | \u003cLink to=\"/app3/about\"\u003e About\u003c/Link\u003e \u003cRoute exact path=\"/app3\" component={Home} /\u003e \u003cRoute exact path=\"/app3/about\" component={About} /\u003e \u003c/div\u003e \u003c/BrowserRouter\u003e \u003c/React.StrictMode\u003e } // home 组件 function Home() { return \u003cdiv\u003e \u003ch1\u003eapp3 home page\u003c/h1\u003e \u003c/div\u003e } // about 组件 function About() { return \u003cdiv\u003e \u003ch1\u003eapp3 about page\u003c/h1\u003e \u003c/div\u003e } iii.打包配置 将子应用导出模式设置为umd\nconst package = require('./package.json') module.exports = { // 告诉子应用在这个地址加载静态资源，否则会去基座应用的域名下加载 publicPath: '//localhost:8082', // 开发服务器 devServer: { port: 8082 }, configureWebpack: { // 导出umd格式的包，在全局对象上挂载属性package.name，基座应用需要通过这个全局对象获取一些信息，比如子应用导出的生命周期函数 output: { // library的值在所有子应用中需要唯一 library: package.name, libraryTarget: 'umd' } } } iv.预览 可以看到它是动态加载的子应用的js，并执行js，将内容渲染到了主应用的盒子内。\n3.框架优缺点 优点：\n敏捷性 - 独立开发、独立部署，微应用仓库独立，前后端可独立开发，部署完成后主框架自动完成同步更新； 技术栈无关，主框架不限制接入应用的技术栈，微应用具备完全自主权； 增量升级，在面对各种复杂场景时，我们通常很难对一个已经存在的系统做全量的技术栈升级或重构，而微前端是一种非常好的实施渐进式重构的手段和策略 缺点：\n需要自己去加载子应用 不支持Javascript沙箱隔离，需要自己去使用single-spa-leaked-globals之类的库去隔离 不支持css隔离，需要自己使用single-spa-css库或者postcss等去解决样式冲突问题 无法预加载 框架2: qiankun 阿里的qiankun是基于single-spa的微前端实现库，孵化自蚂蚁，能更简单、无痛的构建一个生产可用微前端架构系统。目前(2024年4月) github star 15.4k。\n1.实现方案 single-spa是基于js-entry方案，而qiankun 是基于html-entry 及沙箱设计，使得微应用的接入 像使用 iframe 一样简单。 主应用监听路由，加载对应子应用的html，挂载到主应用的元素内，然后解析子应用的html，从中分析出css、js再去沙盒化后加载执行，最终将子应用的内容渲染出来。 qiankun实现样式隔离有两种模式可供开发者选择： strictStyleIsolation： 这种模式下 qiankun 会为每个微应用的容器包裹上一个 shadow dom 节点，从而确保微应用的样式不会对全局造成影响。 experimentalStyleIsolation： 当 experimentalStyleIsolation 被设置为 true 时，qiankun 会改写子应用所添加的样式，会为所有样式规则增加一个特殊的选择器规则，来限定其影响范围 qiankun实现js隔离，采用了两种沙箱，分别为基于Proxy实现的沙箱和快照沙箱，当浏览器不支持Proxy会降级为快照沙箱 Proxy沙箱机制：\n// 伪代码 class ProxySandbox { constructor() { const rawWindow = window; const fakeWindow = {} const proxy = new Proxy(fakeWindow, { set(target, p, value) { target[p] = value; return true }, get(target, p) { return target[p] || rawWindow[p]; } }); this.proxy = proxy } } let sandbox1 = new ProxySandbox(); let sandbox2 = new ProxySandbox(); window.a = 1; // 伪代码 ((window) =\u003e { window.a = 'hello'; console.log(window.a) // hello })(sandbox1.proxy); ((window) =\u003e { window.a = 'world'; console.log(window.a) // world })(sandbox2.proxy); 快照沙箱：\n// 伪代码 class SnapshotSandbox { constructor() { this.proxy = window; this.modifyPropsMap = {}; // 修改了那些属性 this.active(); // 调用active保存主应用window快照 } /**1. 初始化时，在子应用即将mount前，先调用active，保存当前主应用的window快照*/ active() { this.windowSnapshot = {}; // window对象的快照 for (const prop in window) { if (window.hasOwnProperty(prop)) { // 将window上的属性进行拍照 this.windowSnapshot[prop] = window[prop]; } } Object.keys(this.modifyPropsMap).forEach(p =\u003e { window[p] = this.modifyPropsMap[p]; }); } /** * 子应用卸载时，遍历当前子应用的window属性，和主应用的window快照做对比 * 如果不一致，做两步操作 * 1. 保存 不一致的window属性， * 2. 还原window */ inactive() { for (const prop in window) { // diff 差异 if (window.hasOwnProperty(prop)) { // 将上次拍照的结果和本次window属性做对比 if (window[prop] !== this.windowSnapshot[prop]) { // 保存修改后的结果 this.modifyPropsMap[prop] = window[prop]; // 还原window window[prop] = this.windowSnapshot[prop]; } } } } } 2.qiankun实战 i.主应用入口文件 初始化主应用，并注册子应用 主应用入口文件初始化应用，注册子应用，注册子应用时支持传入子应用列表， 注册子应用时需要指明以下几个主要参数：\nname： 微应用的名称，微应用之间必须确保唯一 entry： 子应用的访问链接。主应用会加载整个页面，例如https://qiankun.umijs.org/guide/ container：需要挂载子应用的DOM元素 loader: 子应用未加载时的界面，一般为loading activeRule： 路由匹配规则 开启子应用start(options) options.prefetch此时可以选择是否预加载子应用。 options.sandbox默认情况下的沙箱可确保【单实例场景子应用之间】的样式隔离，但无法确保主应用和子应用、或者多实例场景的子应用样式隔离。qiankun提供了另外两种方式的隔离，供开发者选择： strictStyleIsolation：当配置为{ strictStyleIsolation: true }时表示开启严格的样式隔离模式。这种模式下qiankun会为每个微应用的容器包裹上一个shadow dom节点，从而确保微应用的样式不会对全局造成影响 experimentalStyleIsolation：当{experimentalStyleIsolation: true}被设置，qiankun会改写子应用所添加的样式为所有样式规则增加一个特殊的选择器规则来限定其影响范围 import { registerMicroApps, start, initGlobalState } from 'qiankun'; registerMicroApps([ { name: 'react app', // app name registered entry: '//localhost:7100', container: '#yourContainer', activeRule: '/yourActiveRule', }, { name: 'vue app', entry: { scripts: ['//localhost:7100/main.js'] }, container: '#yourContainer2', activeRule: '/yourActiveRule2', }, ]); // 通讯 const { onGlobalStateChange, setGlobalState } = initGlobalState({ user: 'qiankun', }); onGlobalStateChange((value, prev) =\u003e console.log('[onGlobalStateChange - master]:', value, prev)); setGlobalState({ ignore: 'master', user: { name: 'master', }, }); /** * 设置默认进入的子应用 */ setDefaultMountApp('/react16'); /** * 启动应用 */ start({ prefetch: true, // 预加载子应用 sandbox:{ strictStyleIsolation: true, // shadow dom的方式实现样式隔离 // experimentalStyleIsolation: true, //添加特殊的选择器的方式实现样式隔离 } }); runAfterFirstMounted(() =\u003e { console.log('[MainApp] first app mounted'); }); ii.子应用导出生命周期钩子 子应用需在自己的入口 js导出bootstrap、mount、unmount三个生命周期钩子，以供主应用在适当的时机调用\nimport React from 'react'; import ReactDOM from 'react-dom'; import App from './App'; import * as serviceWorker from './serviceWorker'; function render(props) { const { container } = props; ReactDOM.render(\u003cApp /\u003e, container ? container.querySelector('#root') : document.querySelector('#root')); } /** * 和主应用通讯 */ function storeTest(props) { props.onGlobalStateChange((value, prev) =\u003e console.log(`[onGlobalStateChange - ${props.name}]:`, value, prev), true); props.setGlobalState({ ignore: props.name, user: { name: props.name, }, }); } if (!window.__POWERED_BY_QIANKUN__) { render({}); } /** * bootstrap 只会在微应用初始化的时候调用一次，下次微应用重新进入时会直接调用 mount 钩子，不会再重复触发 bootstrap。 * 通常我们可以在这里做一些全局变量的初始化，比如不会在 unmount 阶段被销毁的应用级别的缓存等。 */ export async function bootstrap() { console.log('[react16] react app bootstraped'); } /** * 应用每次进入都会调用 mount 方法，通常我们在这里触发应用的渲染方法 */ export async function mount(props) { console.log('[react16] props from main framework', props); storeTest(props); render(props); } /** * 应用每次 切出/卸载 会调用的方法，通常在这里我们会卸载微应用的应用实例 */ export async function unmount(props) { const { container } = props; ReactDOM.unmountComponentAtNode(container ? container.querySelector('#root') : document.querySelector('#root')); } iii. 配置打包工具 为了让主应用能正确识别微应用暴露出来的一些全局信息和开发环境下的跨域兼容，在子应用（以create-react-app出来的react项目为例）安装@rescripts/cli，并在子应用目录下新建.rescriptsrc.js，内容如下：\nconst { name } = require('./package'); module.exports = { webpack: (config) =\u003e { config.output.library = `${name}-[name]`; config.output.libraryTarget = 'umd'; // 为了能通过window['app-name1']拿到子应用声明的生命周期 // webpack 5 需要把 jsonpFunction 替换成 chunkLoadingGlobal config.output.jsonpFunction = `webpackJsonp_${name}`; config.output.globalObject = 'window'; return config; }, devServer: (_) =\u003e { const config = _; config.headers = { 'Access-Control-Allow-Origin': '*', }; config.historyApiFallback = true; config.hot = false; config.watchContentBase = false; config.liveReload = false; return config; }, }; iv.预览 使用strictStyleIsolation：true方式进行样式隔离，会生成一个shadow dom，进行样式的完全隔离：\n使用experimentalStyleIsolation：true的方式进行样式隔离，会在css选择器前添加特殊标识： 可以看到，qiankun会将子应用的html渲染到自定义的container中。 主应用加载的是子应用的html，在解析子应用的html的过程中遇到js和css会载框架内进行沙盒处理，完成css和js的隔离，之后下载并执行，完成整个子应用的渲染过程。\n3.框架优缺点 优点\nhtml entry的接入方式，不需要自己写load方法，而是直接写子应用的访问链接就可以。 提供js沙箱 提供样式隔离，两种方式可选 资源预加载，在浏览器空闲时间预加载未打开的微应用资源，加速微应用打开速度。 社区活跃 umi 插件，提供了 @umijs/plugin-qiankun 供 umi 应用一键切换成微前端架构系统 除了最后一点拓展以外，微前端想要达到的效果都已经达到。 应用间通信简单，全局注入路由保持，浏览器刷新、前进、后退，都可以作用到子应用 路由保持，浏览器刷新、前进、后退，都可以作用到子应用 缺点\n改造成本较大，从 webpack、代码、路由等等都要做一系列的适配 对 eval 的争议，eval函数的安全和性能是有一些争议的：MDN的eval介绍； 无法同时激活多个子应用，也不支持子应用保活 无法支持 vite 等 ESM 脚本运行 框架3: wujie wujie是腾讯出品。基于 webcomponent 容器 + iframe 沙箱，能够完善的解决适配成本、样式隔离、运行性能、页面白屏、子应用通信、子应用保活、多应用激活、vite 框架支持、应用共享等。目前（2024年4月）github star 3.7k\n1.实现方案 无界利用iframe和webcomponent来搭建天然的js隔离沙箱和css隔离沙箱, 利用iframe的history和主应用的history在同一个top-level browsing context来搭建天然的路由同步机制 支持以fiber的形式执行js，由于子应用的执行会阻塞主应用的渲染线程，当fiber设置为true，那么js执行时采取类似react fiber的模式方式间断执行，每个 js 文件的执行都包裹在requestidlecallback中，每执行一个js可以返回响应外部的输入，但是这个颗粒度是js文件，如果子应用单个js文件过大，可以通过拆包的方式降低达到fiber模式效益最大化 wujie是如何渲染子应用的？ wujie跟qiankun一样，都是基于html entry加载的，但他们解析html的过程是不一样的。 qiankun是直接解析并执行js、css、html的，而wujie则是先解析html，提取出script脚本放入空的iframe中，提取出css、html放入到web components中，具体来说：\n解析入口 HTML ，分别得到script、css、模版html 创建一个纯净的 iframe，为了实现应用间（iframe 间）通讯，无界子应用 iframe 的 url 会设置为主应用的域名（同域），因此 iframe 的 location.href 并不是子应用的 url。创建好后停止加载iframe。 iframe内插入js，将抽离出来的script脚本，插到iframe中去，在iframe中执行子应用的js 创建web component，id为子应用id，将抽离出来的html插入。 由于iframe内的js有可能操作dom，但是iframe内没有dom，随意wujie框架内对iframe拦截document对象，统一将dom指向shadowRoot，此时比如新建元素、弹窗或者冒泡组件就可以正常约束在shadowRoot内部。 2.wujie实战 wujie接入很简单，主应用可以让开发者以组件的方式加载子应用。子应用只需要做支持跨域请求改造，这个是所有微前端框架运行的前提，除此之外子应用可以不做任何改造就可以在无界框架中运行，不过此时运行的方式是重建模式。 子应用也可以配置保活、生命周期适配进入保活模式或单例模式。\ni.主应用入口文件 与其他框架一样，先配置子应用\n// main-react/index.js import \"react-app-polyfill/stable\"; import \"react-app-polyfill/ie11\"; import React from \"react\"; import ReactDOM from \"react-dom\"; import WujieReact from \"wujie-react\"; import \"./index.css\"; import App from \"./App\"; import hostMap from \"./hostMap\"; import credentialsFetch from \"./fetch\"; import lifecycles from \"./lifecycle\"; import plugins from \"./plugin\"; const { setupApp, preloadApp, bus } = WujieReact; const isProduction = process.env.NODE_ENV === \"production\"; bus.$on(\"click\", (msg) =\u003e window.alert(msg)); const degrade = window.localStorage.getItem(\"degrade\") === \"true\" || !window.Proxy || !window.CustomElementRegistry; /** * 大部分业务无需设置 attrs * 此处修正 iframe 的 src，是防止github pages csp报错 * 因为默认是只有 host+port，没有携带路径 */ const attrs = isProduction ? { src: hostMap(\"//localhost:7700/\") } : {}; /** * 配置应用，主要是设置默认配置 * preloadApp、startApp的配置会基于这个配置做覆盖 */ setupApp({ name: \"react16\", url: hostMap(\"//localhost:7600/\"), attrs, // 子应用iframe的src exec: true, // 预执行 fetch: credentialsFetch, // 自定义的fetch方法 plugins, /** 子应用短路径替换，路由同步时生效 */ prefix: { \"prefix-dialog\": \"/dialog\", \"prefix-location\": \"/location\" }, /** 子应用采用降级iframe方案 */ degrade, ...lifecycles, }); setupApp({ name: \"vue3\", url: hostMap(\"//localhost:7300/\"), attrs, exec: true, alive: true, // 子应用保活，state不会丢失 plugins: [{ cssExcludes: [\"https://stackpath.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css\"] }], // 引入了的第三方样式不需要添加credentials fetch: (url, options) =\u003e url.includes(hostMap(\"//localhost:7300/\")) ? credentialsFetch(url, options) : window.fetch(url, options), degrade, ...lifecycles, }); if (window.localStorage.getItem(\"preload\") !== \"false\") { preloadApp({ name: \"react16\", }); if (window.Proxy) { preloadApp({ name: \"vue3\", }); } } ReactDOM.render(\u003cApp /\u003e, document.getElementById(\"root\")); 引入子应用的地方直接以组件式的方式引入：\nimport React from \"react\"; import hostMap from \"../hostMap\"; import WujieReact from \"wujie-react\"; import { useNavigate, useLocation } from \"react-router-dom\"; export default function React16() { const navigation = useNavigate(); const location = useLocation(); const path = location.pathname.replace(\"/react16-sub\", \"\").replace(\"/react16\", \"\").replace(\"/\",\"\"); //// const react16Url = hostMap(\"//localhost:7600/\") + path; const props = { jump: (name) =\u003e { navigation(`/${name}`); }, }; return ( // 单例模式，name相同则复用一个无界实例，改变url则子应用重新渲染实例到对应路由 \u003cWujieReact width=\"100%\" height=\"100%\" name=\"react16\" url={react16Url} sync={!path} props={props} \u003e\u003c/WujieReact\u003e ); } ii.预览 2.框架优缺点 优点：\n接入简单，可以以组件的方式引入子应用 纯净无污染 无界利用iframe和webcomponent来搭建天然的js隔离沙箱和css隔离沙箱 利用iframe的history和主应用的history在同一个top-level browsing context来搭建天然的路由同步机制 副作用局限在沙箱内部，子应用切换无需任何清理工作，没有额外的切换成本 支持vite esmoudle加载，由于js是独立在iframe中加载的，所以支持esmodule加载 支持预加载 支持应用保活，子应用状态保留，由于是独立在iframe中的，而切换应用时不会移除iframe，所以子应用的状态会被保留在原来的iframe中，当主应用再次渲染子应用dom时，会显示之前的状态。 多应用同时激活在线 缺点：\niframe沙箱的src设置了主应用的host，初始化iframe的时候需要等待iframe的location.orign从’about:blank’初始化为主应用的host，这个采用的计时器去等待的不是很优雅。 框架4: Micro App mirco-app 是京东2021年开源的一款微前端框架。它借助了浏览器对 webComponent 的支持，实现了一套微前端方案体系。并且由于 Shadow Dom 对 react 这类库的兼容性较差，便自己实现了类 Shadow Dom 的效果。与 qiankun 相比，接入更加简单。最新的版本也支持iframe实现js隔离，类似wujie。截至目前（2024年4月）github star 5.2k\n1.实现方案 首先micro-app实现了一个基于WebComponent的组件，并实现了类Shadow Dom 的效果，开发者只需要用来加载子应用，整个对子应用的加载、js隔离、css隔离的逻辑都封装在了web component组件中，具体来说：\n当调用microApp.start()后，会注册一个名为micro-app 的自定义 webComponent 标签。我们可以从 中拿到子应用的线上入口地址。 组件内部，当匹配到路由后，跟qiankun一样加载html，得到html字符串模版 分析html字符串，提取头和，并替换为框架自定义标签和 在内，会对script标签和link标签的内容进行加载并执行 将和插入到标签内 内提供了js沙箱方法（v1.0以前跟qiankun沙箱一样），挂载到后，内部会逐一对内的script标签的js绑定作用域，实现js隔离。 css隔离方案 默认使用正则将CSS字符串切割成最小单元，每个单元包含一段CSS信息，将所有的信息整理生成CSSTree，遍历CSSTree的每个规则，添加前缀实现样式隔离。\njs隔离方案 micro-app有两种方式实现js隔离，默认是跟qiankun一样采用proxy沙箱的方式隔离， 在v1.0发布后支持了基于原生iframe的隔离方式。\n2.Micro App实战 i.主应用入口文件 import React from 'react'; import ReactDOM from 'react-dom'; import './index.css'; import Router from './router'; import microApp from '@micro-zoe/micro-app' microApp.start() ReactDOM.render( \u003cReact.StrictMode\u003e \u003cRouter /\u003e \u003c/React.StrictMode\u003e, document.getElementById('root') ); 调用子应用\nexport function MyPage () { return ( \u003cdiv\u003e \u003ch1\u003e子应用👇\u003c/h1\u003e // name：应用名称, url：应用地址 \u003cmicro-app name='my-app' url='http://localhost:3000/'\u003e\u003c/micro-app\u003e \u003c/div\u003e ) } ii.预览 2.框架优缺点 优点\n接入简单，组件式引入子应用 团队持续更新维护 js隔离、css隔离、路由同步 支持子应用保活, 需要开启keep-alive模式 支持fiber模式，提升主应用的渲染性能。 缺点\n1.0之前不支持vite，1.0之后支持了 默认css隔离方式，主应用的样式还是会污染到子应用。 子应用和主应用必须相同的路由模式，要么同时hash模式，要么同时history模式 依赖于CustomElements和Proxy两个较新的API。Proxy暂时没有做兼容，所以对于不支持Proxy的浏览器无法运行micro-app。 参考 探探各个微前端框架 | 奇舞精选 最后， 希望大家早日实现：成为编程高手的伟大梦想！ 欢迎交流~\n本文版权归原作者曜灵所有！未经允许，严禁转载！对非法转载者, 原作者保留采用法律手段追究的权利！ 若需转载，请联系微信公众号：连先生有猫病，可获取作者联系方式！\n","wordCount":"8826","inLanguage":"zh","datePublished":"2024-05-15T20:37:01+08:00","dateModified":"2024-05-15T20:37:01+08:00","author":[{"@type":"Person","name":"曜灵"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://lianpf.github.io/posts/frontend-develop/microfrontend_framework_compare/"},"publisher":{"@type":"Organization","name":"曜灵（SUN）Site","logo":{"@type":"ImageObject","url":"https://lianpf.github.io/img-common/favicon.png"}}}</script></head><body id=top><script>(function(){let e,t=new RegExp("(^| )change-themes=([^;]*)(;|$)");(e=document.cookie.match(t))||((new Date).getHours()>=19||(new Date).getHours()<6?(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark")):(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")))})(),localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://lianpf.github.io/ accesskey=h title="曜灵（SUN）Site (Alt + H)"><img src=https://lianpf.github.io/img-common/avatar.jpeg alt=logo aria-label=logo height=35>曜灵（SUN）Site</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://lianpf.github.io/search title="🔍 搜索 (Alt + /)" accesskey=/><span>🔍 搜索</span></a></li><li><a href=https://lianpf.github.io/ title="🏠 主页"><span>🏠 主页</span></a></li><li><a href=https://lianpf.github.io/archives/ title="⏱️ 归档"><span>⏱️ 归档</span></a></li><li><a href=https://lianpf.github.io/tags title="🧩 标签"><span>🧩 标签</span></a></li><li><a href=https://lianpf.github.io/about title="🙋🏻‍♂️ 关于"><span>🙋🏻‍♂️ 关于</span></a></li></ul></nav></header><main class="main page"><style>i[id*=post_meta_style]{display:flex;align-items:center;margin:0 0 10px}</style><article class=post-single><div id=single-content><header class=post-header><div class=breadcrumbs><a href=https://lianpf.github.io/>🏠 主页</a>&nbsp;»&nbsp;<a href=https://lianpf.github.io/posts/>📚文章</a>&nbsp;»&nbsp;<a href=https://lianpf.github.io/posts/frontend-develop/>👨🏻‍💻 前端</a></div><h1 class=post-title>微前端: qiankun、wujie和Micro App等框架对比</h1><div class=post-meta><style>i[id*=post_meta_style]{display:flex;align-items:center;margin:0 0 10px}.parent-post-meta{display:flex;flex-wrap:wrap;opacity:.8}</style><span class=parent-post-meta><span id=post_meta_style_1><span class="fa fa-calendar-check-o"></span>
<span>2024-05-15
&nbsp;&nbsp;</span></span>
<span id=post_meta_style_3><span class="fa fa-file-word-o"></span>
<span>8826字
&nbsp;&nbsp;</span></span>
<span id=post_meta_style_4><span class="fa fa-clock-o"></span>
<span>18分钟
&nbsp;&nbsp;</span></span>
<span id=post_meta_style_5><span class="fa fa-user-o"></span>
<span>曜灵
&nbsp;&nbsp;</span></span>
<span id=post_meta_style_6><span class="fa fa-tags" style=opacity:.8></span>
<span><span class=post-tags-meta><a href=https://lianpf.github.io/tags/%E5%B7%A5%E5%85%B7/ style=color:var(--secondary)!important>工具</a></span></span></span></span>
<span style=opacity:.8><span id=post_meta_style_7>&nbsp;&nbsp;
<span class="fa fa-eye"></span>
<span><span id=busuanzi_container_page_pv><span id=busuanzi_value_page_pv></span></span>
&nbsp;&nbsp;</span></span>
<span id=post_meta_style_8><span class="fa fa-commenting-o"></span>
<span><script src=https://cdn.staticfile.org/twikoo/1.5.8/twikoo.all.min.js></script>
<script>let url=document.documentURI,dnsUrl="https://lianpf.github.io/",urlSplit=url.split(dnsUrl),finalUrl=urlSplit[1];finalUrl[0]!=="/"&&(finalUrl="/"+finalUrl),twikoo.getCommentsCount({envId:null,region:null,urls:[finalUrl],includeReply:!1}).then(function(e){let t=e[0].count;const n=document.getElementById("comment_count");n.innerText=t}).catch(function(e){console.error(e)})</script><span id=comment_count></span></span></span></span></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#%e4%b8%80iframe-vs-%e5%be%ae%e5%89%8d%e7%ab%af%e6%9e%b6%e6%9e%84 aria-label="一、iframe vs 微前端架构">一、iframe vs 微前端架构</a><ul><li><a href=#1iframe aria-label=1.iframe>1.iframe</a></li><li><a href=#2%e5%be%ae%e5%89%8d%e7%ab%af%e6%9e%b6%e6%9e%84 aria-label=2.微前端架构>2.微前端架构</a></li></ul></li><li><a href=#%e4%ba%8c%e5%be%ae%e5%89%8d%e7%ab%af%e6%9e%b6%e6%9e%84 aria-label=二、微前端架构>二、微前端架构</a><ul><li><a href=#%e6%a1%86%e6%9e%b61-single-spa aria-label="框架1: single-spa">框架1: single-spa</a><ul><li><a href=#1%e5%ae%9e%e7%8e%b0%e6%96%b9%e6%a1%88 aria-label=1.实现方案>1.实现方案</a></li><li><a href=#2single-spa%e5%ae%9e%e6%88%98 aria-label=2.single-spa实战>2.single-spa实战</a><ul><li><a href=#i%e4%b8%bb%e5%ba%94%e7%94%a8%e5%85%a5%e5%8f%a3%e6%96%87%e4%bb%b6 aria-label=i.主应用入口文件>i.主应用入口文件</a></li><li><a href=#ii%e5%ad%90%e5%ba%94%e7%94%a8%e5%af%bc%e5%87%ba%e6%96%87%e4%bb%b6 aria-label=ii.子应用导出文件>ii.子应用导出文件</a></li><li><a href=#iii%e6%89%93%e5%8c%85%e9%85%8d%e7%bd%ae aria-label=iii.打包配置>iii.打包配置</a></li><li><a href=#iv%e9%a2%84%e8%a7%88 aria-label=iv.预览>iv.预览</a></li></ul></li><li><a href=#3%e6%a1%86%e6%9e%b6%e4%bc%98%e7%bc%ba%e7%82%b9 aria-label=3.框架优缺点>3.框架优缺点</a></li></ul></li><li><a href=#%e6%a1%86%e6%9e%b62-qiankun aria-label="框架2: qiankun">框架2: qiankun</a><ul><li><a href=#1%e5%ae%9e%e7%8e%b0%e6%96%b9%e6%a1%88-1 aria-label=1.实现方案>1.实现方案</a></li><li><a href=#2qiankun%e5%ae%9e%e6%88%98 aria-label=2.qiankun实战>2.qiankun实战</a><ul><li><a href=#i%e4%b8%bb%e5%ba%94%e7%94%a8%e5%85%a5%e5%8f%a3%e6%96%87%e4%bb%b6-1 aria-label=i.主应用入口文件>i.主应用入口文件</a></li><li><a href=#ii%e5%ad%90%e5%ba%94%e7%94%a8%e5%af%bc%e5%87%ba%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f%e9%92%a9%e5%ad%90 aria-label=ii.子应用导出生命周期钩子>ii.子应用导出生命周期钩子</a></li><li><a href=#iii-%e9%85%8d%e7%bd%ae%e6%89%93%e5%8c%85%e5%b7%a5%e5%85%b7 aria-label="iii. 配置打包工具">iii. 配置打包工具</a></li><li><a href=#iv%e9%a2%84%e8%a7%88-1 aria-label=iv.预览>iv.预览</a></li></ul></li><li><a href=#3%e6%a1%86%e6%9e%b6%e4%bc%98%e7%bc%ba%e7%82%b9-1 aria-label=3.框架优缺点>3.框架优缺点</a></li></ul></li><li><a href=#%e6%a1%86%e6%9e%b63-wujie aria-label="框架3: wujie">框架3: wujie</a><ul><li><a href=#1%e5%ae%9e%e7%8e%b0%e6%96%b9%e6%a1%88-2 aria-label=1.实现方案>1.实现方案</a></li><li><a href=#2wujie%e5%ae%9e%e6%88%98 aria-label=2.wujie实战>2.wujie实战</a><ul><li><a href=#i%e4%b8%bb%e5%ba%94%e7%94%a8%e5%85%a5%e5%8f%a3%e6%96%87%e4%bb%b6-2 aria-label=i.主应用入口文件>i.主应用入口文件</a></li><li><a href=#ii%e9%a2%84%e8%a7%88 aria-label=ii.预览>ii.预览</a></li></ul></li><li><a href=#2%e6%a1%86%e6%9e%b6%e4%bc%98%e7%bc%ba%e7%82%b9 aria-label=2.框架优缺点>2.框架优缺点</a></li></ul></li><li><a href=#%e6%a1%86%e6%9e%b64-micro-app aria-label="框架4: Micro App">框架4: Micro App</a><ul><li><a href=#1%e5%ae%9e%e7%8e%b0%e6%96%b9%e6%a1%88-3 aria-label=1.实现方案>1.实现方案</a></li><li><a href=#2micro-app%e5%ae%9e%e6%88%98 aria-label="2.Micro App实战">2.Micro App实战</a><ul><li><a href=#i%e4%b8%bb%e5%ba%94%e7%94%a8%e5%85%a5%e5%8f%a3%e6%96%87%e4%bb%b6-3 aria-label=i.主应用入口文件>i.主应用入口文件</a></li><li><a href=#ii%e9%a2%84%e8%a7%88-1 aria-label=ii.预览>ii.预览</a></li></ul></li><li><a href=#2%e6%a1%86%e6%9e%b6%e4%bc%98%e7%bc%ba%e7%82%b9-1 aria-label=2.框架优缺点>2.框架优缺点</a></li></ul></li></ul></li><li><a href=#%e5%8f%82%e8%80%83 aria-label=参考>参考</a></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{elements&&(activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")}))},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><p>系列文章：</p><ul><li>第一篇：<a href=/posts/frontend-develop/microfrontend_framework_compare/>微前端: qiankun、wujie和Micro App等框架对比</a></li></ul><p>微前端架构主要解决单体应用（常见于企业级 Web 应用）在一个相对长的时间跨度下，由于参与的人员、团队的增多、变迁，从一个普通应用演变成一个 <strong><font color=Tomato>巨石应用(Frontend Monolith)</font></strong> 后，应用不可维护的问题。</p><p>在各大微前端解决方案出现前，通常用<code>iframe</code>解决这类问题。本文首先从<code>iframe</code>和<code>微前端架构</code>的视角，去对比下原理。其次，对比现有的各大微前端框架</p><hr><h2 id=一iframe-vs-微前端架构>一、iframe vs 微前端架构<a hidden class=anchor aria-hidden=true href=#一iframe-vs-微前端架构>#</a></h2><h3 id=1iframe>1.iframe<a hidden class=anchor aria-hidden=true href=#1iframe>#</a></h3><p><strong><font color=Tomato><code>iframe</code>提供了浏览器原生的硬隔离方案</font></strong> ，不论是【巨石应用】的样式隔离、js隔离问题都能被完美解决。<br>但最大问题也在于<code>iframe</code>的隔离性无法被突破，导致<strong>应用间上下文无法被共享</strong>，带来开发和产品体验的问题：</p><ol><li><code>url</code>不同步: 浏览器刷新<code>iframe url</code>状态丢失、后退前进按钮无法使用</li><li><code>UI</code>不同步: <code>DOM</code>结构不共享，弹窗只能在<code>iframe</code>内部展示，无法覆盖全局</li><li>隔离问题: 全局上下文完全隔离，内存变量不共享，iframe内外系统的通信、数据同步等需求，主应用的<code>cookie</code>要透传到根域名都不同的子应用中实现免登效果</li><li>慢: 每次子应用进入都是一次浏览器上下文重建、资源重新加载的过程</li></ol><h3 id=2微前端架构>2.微前端架构<a hidden class=anchor aria-hidden=true href=#2微前端架构>#</a></h3><p>微前端框架内的各个应用都支持独立开发部署、不限技术框架、支持独立运行、应用状态隔离但也可共享等特征。</p><hr><h2 id=二微前端架构>二、微前端架构<a hidden class=anchor aria-hidden=true href=#二微前端架构>#</a></h2><h3 id=框架1-single-spa>框架1: single-spa<a hidden class=anchor aria-hidden=true href=#框架1-single-spa>#</a></h3><p><a href=https://github.com/single-spa/single-spa>single-spa</a>是最早的微前端框架，兼容多种前端技术栈，支持将多个单页面应用聚合为一个整体应用的。</p><blockquote><p>简单来说就是【聚合】，该库可让你的应用使用多个不同的技术栈（vue、react、angular等)进行同步开发，最后使用一个公用的路由去实现完美的切换</p></blockquote><h4 id=1实现方案>1.实现方案<a hidden class=anchor aria-hidden=true href=#1实现方案>#</a></h4><p><code>single-spa</code>实现了一套 <strong>【生命周期】</strong>，开发者需在相应的时机自己去加载对应的子应用。它做的事情就是：注册子应用、监听URL变化，然后加载对应的子应用js，执行对应子应用的生命周期流程。</p><ol><li>提供<code>registerApplication</code>方法，用来注册子应用列表</li><li>提供<code>activeWhen</code>，由开发者指定路由满足条件时，激活（挂载）子应用的js、css。</li><li>js隔离由<code>single-spa-leaked-globals</code>实现<br>本质上就是在 mount A 子应用时，正常添加全局变量，比如 jQuery 的 $, lodash 的 _。在 unmount A 子应用时，用一个对象记录之前给 window 添加的全局变量，并把 A 应用里添加 window 的变量都删掉。下一次再 mount A 应用时，把记录的全局变量重新加回来。</li><li>css隔离：<ul><li>子应用之间通过<code>single-spa-css</code>插件提供的css生命周期函数，做到子应用mount时加载css，子应用unmount时将css unmount掉</li><li>主应用与子应用之间可通过<code>PostCSSPrefix Selector</code>给样式自动加前缀的方式，或<code>Shadow DOM</code>的形式去解决。</li></ul></li></ol><h4 id=2single-spa实战>2.single-spa实战<a hidden class=anchor aria-hidden=true href=#2single-spa实战>#</a></h4><h5 id=i主应用入口文件>i.主应用入口文件<a hidden class=anchor aria-hidden=true href=#i主应用入口文件>#</a></h5><p>主要通过<code>single-spa</code>提供的<code>registerApplication</code>方法注册子应用，子应用需要指定加载子应用的方法、和路由条件</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>import</span> <span style=color:#a6e22e>Vue</span> <span style=color:#a6e22e>from</span> <span style=color:#e6db74>&#39;vue&#39;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>import</span> <span style=color:#a6e22e>App</span> <span style=color:#a6e22e>from</span> <span style=color:#e6db74>&#39;./App.vue&#39;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>import</span> <span style=color:#a6e22e>router</span> <span style=color:#a6e22e>from</span> <span style=color:#e6db74>&#39;./router&#39;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>import</span> { <span style=color:#a6e22e>registerApplication</span>, <span style=color:#a6e22e>start</span> } <span style=color:#a6e22e>from</span> <span style=color:#e6db74>&#39;single-spa&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>Vue</span>.<span style=color:#a6e22e>config</span>.<span style=color:#a6e22e>productionTip</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 远程加载子应用
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>createScript</span>(<span style=color:#a6e22e>url</span>) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> Promise((<span style=color:#a6e22e>resolve</span>, <span style=color:#a6e22e>reject</span>) =&gt; {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>script</span> <span style=color:#f92672>=</span> document.<span style=color:#a6e22e>createElement</span>(<span style=color:#e6db74>&#39;script&#39;</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>script</span>.<span style=color:#a6e22e>src</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>url</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>script</span>.<span style=color:#a6e22e>onload</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>resolve</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>script</span>.<span style=color:#a6e22e>onerror</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>reject</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>firstScript</span> <span style=color:#f92672>=</span> document.<span style=color:#a6e22e>getElementsByTagName</span>(<span style=color:#e6db74>&#39;script&#39;</span>)[<span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>firstScript</span>.<span style=color:#a6e22e>parentNode</span>.<span style=color:#a6e22e>insertBefore</span>(<span style=color:#a6e22e>script</span>, <span style=color:#a6e22e>firstScript</span>)
</span></span><span style=display:flex><span>  })
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 加载函数，返回一个 promise
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>loadApp</span>(<span style=color:#a6e22e>url</span>, <span style=color:#a6e22e>globalVar</span>) {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 支持远程加载子应用
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>async</span> () =&gt; {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>createScript</span>(<span style=color:#a6e22e>url</span> <span style=color:#f92672>+</span> <span style=color:#e6db74>&#39;/js/chunk-vendors.js&#39;</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>createScript</span>(<span style=color:#a6e22e>url</span> <span style=color:#f92672>+</span> <span style=color:#e6db74>&#39;/js/app.js&#39;</span>)
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 这里的return很重要，需要从这个全局对象中拿到子应用暴露出来的生命周期函数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> window[<span style=color:#a6e22e>globalVar</span>]
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 子应用列表
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>apps</span> <span style=color:#f92672>=</span> [
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 子应用名称
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>name</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;app1&#39;</span>,
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 子应用加载函数，是一个promise
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>app</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>loadApp</span>(<span style=color:#e6db74>&#39;http://localhost:8081&#39;</span>, <span style=color:#e6db74>&#39;app1&#39;</span>),
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 当路由满足条件时（返回true），激活（挂载）子应用
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>activeWhen</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>location</span> =&gt; <span style=color:#a6e22e>location</span>.<span style=color:#a6e22e>pathname</span>.<span style=color:#a6e22e>startsWith</span>(<span style=color:#e6db74>&#39;/app1&#39;</span>),
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 传递给子应用的对象
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>customProps</span><span style=color:#f92672>:</span> {}
</span></span><span style=display:flex><span>  },
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>name</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;app2&#39;</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>app</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>loadApp</span>(<span style=color:#e6db74>&#39;http://localhost:8082&#39;</span>, <span style=color:#e6db74>&#39;app2&#39;</span>),
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>activeWhen</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>location</span> =&gt; <span style=color:#a6e22e>location</span>.<span style=color:#a6e22e>pathname</span>.<span style=color:#a6e22e>startsWith</span>(<span style=color:#e6db74>&#39;/app2&#39;</span>),
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>customProps</span><span style=color:#f92672>:</span> {}
</span></span><span style=display:flex><span>  },
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 子应用名称
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>name</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;app3&#39;</span>,
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 子应用加载函数，是一个promise
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>app</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>loadApp</span>(<span style=color:#e6db74>&#39;http://localhost:3000&#39;</span>, <span style=color:#e6db74>&#39;app3&#39;</span>),
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 当路由满足条件时（返回true），激活（挂载）子应用
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>activeWhen</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>location</span> =&gt; <span style=color:#a6e22e>location</span>.<span style=color:#a6e22e>pathname</span>.<span style=color:#a6e22e>startsWith</span>(<span style=color:#e6db74>&#39;/app3&#39;</span>),
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 传递给子应用的对象，这个很重要，该配置告诉react子应用自己的容器元素是什么，这块儿和vue子应用的集成不一样，官网并没有说这部分，或者我没找到，是通过看single-spa-react源码知道的
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>customProps</span><span style=color:#f92672>:</span> {
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>domElement</span><span style=color:#f92672>:</span> document.<span style=color:#a6e22e>getElementById</span>(<span style=color:#e6db74>&#39;microApp&#39;</span>),
</span></span><span style=display:flex><span>      <span style=color:#75715e>// 添加 name 属性是为了兼容自己写的lyn-single-spa，原生的不需要，当然加了也不影响
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#a6e22e>name</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;app3&#39;</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 注册子应用
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>apps</span>.<span style=color:#a6e22e>length</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>; <span style=color:#a6e22e>i</span> <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>--</span>) {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>registerApplication</span>(<span style=color:#a6e22e>apps</span>[<span style=color:#a6e22e>i</span>])
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Vue</span>({
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>router</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>mounted</span>() {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 启动
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>start</span>()
</span></span><span style=display:flex><span>  },
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>render</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>h</span> =&gt; <span style=color:#a6e22e>h</span>(<span style=color:#a6e22e>App</span>)
</span></span><span style=display:flex><span>}).<span style=color:#a6e22e>$mount</span>(<span style=color:#e6db74>&#39;#app&#39;</span>)
</span></span></code></pre></div><h5 id=ii子应用导出文件>ii.子应用导出文件<a hidden class=anchor aria-hidden=true href=#ii子应用导出文件>#</a></h5><ul><li>子应用需要安装single-spa-react或者single-spa-vue，</li><li>将子应用传递给single-spa-react，得到子应用运行的生命周期，</li><li>子应用将生命周期导出到全局，</li><li>在主应用可以获取子应用的生命周期函数</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>import</span> <span style=color:#a6e22e>React</span> <span style=color:#a6e22e>from</span> <span style=color:#e6db74>&#39;react&#39;</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>import</span> <span style=color:#a6e22e>ReactDOM</span> <span style=color:#a6e22e>from</span> <span style=color:#e6db74>&#39;react-dom&#39;</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>import</span> <span style=color:#e6db74>&#39;./index.css&#39;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>import</span> { <span style=color:#a6e22e>BrowserRouter</span>, <span style=color:#a6e22e>Link</span>, <span style=color:#a6e22e>Route</span> } <span style=color:#a6e22e>from</span> <span style=color:#e6db74>&#39;react-router-dom&#39;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>import</span> <span style=color:#a6e22e>singleSpaReact</span> <span style=color:#a6e22e>from</span> <span style=color:#e6db74>&#39;single-spa-react&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 子应用独立运行
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>window.<span style=color:#a6e22e>singleSpaNavigate</span>) {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>ReactDOM</span>.<span style=color:#a6e22e>render</span>(<span style=color:#a6e22e>rootComponent</span>(), document.<span style=color:#a6e22e>getElementById</span>(<span style=color:#e6db74>&#39;root&#39;</span>))
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 生命周期a
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>reactLifecycles</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>singleSpaReact</span>({
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>React</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>ReactDOM</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>rootComponent</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>errorBoundary</span>(<span style=color:#a6e22e>err</span>, <span style=color:#a6e22e>info</span>, <span style=color:#a6e22e>props</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#f92672>&lt;</span><span style=color:#a6e22e>div</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>This</span> <span style=color:#a6e22e>renders</span> <span style=color:#a6e22e>when</span> <span style=color:#a6e22e>a</span> <span style=color:#a6e22e>catastrophic</span> <span style=color:#a6e22e>error</span> <span style=color:#a6e22e>occurs</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;</span><span style=color:#960050;background-color:#1e0010>/div&gt;</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>})
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 这里和vue不一样，props必须向下传递
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>bootstrap</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>async</span> <span style=color:#a6e22e>props</span> =&gt; {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#39;app3 bootstrap&#39;</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>reactLifecycles</span>.<span style=color:#a6e22e>bootstrap</span>(<span style=color:#a6e22e>props</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>mount</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>async</span> <span style=color:#a6e22e>props</span> =&gt; {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#39;app3 mount&#39;</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>reactLifecycles</span>.<span style=color:#a6e22e>mount</span>(<span style=color:#a6e22e>props</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>unmount</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>async</span> <span style=color:#a6e22e>props</span> =&gt; {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#39;app3 unmount&#39;</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>reactLifecycles</span>.<span style=color:#a6e22e>unmount</span>(<span style=color:#a6e22e>props</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 根组件
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>rootComponent</span>() {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#f92672>&lt;</span><span style=color:#a6e22e>React</span>.<span style=color:#a6e22e>StrictMode</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;</span><span style=color:#a6e22e>BrowserRouter</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>&lt;</span><span style=color:#a6e22e>div</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>&lt;</span><span style=color:#a6e22e>Link</span> <span style=color:#a6e22e>to</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;/app3&#34;</span><span style=color:#f92672>&gt;</span><span style=color:#a6e22e>Home</span><span style=color:#f92672>&lt;</span><span style=color:#960050;background-color:#1e0010>/Link&gt; |</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>&lt;</span><span style=color:#a6e22e>Link</span> <span style=color:#a6e22e>to</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;/app3/about&#34;</span><span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>About</span><span style=color:#f92672>&lt;</span><span style=color:#960050;background-color:#1e0010>/Link&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>&lt;</span><span style=color:#a6e22e>Route</span> <span style=color:#a6e22e>exact</span> <span style=color:#a6e22e>path</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;/app3&#34;</span> <span style=color:#a6e22e>component</span><span style=color:#f92672>=</span>{<span style=color:#a6e22e>Home</span>} <span style=color:#f92672>/&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>&lt;</span><span style=color:#a6e22e>Route</span> <span style=color:#a6e22e>exact</span> <span style=color:#a6e22e>path</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;/app3/about&#34;</span> <span style=color:#a6e22e>component</span><span style=color:#f92672>=</span>{<span style=color:#a6e22e>About</span>} <span style=color:#f92672>/&gt;</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>&lt;</span><span style=color:#960050;background-color:#1e0010>/div&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;</span><span style=color:#960050;background-color:#1e0010>/BrowserRouter&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>&lt;</span><span style=color:#960050;background-color:#1e0010>/React.StrictMode&gt;</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// home 组件
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>Home</span>() {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#f92672>&lt;</span><span style=color:#a6e22e>div</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;</span><span style=color:#a6e22e>h1</span><span style=color:#f92672>&gt;</span><span style=color:#a6e22e>app3</span> <span style=color:#a6e22e>home</span> <span style=color:#a6e22e>page</span><span style=color:#f92672>&lt;</span><span style=color:#960050;background-color:#1e0010>/h1&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>&lt;</span><span style=color:#960050;background-color:#1e0010>/div&gt;</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// about 组件
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>About</span>() {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#f92672>&lt;</span><span style=color:#a6e22e>div</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;</span><span style=color:#a6e22e>h1</span><span style=color:#f92672>&gt;</span><span style=color:#a6e22e>app3</span> <span style=color:#a6e22e>about</span> <span style=color:#a6e22e>page</span><span style=color:#f92672>&lt;</span><span style=color:#960050;background-color:#1e0010>/h1&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>&lt;</span><span style=color:#960050;background-color:#1e0010>/div&gt;</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h5 id=iii打包配置>iii.打包配置<a hidden class=anchor aria-hidden=true href=#iii打包配置>#</a></h5><p>将子应用导出模式设置为umd</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>package</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>require</span>(<span style=color:#e6db74>&#39;./package.json&#39;</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>module</span>.<span style=color:#a6e22e>exports</span> <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 告诉子应用在这个地址加载静态资源，否则会去基座应用的域名下加载
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>publicPath</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;//localhost:8082&#39;</span>,
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 开发服务器
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>devServer</span><span style=color:#f92672>:</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>port</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>8082</span>
</span></span><span style=display:flex><span>  },
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>configureWebpack</span><span style=color:#f92672>:</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 导出umd格式的包，在全局对象上挂载属性package.name，基座应用需要通过这个全局对象获取一些信息，比如子应用导出的生命周期函数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>output</span><span style=color:#f92672>:</span> {
</span></span><span style=display:flex><span>      <span style=color:#75715e>// library的值在所有子应用中需要唯一
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#a6e22e>library</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>package</span>.<span style=color:#a6e22e>name</span>,
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>libraryTarget</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;umd&#39;</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h5 id=iv预览>iv.预览<a hidden class=anchor aria-hidden=true href=#iv预览>#</a></h5><img src=https://cdn.jsdelivr.net/gh/lianpf/image-bed@main/blog/2024/20240515-001.webp width=800><p>可以看到它是动态加载的子应用的js，并执行js，将内容渲染到了主应用的盒子内。</p><h4 id=3框架优缺点>3.框架优缺点<a hidden class=anchor aria-hidden=true href=#3框架优缺点>#</a></h4><p>优点：</p><ul><li>敏捷性 - 独立开发、独立部署，微应用仓库独立，前后端可独立开发，部署完成后主框架自动完成同步更新；</li><li>技术栈无关，主框架不限制接入应用的技术栈，微应用具备完全自主权；</li><li>增量升级，在面对各种复杂场景时，我们通常很难对一个已经存在的系统做全量的技术栈升级或重构，而微前端是一种非常好的实施渐进式重构的手段和策略</li></ul><p>缺点：</p><ul><li>需要自己去加载子应用</li><li>不支持Javascript沙箱隔离，需要自己去使用single-spa-leaked-globals之类的库去隔离</li><li>不支持css隔离，需要自己使用single-spa-css库或者postcss等去解决样式冲突问题</li><li>无法预加载</li></ul><h3 id=框架2-qiankun>框架2: qiankun<a hidden class=anchor aria-hidden=true href=#框架2-qiankun>#</a></h3><p>阿里的<code>qiankun</code>是基于<code>single-spa</code>的微前端实现库，孵化自蚂蚁，能更简单、无痛的构建一个生产可用微前端架构系统。目前(2024年4月) github star 15.4k。</p><h4 id=1实现方案-1>1.实现方案<a hidden class=anchor aria-hidden=true href=#1实现方案-1>#</a></h4><ul><li>single-spa是基于js-entry方案，而qiankun 是基于html-entry 及沙箱设计，使得微应用的接入 像使用 iframe 一样简单。</li><li>主应用监听路由，加载对应子应用的html，挂载到主应用的元素内，然后解析子应用的html，从中分析出css、js再去沙盒化后加载执行，最终将子应用的内容渲染出来。</li><li>qiankun实现样式隔离有两种模式可供开发者选择：<ul><li>strictStyleIsolation： 这种模式下 qiankun 会为每个微应用的容器包裹上一个 shadow dom 节点，从而确保微应用的样式不会对全局造成影响。</li><li>experimentalStyleIsolation： 当 experimentalStyleIsolation 被设置为 true 时，qiankun 会改写子应用所添加的样式，会为所有样式规则增加一个特殊的选择器规则，来限定其影响范围</li></ul></li><li>qiankun实现js隔离，采用了两种沙箱，分别为基于Proxy实现的沙箱和快照沙箱，当浏览器不支持Proxy会降级为快照沙箱</li></ul><p><code>Proxy沙箱机制</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#75715e>// 伪代码
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ProxySandbox</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>constructor</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>rawWindow</span> <span style=color:#f92672>=</span> window;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>fakeWindow</span> <span style=color:#f92672>=</span> {}
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>proxy</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Proxy(<span style=color:#a6e22e>fakeWindow</span>, {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>set</span>(<span style=color:#a6e22e>target</span>, <span style=color:#a6e22e>p</span>, <span style=color:#a6e22e>value</span>) {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>target</span>[<span style=color:#a6e22e>p</span>] <span style=color:#f92672>=</span> <span style=color:#a6e22e>value</span>;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>            },
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>get</span>(<span style=color:#a6e22e>target</span>, <span style=color:#a6e22e>p</span>) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>target</span>[<span style=color:#a6e22e>p</span>] <span style=color:#f92672>||</span> <span style=color:#a6e22e>rawWindow</span>[<span style=color:#a6e22e>p</span>];
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        });
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>proxy</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>proxy</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>sandbox1</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>ProxySandbox</span>();
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>sandbox2</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>ProxySandbox</span>();
</span></span><span style=display:flex><span>window.<span style=color:#a6e22e>a</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span><span style=color:#75715e>// 伪代码
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>((window) =&gt; {
</span></span><span style=display:flex><span>    window.<span style=color:#a6e22e>a</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;hello&#39;</span>;
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(window.<span style=color:#a6e22e>a</span>) <span style=color:#75715e>// hello
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>})(<span style=color:#a6e22e>sandbox1</span>.<span style=color:#a6e22e>proxy</span>);
</span></span><span style=display:flex><span>((window) =&gt; {
</span></span><span style=display:flex><span>    window.<span style=color:#a6e22e>a</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;world&#39;</span>;
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(window.<span style=color:#a6e22e>a</span>) <span style=color:#75715e>// world
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>})(<span style=color:#a6e22e>sandbox2</span>.<span style=color:#a6e22e>proxy</span>);
</span></span></code></pre></div><p><strong>快照沙箱</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#75715e>// 伪代码
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>SnapshotSandbox</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>constructor</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>proxy</span> <span style=color:#f92672>=</span> window; 
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>modifyPropsMap</span> <span style=color:#f92672>=</span> {}; <span style=color:#75715e>// 修改了那些属性
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>active</span>(); <span style=color:#75715e>// 调用active保存主应用window快照
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/**1. 初始化时，在子应用即将mount前，先调用active，保存当前主应用的window快照*/</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>active</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>windowSnapshot</span> <span style=color:#f92672>=</span> {}; <span style=color:#75715e>// window对象的快照
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>const</span> <span style=color:#a6e22e>prop</span> <span style=color:#66d9ef>in</span> window) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (window.<span style=color:#a6e22e>hasOwnProperty</span>(<span style=color:#a6e22e>prop</span>)) {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 将window上的属性进行拍照
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>windowSnapshot</span>[<span style=color:#a6e22e>prop</span>] <span style=color:#f92672>=</span> window[<span style=color:#a6e22e>prop</span>];
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        Object.<span style=color:#a6e22e>keys</span>(<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>modifyPropsMap</span>).<span style=color:#a6e22e>forEach</span>(<span style=color:#a6e22e>p</span> =&gt; {
</span></span><span style=display:flex><span>            window[<span style=color:#a6e22e>p</span>] <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>modifyPropsMap</span>[<span style=color:#a6e22e>p</span>];
</span></span><span style=display:flex><span>        });
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e>    * 子应用卸载时，遍历当前子应用的window属性，和主应用的window快照做对比
</span></span></span><span style=display:flex><span><span style=color:#75715e>    * 如果不一致，做两步操作 
</span></span></span><span style=display:flex><span><span style=color:#75715e>    *     1. 保存 不一致的window属性，
</span></span></span><span style=display:flex><span><span style=color:#75715e>    *     2. 还原window
</span></span></span><span style=display:flex><span><span style=color:#75715e>    */</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>inactive</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>const</span> <span style=color:#a6e22e>prop</span> <span style=color:#66d9ef>in</span> window) { <span style=color:#75715e>// diff 差异
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> (window.<span style=color:#a6e22e>hasOwnProperty</span>(<span style=color:#a6e22e>prop</span>)) {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 将上次拍照的结果和本次window属性做对比
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>if</span> (window[<span style=color:#a6e22e>prop</span>] <span style=color:#f92672>!==</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>windowSnapshot</span>[<span style=color:#a6e22e>prop</span>]) {
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// 保存修改后的结果
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>modifyPropsMap</span>[<span style=color:#a6e22e>prop</span>] <span style=color:#f92672>=</span> window[<span style=color:#a6e22e>prop</span>]; 
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// 还原window
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    window[<span style=color:#a6e22e>prop</span>] <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>windowSnapshot</span>[<span style=color:#a6e22e>prop</span>]; 
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=2qiankun实战>2.qiankun实战<a hidden class=anchor aria-hidden=true href=#2qiankun实战>#</a></h4><h5 id=i主应用入口文件-1>i.主应用入口文件<a hidden class=anchor aria-hidden=true href=#i主应用入口文件-1>#</a></h5><p><strong>初始化主应用，并注册子应用</strong><br>主应用入口文件初始化应用，注册子应用，注册子应用时支持传入子应用列表， 注册子应用时需要指明以下几个主要参数：</p><ul><li>name： 微应用的名称，微应用之间必须确保唯一</li><li>entry： 子应用的访问链接。主应用会加载整个页面，例如https://qiankun.umijs.org/guide/</li><li>container：需要挂载子应用的DOM元素</li><li>loader: 子应用未加载时的界面，一般为loading</li><li>activeRule： 路由匹配规则</li></ul><p><strong>开启子应用start(options)</strong><br></p><ul><li><code>options.prefetch</code>此时可以选择是否预加载子应用。</li><li><code>options.sandbox</code>默认情况下的沙箱可确保【单实例场景子应用之间】的样式隔离，但无法确保主应用和子应用、或者多实例场景的子应用样式隔离。qiankun提供了另外两种方式的隔离，供开发者选择：<ul><li><code>strictStyleIsolation</code>：当配置为<code>{ strictStyleIsolation: true }</code>时表示开启严格的样式隔离模式。这种模式下<code>qiankun</code>会为每个微应用的容器包裹上一个<code>shadow dom</code>节点，从而确保微应用的样式不会对全局造成影响</li><li><code>experimentalStyleIsolation</code>：当<code>{experimentalStyleIsolation: true}</code>被设置，qiankun会改写子应用所添加的样式为所有样式规则增加一个特殊的选择器规则来限定其影响范围</li></ul></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>import</span> { <span style=color:#a6e22e>registerMicroApps</span>, <span style=color:#a6e22e>start</span>, <span style=color:#a6e22e>initGlobalState</span> } <span style=color:#a6e22e>from</span> <span style=color:#e6db74>&#39;qiankun&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>registerMicroApps</span>([
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>name</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;react app&#39;</span>, <span style=color:#75715e>// app name registered
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>entry</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;//localhost:7100&#39;</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>container</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;#yourContainer&#39;</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>activeRule</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;/yourActiveRule&#39;</span>,
</span></span><span style=display:flex><span>  },
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>name</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;vue app&#39;</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>entry</span><span style=color:#f92672>:</span> { <span style=color:#a6e22e>scripts</span><span style=color:#f92672>:</span> [<span style=color:#e6db74>&#39;//localhost:7100/main.js&#39;</span>] },
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>container</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;#yourContainer2&#39;</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>activeRule</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;/yourActiveRule2&#39;</span>,
</span></span><span style=display:flex><span>  },
</span></span><span style=display:flex><span>]);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 通讯
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> { <span style=color:#a6e22e>onGlobalStateChange</span>, <span style=color:#a6e22e>setGlobalState</span> } <span style=color:#f92672>=</span> <span style=color:#a6e22e>initGlobalState</span>({
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>user</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;qiankun&#39;</span>,
</span></span><span style=display:flex><span>});
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>onGlobalStateChange</span>((<span style=color:#a6e22e>value</span>, <span style=color:#a6e22e>prev</span>) =&gt; <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#39;[onGlobalStateChange - master]:&#39;</span>, <span style=color:#a6e22e>value</span>, <span style=color:#a6e22e>prev</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>setGlobalState</span>({
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>ignore</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;master&#39;</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>user</span><span style=color:#f92672>:</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>name</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;master&#39;</span>,
</span></span><span style=display:flex><span>  },
</span></span><span style=display:flex><span>});
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * 设置默认进入的子应用
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>setDefaultMountApp</span>(<span style=color:#e6db74>&#39;/react16&#39;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * 启动应用
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>start</span>({
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>prefetch</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>true</span>, <span style=color:#75715e>// 预加载子应用
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>sandbox</span><span style=color:#f92672>:</span>{
</span></span><span style=display:flex><span>     <span style=color:#a6e22e>strictStyleIsolation</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>true</span>, <span style=color:#75715e>//  shadow dom的方式实现样式隔离
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// experimentalStyleIsolation: true, //添加特殊的选择器的方式实现样式隔离
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  }
</span></span><span style=display:flex><span>});
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>runAfterFirstMounted</span>(() =&gt; {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#39;[MainApp] first app mounted&#39;</span>);
</span></span><span style=display:flex><span>});
</span></span></code></pre></div><h5 id=ii子应用导出生命周期钩子>ii.子应用导出生命周期钩子<a hidden class=anchor aria-hidden=true href=#ii子应用导出生命周期钩子>#</a></h5><p>子应用需在自己的入口 js导出<code>bootstrap</code>、<code>mount</code>、<code>unmount</code>三个生命周期钩子，以供主应用在适当的时机调用</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=display:flex><span><span style=color:#66d9ef>import</span> <span style=color:#a6e22e>React</span> <span style=color:#a6e22e>from</span> <span style=color:#e6db74>&#39;react&#39;</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>import</span> <span style=color:#a6e22e>ReactDOM</span> <span style=color:#a6e22e>from</span> <span style=color:#e6db74>&#39;react-dom&#39;</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>import</span> <span style=color:#a6e22e>App</span> <span style=color:#a6e22e>from</span> <span style=color:#e6db74>&#39;./App&#39;</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>import</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>as</span> <span style=color:#a6e22e>serviceWorker</span> <span style=color:#a6e22e>from</span> <span style=color:#e6db74>&#39;./serviceWorker&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>render</span>(<span style=color:#a6e22e>props</span>) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> { <span style=color:#a6e22e>container</span> } <span style=color:#f92672>=</span> <span style=color:#a6e22e>props</span>;
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>ReactDOM</span>.<span style=color:#a6e22e>render</span>(&lt;<span style=color:#f92672>App</span> /&gt;, <span style=color:#a6e22e>container</span> <span style=color:#f92672>?</span> <span style=color:#a6e22e>container</span>.<span style=color:#a6e22e>querySelector</span>(<span style=color:#e6db74>&#39;#root&#39;</span>) <span style=color:#f92672>:</span> document.<span style=color:#a6e22e>querySelector</span>(<span style=color:#e6db74>&#39;#root&#39;</span>));
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e>* 和主应用通讯
</span></span></span><span style=display:flex><span><span style=color:#75715e>*/</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>storeTest</span>(<span style=color:#a6e22e>props</span>) {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>props</span>.<span style=color:#a6e22e>onGlobalStateChange</span>((<span style=color:#a6e22e>value</span>, <span style=color:#a6e22e>prev</span>) =&gt; <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>`[onGlobalStateChange - </span><span style=color:#e6db74>${</span><span style=color:#a6e22e>props</span>.<span style=color:#a6e22e>name</span><span style=color:#e6db74>}</span><span style=color:#e6db74>]:`</span>, <span style=color:#a6e22e>value</span>, <span style=color:#a6e22e>prev</span>), <span style=color:#66d9ef>true</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>props</span>.<span style=color:#a6e22e>setGlobalState</span>({
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ignore</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>props</span>.<span style=color:#a6e22e>name</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>user</span><span style=color:#f92672>:</span> {
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>name</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>props</span>.<span style=color:#a6e22e>name</span>,
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>  });
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>window.<span style=color:#a6e22e>__POWERED_BY_QIANKUN__</span>) {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>render</span>({});
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * bootstrap 只会在微应用初始化的时候调用一次，下次微应用重新进入时会直接调用 mount 钩子，不会再重复触发 bootstrap。
</span></span></span><span style=display:flex><span><span style=color:#75715e> * 通常我们可以在这里做一些全局变量的初始化，比如不会在 unmount 阶段被销毁的应用级别的缓存等。
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>async</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>bootstrap</span>() {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#39;[react16] react app bootstraped&#39;</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * 应用每次进入都会调用 mount 方法，通常我们在这里触发应用的渲染方法
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>async</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>mount</span>(<span style=color:#a6e22e>props</span>) {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#39;[react16] props from main framework&#39;</span>, <span style=color:#a6e22e>props</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>storeTest</span>(<span style=color:#a6e22e>props</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>render</span>(<span style=color:#a6e22e>props</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * 应用每次 切出/卸载 会调用的方法，通常在这里我们会卸载微应用的应用实例
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>async</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>unmount</span>(<span style=color:#a6e22e>props</span>) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> { <span style=color:#a6e22e>container</span> } <span style=color:#f92672>=</span> <span style=color:#a6e22e>props</span>;
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>ReactDOM</span>.<span style=color:#a6e22e>unmountComponentAtNode</span>(<span style=color:#a6e22e>container</span> <span style=color:#f92672>?</span> <span style=color:#a6e22e>container</span>.<span style=color:#a6e22e>querySelector</span>(<span style=color:#e6db74>&#39;#root&#39;</span>) <span style=color:#f92672>:</span> document.<span style=color:#a6e22e>querySelector</span>(<span style=color:#e6db74>&#39;#root&#39;</span>));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h5 id=iii-配置打包工具>iii. 配置打包工具<a hidden class=anchor aria-hidden=true href=#iii-配置打包工具>#</a></h5><p>为了让主应用能正确识别微应用暴露出来的一些全局信息和开发环境下的跨域兼容，在子应用（以create-react-app出来的react项目为例）安装<code>@rescripts/cli</code>，并在子应用目录下新建<code>.rescriptsrc.js</code>，内容如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>const</span> { <span style=color:#a6e22e>name</span> } <span style=color:#f92672>=</span> <span style=color:#a6e22e>require</span>(<span style=color:#e6db74>&#39;./package&#39;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>module</span>.<span style=color:#a6e22e>exports</span> <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>webpack</span><span style=color:#f92672>:</span> (<span style=color:#a6e22e>config</span>) =&gt; {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>config</span>.<span style=color:#a6e22e>output</span>.<span style=color:#a6e22e>library</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>`</span><span style=color:#e6db74>${</span><span style=color:#a6e22e>name</span><span style=color:#e6db74>}</span><span style=color:#e6db74>-[name]`</span>;
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>config</span>.<span style=color:#a6e22e>output</span>.<span style=color:#a6e22e>libraryTarget</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;umd&#39;</span>; <span style=color:#75715e>// 为了能通过window[&#39;app-name1&#39;]拿到子应用声明的生命周期
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// webpack 5 需要把 jsonpFunction 替换成 chunkLoadingGlobal
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>config</span>.<span style=color:#a6e22e>output</span>.<span style=color:#a6e22e>jsonpFunction</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>`webpackJsonp_</span><span style=color:#e6db74>${</span><span style=color:#a6e22e>name</span><span style=color:#e6db74>}</span><span style=color:#e6db74>`</span>; 
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>config</span>.<span style=color:#a6e22e>output</span>.<span style=color:#a6e22e>globalObject</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;window&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>config</span>;
</span></span><span style=display:flex><span>  },
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>devServer</span><span style=color:#f92672>:</span> (<span style=color:#a6e22e>_</span>) =&gt; {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>config</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>_</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>config</span>.<span style=color:#a6e22e>headers</span> <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>      <span style=color:#e6db74>&#39;Access-Control-Allow-Origin&#39;</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;*&#39;</span>,
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>config</span>.<span style=color:#a6e22e>historyApiFallback</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>config</span>.<span style=color:#a6e22e>hot</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>config</span>.<span style=color:#a6e22e>watchContentBase</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>config</span>.<span style=color:#a6e22e>liveReload</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>config</span>;
</span></span><span style=display:flex><span>  },
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h5 id=iv预览-1>iv.预览<a hidden class=anchor aria-hidden=true href=#iv预览-1>#</a></h5><p>使用<code>strictStyleIsolation：true</code>方式进行样式隔离，会生成一个<code>shadow dom</code>，进行样式的完全隔离：</p><img src=https://cdn.jsdelivr.net/gh/lianpf/image-bed@main/blog/2024/20240515-002.webp width=800><p>使用<code>experimentalStyleIsolation：true</code>的方式进行样式隔离，会在css选择器前添加特殊标识：
<img src=https://cdn.jsdelivr.net/gh/lianpf/image-bed@main/blog/2024/20240515-003.webp width=800></p><p>可以看到，<code>qiankun</code>会将子应用的html渲染到自定义的container中。 主应用加载的是子应用的html，在解析子应用的html的过程中遇到js和css会载框架内进行沙盒处理，完成css和js的隔离，之后下载并执行，完成整个子应用的渲染过程。</p><h4 id=3框架优缺点-1>3.框架优缺点<a hidden class=anchor aria-hidden=true href=#3框架优缺点-1>#</a></h4><p><strong>优点</strong></p><ul><li>html entry的接入方式，不需要自己写load方法，而是直接写子应用的访问链接就可以。</li><li>提供js沙箱</li><li>提供样式隔离，两种方式可选</li><li>资源预加载，在浏览器空闲时间预加载未打开的微应用资源，加速微应用打开速度。</li><li>社区活跃</li><li>umi 插件，提供了 @umijs/plugin-qiankun 供 umi 应用一键切换成微前端架构系统 除了最后一点拓展以外，微前端想要达到的效果都已经达到。</li><li>应用间通信简单，全局注入路由保持，浏览器刷新、前进、后退，都可以作用到子应用</li><li>路由保持，浏览器刷新、前进、后退，都可以作用到子应用</li></ul><p><strong>缺点</strong></p><ul><li>改造成本较大，从 webpack、代码、路由等等都要做一系列的适配</li><li>对 eval 的争议，eval函数的安全和性能是有一些争议的：MDN的eval介绍；</li><li>无法同时激活多个子应用，也不支持子应用保活</li><li>无法支持 vite 等 ESM 脚本运行</li></ul><h3 id=框架3-wujie>框架3: wujie<a hidden class=anchor aria-hidden=true href=#框架3-wujie>#</a></h3><p>wujie是腾讯出品。基于 webcomponent 容器 + iframe 沙箱，能够完善的解决适配成本、样式隔离、运行性能、页面白屏、子应用通信、子应用保活、多应用激活、vite 框架支持、应用共享等。目前（2024年4月）github star 3.7k</p><h4 id=1实现方案-2>1.实现方案<a hidden class=anchor aria-hidden=true href=#1实现方案-2>#</a></h4><ul><li>无界利用iframe和webcomponent来搭建天然的js隔离沙箱和css隔离沙箱,</li><li>利用iframe的history和主应用的history在同一个top-level browsing context来搭建天然的路由同步机制</li><li>支持以fiber的形式执行js，由于子应用的执行会阻塞主应用的渲染线程，当fiber设置为true，那么js执行时采取类似react fiber的模式方式间断执行，每个 js 文件的执行都包裹在requestidlecallback中，每执行一个js可以返回响应外部的输入，但是这个颗粒度是js文件，如果子应用单个js文件过大，可以通过拆包的方式降低达到fiber模式效益最大化</li></ul><p><strong>wujie是如何渲染子应用的？</strong><br>wujie跟qiankun一样，都是基于html entry加载的，但他们解析html的过程是不一样的。 qiankun是直接解析并执行js、css、html的，而wujie则是先解析html，提取出script脚本放入空的iframe中，提取出css、html放入到web components中，具体来说：</p><ol><li>解析入口 HTML ，分别得到script、css、模版html</li><li>创建一个纯净的 iframe，为了实现应用间（iframe 间）通讯，无界子应用 iframe 的 url 会设置为主应用的域名（同域），因此 iframe 的 location.href 并不是子应用的 url。创建好后停止加载iframe。</li><li>iframe内插入js，将抽离出来的script脚本，插到iframe中去，在iframe中执行子应用的js</li><li>创建web component，id为子应用id，将抽离出来的html插入。</li><li>由于iframe内的js有可能操作dom，但是iframe内没有dom，随意wujie框架内对iframe拦截document对象，统一将dom指向shadowRoot，此时比如新建元素、弹窗或者冒泡组件就可以正常约束在shadowRoot内部。</li></ol><h4 id=2wujie实战>2.wujie实战<a hidden class=anchor aria-hidden=true href=#2wujie实战>#</a></h4><p>wujie接入很简单，主应用可以让开发者以组件的方式加载子应用。子应用只需要做支持跨域请求改造，这个是所有微前端框架运行的前提，除此之外子应用可以不做任何改造就可以在无界框架中运行，不过此时运行的方式是重建模式。 子应用也可以配置保活、生命周期适配进入保活模式或单例模式。</p><h5 id=i主应用入口文件-2>i.主应用入口文件<a hidden class=anchor aria-hidden=true href=#i主应用入口文件-2>#</a></h5><p>与其他框架一样，先配置子应用</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=display:flex><span><span style=color:#75715e>// main-react/index.js
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>import</span> <span style=color:#e6db74>&#34;react-app-polyfill/stable&#34;</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>import</span> <span style=color:#e6db74>&#34;react-app-polyfill/ie11&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>import</span> <span style=color:#a6e22e>React</span> <span style=color:#a6e22e>from</span> <span style=color:#e6db74>&#34;react&#34;</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>import</span> <span style=color:#a6e22e>ReactDOM</span> <span style=color:#a6e22e>from</span> <span style=color:#e6db74>&#34;react-dom&#34;</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>import</span> <span style=color:#a6e22e>WujieReact</span> <span style=color:#a6e22e>from</span> <span style=color:#e6db74>&#34;wujie-react&#34;</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>import</span> <span style=color:#e6db74>&#34;./index.css&#34;</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>import</span> <span style=color:#a6e22e>App</span> <span style=color:#a6e22e>from</span> <span style=color:#e6db74>&#34;./App&#34;</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>import</span> <span style=color:#a6e22e>hostMap</span> <span style=color:#a6e22e>from</span> <span style=color:#e6db74>&#34;./hostMap&#34;</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>import</span> <span style=color:#a6e22e>credentialsFetch</span> <span style=color:#a6e22e>from</span> <span style=color:#e6db74>&#34;./fetch&#34;</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>import</span> <span style=color:#a6e22e>lifecycles</span> <span style=color:#a6e22e>from</span> <span style=color:#e6db74>&#34;./lifecycle&#34;</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>import</span> <span style=color:#a6e22e>plugins</span> <span style=color:#a6e22e>from</span> <span style=color:#e6db74>&#34;./plugin&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> { <span style=color:#a6e22e>setupApp</span>, <span style=color:#a6e22e>preloadApp</span>, <span style=color:#a6e22e>bus</span> } <span style=color:#f92672>=</span> <span style=color:#a6e22e>WujieReact</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>isProduction</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>process</span>.<span style=color:#a6e22e>env</span>.<span style=color:#a6e22e>NODE_ENV</span> <span style=color:#f92672>===</span> <span style=color:#e6db74>&#34;production&#34;</span>;
</span></span><span style=display:flex><span><span style=color:#a6e22e>bus</span>.<span style=color:#a6e22e>$on</span>(<span style=color:#e6db74>&#34;click&#34;</span>, (<span style=color:#a6e22e>msg</span>) =&gt; window.<span style=color:#a6e22e>alert</span>(<span style=color:#a6e22e>msg</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>degrade</span> <span style=color:#f92672>=</span> window.<span style=color:#a6e22e>localStorage</span>.<span style=color:#a6e22e>getItem</span>(<span style=color:#e6db74>&#34;degrade&#34;</span>) <span style=color:#f92672>===</span> <span style=color:#e6db74>&#34;true&#34;</span> <span style=color:#f92672>||</span> <span style=color:#f92672>!</span>window.Proxy <span style=color:#f92672>||</span> <span style=color:#f92672>!</span>window.<span style=color:#a6e22e>CustomElementRegistry</span>;
</span></span><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * 大部分业务无需设置 attrs
</span></span></span><span style=display:flex><span><span style=color:#75715e> * 此处修正 iframe 的 src，是防止github pages csp报错
</span></span></span><span style=display:flex><span><span style=color:#75715e> * 因为默认是只有 host+port，没有携带路径
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>attrs</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>isProduction</span> <span style=color:#f92672>?</span> { <span style=color:#a6e22e>src</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>hostMap</span>(<span style=color:#e6db74>&#34;//localhost:7700/&#34;</span>) } <span style=color:#f92672>:</span> {};
</span></span><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * 配置应用，主要是设置默认配置
</span></span></span><span style=display:flex><span><span style=color:#75715e> * preloadApp、startApp的配置会基于这个配置做覆盖
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>setupApp</span>({
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>name</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;react16&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>url</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>hostMap</span>(<span style=color:#e6db74>&#34;//localhost:7600/&#34;</span>),
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>attrs</span>, <span style=color:#75715e>// 子应用iframe的src
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>exec</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>true</span>, <span style=color:#75715e>// 预执行
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>fetch</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>credentialsFetch</span>, <span style=color:#75715e>// 自定义的fetch方法
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>plugins</span>,
</span></span><span style=display:flex><span>  <span style=color:#75715e>/** 子应用短路径替换，路由同步时生效 */</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>prefix</span><span style=color:#f92672>:</span> { <span style=color:#e6db74>&#34;prefix-dialog&#34;</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;/dialog&#34;</span>, <span style=color:#e6db74>&#34;prefix-location&#34;</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;/location&#34;</span> },
</span></span><span style=display:flex><span>   <span style=color:#75715e>/** 子应用采用降级iframe方案 */</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>degrade</span>,
</span></span><span style=display:flex><span>  ...<span style=color:#a6e22e>lifecycles</span>,
</span></span><span style=display:flex><span>});
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>setupApp</span>({
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>name</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;vue3&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>url</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>hostMap</span>(<span style=color:#e6db74>&#34;//localhost:7300/&#34;</span>),
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>attrs</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>exec</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>true</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>alive</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>true</span>, <span style=color:#75715e>// 子应用保活，state不会丢失
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>plugins</span><span style=color:#f92672>:</span> [{ <span style=color:#a6e22e>cssExcludes</span><span style=color:#f92672>:</span> [<span style=color:#e6db74>&#34;https://stackpath.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css&#34;</span>] }],
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 引入了的第三方样式不需要添加credentials
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>fetch</span><span style=color:#f92672>:</span> (<span style=color:#a6e22e>url</span>, <span style=color:#a6e22e>options</span>) =&gt;
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>url</span>.<span style=color:#a6e22e>includes</span>(<span style=color:#a6e22e>hostMap</span>(<span style=color:#e6db74>&#34;//localhost:7300/&#34;</span>)) <span style=color:#f92672>?</span> <span style=color:#a6e22e>credentialsFetch</span>(<span style=color:#a6e22e>url</span>, <span style=color:#a6e22e>options</span>) <span style=color:#f92672>:</span> window.<span style=color:#a6e22e>fetch</span>(<span style=color:#a6e22e>url</span>, <span style=color:#a6e22e>options</span>),
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>degrade</span>,
</span></span><span style=display:flex><span>  ...<span style=color:#a6e22e>lifecycles</span>,
</span></span><span style=display:flex><span>});
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (window.<span style=color:#a6e22e>localStorage</span>.<span style=color:#a6e22e>getItem</span>(<span style=color:#e6db74>&#34;preload&#34;</span>) <span style=color:#f92672>!==</span> <span style=color:#e6db74>&#34;false&#34;</span>) {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>preloadApp</span>({
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>name</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;react16&#34;</span>,
</span></span><span style=display:flex><span>  });
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (window.Proxy) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>preloadApp</span>({
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>name</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;vue3&#34;</span>,
</span></span><span style=display:flex><span>    });
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>ReactDOM</span>.<span style=color:#a6e22e>render</span>(&lt;<span style=color:#f92672>App</span> /&gt;, document.<span style=color:#a6e22e>getElementById</span>(<span style=color:#e6db74>&#34;root&#34;</span>));
</span></span></code></pre></div><p>引入子应用的地方直接以组件式的方式引入：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=display:flex><span><span style=color:#66d9ef>import</span> <span style=color:#a6e22e>React</span> <span style=color:#a6e22e>from</span> <span style=color:#e6db74>&#34;react&#34;</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>import</span> <span style=color:#a6e22e>hostMap</span> <span style=color:#a6e22e>from</span> <span style=color:#e6db74>&#34;../hostMap&#34;</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>import</span> <span style=color:#a6e22e>WujieReact</span> <span style=color:#a6e22e>from</span> <span style=color:#e6db74>&#34;wujie-react&#34;</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>import</span> { <span style=color:#a6e22e>useNavigate</span>, <span style=color:#a6e22e>useLocation</span> } <span style=color:#a6e22e>from</span> <span style=color:#e6db74>&#34;react-router-dom&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>default</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>React16</span>() {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>navigation</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>useNavigate</span>();
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>location</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>useLocation</span>();
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>path</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>location</span>.<span style=color:#a6e22e>pathname</span>.<span style=color:#a6e22e>replace</span>(<span style=color:#e6db74>&#34;/react16-sub&#34;</span>, <span style=color:#e6db74>&#34;&#34;</span>).<span style=color:#a6e22e>replace</span>(<span style=color:#e6db74>&#34;/react16&#34;</span>, <span style=color:#e6db74>&#34;&#34;</span>).<span style=color:#a6e22e>replace</span>(<span style=color:#e6db74>&#34;/&#34;</span>,<span style=color:#e6db74>&#34;&#34;</span>); <span style=color:#75715e>////
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>react16Url</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>hostMap</span>(<span style=color:#e6db74>&#34;//localhost:7600/&#34;</span>) <span style=color:#f92672>+</span> <span style=color:#a6e22e>path</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>props</span> <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>jump</span><span style=color:#f92672>:</span> (<span style=color:#a6e22e>name</span>) =&gt; {
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>navigation</span>(<span style=color:#e6db74>`/</span><span style=color:#e6db74>${</span><span style=color:#a6e22e>name</span><span style=color:#e6db74>}</span><span style=color:#e6db74>`</span>);
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>  };
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> (
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 单例模式，name相同则复用一个无界实例，改变url则子应用重新渲染实例到对应路由
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    &lt;<span style=color:#f92672>WujieReact</span>
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>width</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;100%&#34;</span>
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>height</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;100%&#34;</span>
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>name</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;react16&#34;</span>
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>url</span><span style=color:#f92672>=</span>{<span style=color:#a6e22e>react16Url</span>}
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>sync</span><span style=color:#f92672>=</span>{<span style=color:#f92672>!</span><span style=color:#a6e22e>path</span>}
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>props</span><span style=color:#f92672>=</span>{<span style=color:#a6e22e>props</span>}
</span></span><span style=display:flex><span>    &gt;&lt;/<span style=color:#f92672>WujieReact</span>&gt;
</span></span><span style=display:flex><span>  );
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h5 id=ii预览>ii.预览<a hidden class=anchor aria-hidden=true href=#ii预览>#</a></h5><img src=https://cdn.jsdelivr.net/gh/lianpf/image-bed@main/blog/2024/20240515-004.webp width=800><h4 id=2框架优缺点>2.框架优缺点<a hidden class=anchor aria-hidden=true href=#2框架优缺点>#</a></h4><p><strong>优点</strong>：</p><ul><li>接入简单，可以以组件的方式引入子应用</li><li>纯净无污染<ul><li>无界利用iframe和webcomponent来搭建天然的js隔离沙箱和css隔离沙箱</li><li>利用iframe的history和主应用的history在同一个top-level browsing context来搭建天然的路由同步机制</li><li>副作用局限在沙箱内部，子应用切换无需任何清理工作，没有额外的切换成本</li></ul></li><li>支持vite esmoudle加载，由于js是独立在iframe中加载的，所以支持esmodule加载</li><li>支持预加载</li><li>支持应用保活，子应用状态保留，由于是独立在iframe中的，而切换应用时不会移除iframe，所以子应用的状态会被保留在原来的iframe中，当主应用再次渲染子应用dom时，会显示之前的状态。</li><li>多应用同时激活在线</li></ul><p><strong>缺点</strong>：</p><ul><li>iframe沙箱的src设置了主应用的host，初始化iframe的时候需要等待iframe的location.orign从&rsquo;about:blank&rsquo;初始化为主应用的host，这个采用的计时器去等待的不是很优雅。</li></ul><h3 id=框架4-micro-app>框架4: Micro App<a hidden class=anchor aria-hidden=true href=#框架4-micro-app>#</a></h3><p>mirco-app 是京东2021年开源的一款微前端框架。它借助了浏览器对 webComponent 的支持，实现了一套微前端方案体系。并且由于 Shadow Dom 对 react 这类库的兼容性较差，便自己实现了类 Shadow Dom 的效果。与 qiankun 相比，接入更加简单。最新的版本也支持iframe实现js隔离，类似wujie。截至目前（2024年4月）github star 5.2k</p><h4 id=1实现方案-3>1.实现方案<a hidden class=anchor aria-hidden=true href=#1实现方案-3>#</a></h4><p>首先micro-app实现了一个基于WebComponent的组件，并实现了类Shadow Dom 的效果，开发者只需要用<code>&lt;micro-app name="xx" url="xx" baseroute="/xxx/xxx"></code>来加载子应用，整个对子应用的加载、js隔离、css隔离的逻辑都封装在了web component组件<code>&lt;micro-app></code>中，具体来说：</p><ol><li>当调用microApp.start()后，会注册一个名为micro-app 的自定义 webComponent 标签。我们可以从 <code>&lt;micro-app name='app1' url='xx' baseroute='/my-page'>&lt;/micro-app> </code>中拿到子应用的线上入口地址。</li><li><code>&lt;micro-app></code>组件内部，当匹配到路由后，跟qiankun一样加载html，得到html字符串模版</li><li>分析html字符串，提取<code>&lt;head>头和&lt;body></code>，并替换为框架自定义标签<code>&lt;micro-app-head>和&lt;micro-app-body></code></li><li>在<code>&lt;micro-app-head></code>内，会对script标签和link标签的内容进行加载并执行</li><li>将<code>&lt;micro-app-head></code>和<code>&lt;micro-app-body></code>插入到<code>&lt;micro-app></code>标签内</li><li><code>&lt;micro-app></code>内提供了js沙箱方法（v1.0以前跟qiankun沙箱一样），<code>&lt;micro-app-head></code>挂载到<code>&lt;micro-app></code>后，内部会逐一对<code>&lt;micro-app-head></code>内的script标签的js绑定作用域，实现js隔离。</li></ol><p><strong>css隔离方案</strong>
默认使用正则将CSS字符串切割成最小单元，每个单元包含一段CSS信息，将所有的信息整理生成CSSTree，遍历CSSTree的每个规则，添加前缀实现样式隔离。</p><img src=https://cdn.jsdelivr.net/gh/lianpf/image-bed@main/blog/2024/20240515-005.webp width=800><p><strong>js隔离方案</strong>
micro-app有两种方式实现js隔离，默认是跟qiankun一样采用proxy沙箱的方式隔离， 在v1.0发布后支持了基于原生iframe的隔离方式。</p><h4 id=2micro-app实战>2.Micro App实战<a hidden class=anchor aria-hidden=true href=#2micro-app实战>#</a></h4><h5 id=i主应用入口文件-3>i.主应用入口文件<a hidden class=anchor aria-hidden=true href=#i主应用入口文件-3>#</a></h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=display:flex><span><span style=color:#66d9ef>import</span> <span style=color:#a6e22e>React</span> <span style=color:#a6e22e>from</span> <span style=color:#e6db74>&#39;react&#39;</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>import</span> <span style=color:#a6e22e>ReactDOM</span> <span style=color:#a6e22e>from</span> <span style=color:#e6db74>&#39;react-dom&#39;</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>import</span> <span style=color:#e6db74>&#39;./index.css&#39;</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>import</span> <span style=color:#a6e22e>Router</span> <span style=color:#a6e22e>from</span> <span style=color:#e6db74>&#39;./router&#39;</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>import</span> <span style=color:#a6e22e>microApp</span> <span style=color:#a6e22e>from</span> <span style=color:#e6db74>&#39;@micro-zoe/micro-app&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>microApp</span>.<span style=color:#a6e22e>start</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>ReactDOM</span>.<span style=color:#a6e22e>render</span>(
</span></span><span style=display:flex><span>  &lt;<span style=color:#f92672>React.StrictMode</span>&gt;
</span></span><span style=display:flex><span>    &lt;<span style=color:#f92672>Router</span> /&gt;
</span></span><span style=display:flex><span>  &lt;/<span style=color:#f92672>React.StrictMode</span>&gt;,
</span></span><span style=display:flex><span>  document.<span style=color:#a6e22e>getElementById</span>(<span style=color:#e6db74>&#39;root&#39;</span>)
</span></span><span style=display:flex><span>);
</span></span></code></pre></div><p><strong>调用子应用</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=display:flex><span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>MyPage</span> () {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> (
</span></span><span style=display:flex><span>    &lt;<span style=color:#f92672>div</span>&gt;
</span></span><span style=display:flex><span>      &lt;<span style=color:#f92672>h1</span>&gt;<span style=color:#a6e22e>子应用</span><span style=color:#960050;background-color:#1e0010>👇</span>&lt;/<span style=color:#f92672>h1</span>&gt;
</span></span><span style=display:flex><span>      <span style=color:#75715e>// name：应用名称, url：应用地址
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      &lt;<span style=color:#f92672>micro</span><span style=color:#960050;background-color:#1e0010>-</span><span style=color:#a6e22e>app</span> <span style=color:#a6e22e>name</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#39;my-app&#39;</span> <span style=color:#a6e22e>url</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#39;http://localhost:3000/&#39;</span>&gt;<span style=color:#f92672>&lt;</span><span style=color:#960050;background-color:#1e0010>/micro-app&gt;</span>
</span></span><span style=display:flex><span>    &lt;/<span style=color:#f92672>div</span>&gt;
</span></span><span style=display:flex><span>  )
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h5 id=ii预览-1>ii.预览<a hidden class=anchor aria-hidden=true href=#ii预览-1>#</a></h5><img src=https://cdn.jsdelivr.net/gh/lianpf/image-bed@main/blog/2024/20240515-006.webp width=800><h4 id=2框架优缺点-1>2.框架优缺点<a hidden class=anchor aria-hidden=true href=#2框架优缺点-1>#</a></h4><p><strong>优点</strong></p><ul><li>接入简单，组件式引入子应用</li><li>团队持续更新维护</li><li>js隔离、css隔离、路由同步</li><li>支持子应用保活, 需要开启keep-alive模式</li><li>支持fiber模式，提升主应用的渲染性能。</li></ul><p><strong>缺点</strong></p><ul><li>1.0之前不支持vite，1.0之后支持了</li><li>默认css隔离方式，主应用的样式还是会污染到子应用。</li><li>子应用和主应用必须相同的路由模式，要么同时hash模式，要么同时history模式</li><li>依赖于CustomElements和Proxy两个较新的API。Proxy暂时没有做兼容，所以对于不支持Proxy的浏览器无法运行micro-app。</li></ul><hr><h2 id=参考>参考<a hidden class=anchor aria-hidden=true href=#参考>#</a></h2><ul><li><a href=https://mp.weixin.qq.com/s/997pVVxdgpOH6ZsDsFAh2g>探探各个微前端框架 | 奇舞精选</a></li></ul><hr><p><strong>最后， 希望大家早日实现：成为编程高手的伟大梦想！</strong><br><strong>欢迎交流~</strong></p><img src=/img-common/weChatPublic.jpg alt=微信公众号 width=600 height=286><p><strong>本文版权归原作者曜灵所有！未经允许，严禁转载！对非法转载者, 原作者保留采用法律手段追究的权利！</strong><br><strong>若需转载，请联系微信公众号：连先生有猫病，可获取作者联系方式！</strong></p></div><footer class=post-footer><nav class=paginav><a class=next href=https://lianpf.github.io/posts/frontend-develop/ts-codefragment/><span class=title>下一页 »</span><br><span>常见问题&代码片段: TS</span></a></nav></footer></div><script src=https://utteranc.es/client.js repo=lianpf/lianpf.github.io issue-term=title label=comments theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>Copyright
&copy;
2016-2024
<a href=https://lianpf.github.io/ style=color:#939393>曜灵（SUN）Site</a>.
基于 Hugo 引擎和 PaperMod 主题</span>
<a href=https://beian.miit.gov.cn/ target=_blank style=color:#939393></a>&nbsp;</footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><span class=topInner><svg class="topSvg" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg><span id=read_progress></span></span></a>
<script>document.addEventListener("scroll",function(){const t=document.getElementById("read_progress"),n=document.documentElement.scrollHeight,s=document.documentElement.clientHeight,o=document.documentElement.scrollTop||document.body.scrollTop;t.innerText=((o/(n-s)).toFixed(2)*100).toFixed(0)})</script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>let mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>200||document.documentElement.scrollTop>200?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{(function(){document.cookie="change-themes="+escape("false")})(),document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.body.addEventListener("copy",function(e){if(window.getSelection().toString()&&window.getSelection().toString().length>50){let t=e.clipboardData||window.clipboardData;if(t){e.preventDefault();let n=window.getSelection().toString()+`

————————————————
版权声明：本文为「曜灵（SUN）Site」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：`+location.href,s=window.getSelection().toString()+`

————————————————
版权声明：本文为「曜灵（SUN）Site」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：`+location.href;t.setData("text/html",n),t.setData("text/plain",s)}}})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const s=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="复制";function i(){t.innerText="已复制！",setTimeout(()=>{t.innerText="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){let t=e.textContent+`
————————————————
版权声明：本文为「曜灵（SUN）Site」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：`+location.href;navigator.clipboard.writeText(t),i();return}const n=document.createRange();n.selectNodeContents(e);const s=window.getSelection();s.removeAllRanges(),s.addRange(n);try{document.execCommand("copy"),i()}catch{}s.removeRange(n)});let l=e.className.replaceAll("language-",""),n=document.createElement("div"),a=document.createElement("div"),r=document.createElement("div"),c=document.createElement("div"),o=document.createElement("div");o.innerText=l,n.setAttribute("class","mac-tool"),a.setAttribute("class","mac bb1"),r.setAttribute("class","mac bb2"),c.setAttribute("class","mac bb3"),o.setAttribute("class","language-type"),n.appendChild(a),n.appendChild(r),n.appendChild(c),n.appendChild(o),s.classList.contains("highlight")?(s.appendChild(t),s.appendChild(n)):s.parentNode.firstChild==s||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?(e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t),s.appendChild(n)):(e.parentNode.appendChild(t),s.appendChild(n)))})</script></body></html>