<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>vue3+ts(2)：TypeScript 语法汇总 | 曜灵（SUN）Site</title><meta name=keywords content="TS"><meta name=description content="本文是vue3+ts项目系列第2篇《TypeScript 语法汇总》，关于TypeScript的基础语法，你了解&mldr;"><meta name=author content="曜灵"><link rel=canonical href=https://lianpf.github.io/posts/frontend-develop/03.ts-basic-grammar/><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.js onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://lianpf.github.io/img-common/favicon.png><link rel=icon type=image/png sizes=16x16 href=https://lianpf.github.io/img-common/favicon.png><link rel=icon type=image/png sizes=32x32 href=https://lianpf.github.io/img-common/favicon.png><link rel=apple-touch-icon href=https://lianpf.github.io/img-common/avatar.jpeg><link rel=mask-icon href=https://lianpf.github.io/img-common/avatar.jpeg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css><script src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script>
<script src=https://cdn.jsdelivr.net/npm/jquery@3.6.3/dist/jquery.min.js></script>
<script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script><meta property="og:title" content="vue3+ts(2)：TypeScript 语法汇总"><meta property="og:description" content="本文是vue3+ts项目系列第2篇《TypeScript 语法汇总》，关于TypeScript的基础语法，你了解&mldr;"><meta property="og:type" content="article"><meta property="og:url" content="https://lianpf.github.io/posts/frontend-develop/03.ts-basic-grammar/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-03-13T17:59:58+08:00"><meta property="article:modified_time" content="2021-03-13T17:59:58+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="vue3+ts(2)：TypeScript 语法汇总"><meta name=twitter:description content="本文是vue3+ts项目系列第2篇《TypeScript 语法汇总》，关于TypeScript的基础语法，你了解&mldr;"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"📚文章","item":"https://lianpf.github.io/posts/"},{"@type":"ListItem","position":2,"name":"👨🏻‍💻 前端","item":"https://lianpf.github.io/posts/frontend-develop/"},{"@type":"ListItem","position":3,"name":"vue3+ts(2)：TypeScript 语法汇总","item":"https://lianpf.github.io/posts/frontend-develop/03.ts-basic-grammar/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"vue3+ts(2)：TypeScript 语法汇总","name":"vue3\u002bts(2)：TypeScript 语法汇总","description":"本文是vue3+ts项目系列第2篇《TypeScript 语法汇总》，关于TypeScript的基础语法，你了解\u0026hellip;\n","keywords":["TS"],"articleBody":"本文是vue3+ts项目系列第2篇《TypeScript 语法汇总》，关于TypeScript的基础语法，你了解…\n一、背景 在 react 和 vue 社区中也越来越多人开始使用TypeScript，使用 TS 可以增加代码的可读性和可维护性。从发布的 Vue3 正式版本来看， Vue3 的源码是用 TS 编写的，更好的 TypeScript 支持也是这次升级的一大亮点。当然，在实际开发中如何正确拥抱 TS 以及如何迁移到 Vue3 也是项目中我们不得不面对的问题，这里针对 Vue3 和 TS单独做了一个系列和大家做一下交流，本篇是 vue3+ts项目系列第2篇《TypeScript 语法汇总》。\n本系列其他内容如下:\nvue3+ts项目系列第1篇《vue3项目从0到1搭建》 vue3+ts项目系列第2篇《TypeScript 语法汇总》 vue3+ts项目系列第3篇《vue3组合式api及重要属性变更》 二、前言 1、静态类型、动态类型、强类型、弱类型 编译时就知道变量类型的是静态类型，运行时才知道一个变量类型的叫做动态类型。 java 是静态类型， js 是动态类型。\n不允许隐式转换的是强类型，允许隐式转换的是弱类型。 java 是强类型， js 是弱类型。\n那ts到底是什么类型的语言，很明显， ts 是静态类型语言，因为它需要经过编译。但是 ts不是强类型，因为它可以允许隐式类型转换。\nlet isBool: boolean let num: number = 10 isBool = !num // ok 2、Typescript是什么 ECMAScript 的超集 (stage 3) 编译期的类型检查 不引入额外开销(零依赖，不扩展 js 语法，不侵入运行时) 编译出通用的、易读的 js 代码 Typescript = Type + ECMAScript + Babel-Lite\nTypescript 设计目标: 链接\n3、为什么使用 Typescript 增加了代码的可读性和可维护性 减少运行时错误，写出的代码更加安全，减少 BUG 享受到代码提示带来的快感 重构神器 三、类型 1、基础类型 声明了变量的类型，那么这个变量就有了静态类型的特性，ts中使用:操作符来声明类型:\nboolean number string array tuple（元组） enum（枚举） any \u0026 unknown void null \u0026 undefined never Object 声明变量的类型:\nlet bool: boolean = false // boolean 类型 let num: number = 12 // number 类型 let str: string = 'hello world' // string类型 let numArr: number[] = [1, 2, 3] // number数组类型 let numArr: Array = [1, 2, 3] // 数组泛型形式：number数组类型 let unknow: any = 4 // any类型，即任一类型 unknow = \"maybe a string instead\" unknow = false 1.1 枚举（enum） 数字枚举 字符串枚举 常量枚举 很多编程语言都有枚举的概念，枚举就是一组常量的集合，但是和集合不同，枚举可以通过变量的值来得到变量，它是一个双向的过程:\nenum Direction { UP, DOWN, LEFT, RIGHT } Direction.UP // 0 Direction[0] // 'UP' 数字枚举 上例中的 Direction 就是一个数字枚举，默认的，第一个变量的值是0，后面的值会在前一个值上 +1 ，所以 DOWN 的值为1， LEFT 的值为2，以此类推。 如果想改变枚举的初始值，只需要给第一个变量赋值即可:\nenum Direction { UP = 1, DOWN, LEFT, RIGHT } 字符串枚举 字符串枚举的概念很简单， 在一个字符串枚举里，每个成员都必须初始化:\n如果某个成员没有被初始化，则会报错\nenum Direction { UP = 'UP', DOWN = 'DOWN', LEFT = 'LEFT', RIGHT = 'RIGHT', MIDDLE //error 枚举成员必须具有初始化表达式 } 常量枚举 可以用 const 修饰符来声明枚举，这时候编译后的js代码将不会出现额外的声明代码:\nenum Direction { UP, DOWN, LEFT, RIGHT } const enum Seasons { SPRING = 'SPRING', SUMMER = 'SUMMER', AUTUMN = 'AUTUMN', WINTER = 'WINTER' } const up = Direction.UP const spring = Seasons.SPRING 生成的js:\nvar Direction; (function (Direction) { Direction[Direction[\"UP\"] = 0] = \"UP\"; Direction[Direction[\"DOWN\"] = 1] = \"DOWN\"; Direction[Direction[\"LEFT\"] = 2] = \"LEFT\"; Direction[Direction[\"RIGHT\"] = 3] = \"RIGHT\"; })(Direction || (Direction = {})); var up = Direction.UP; var spring = \"SPRING\" /* SPRING */; 1.2 any 和 unknown 的区别 any : 任意类型 unknown : 未知的类型 任何类型都能分配给 unknown ，但 unknown 不能分配给其他基本类型，而 any 啥都能分配和被分配\nunknown Demo:\nlet foo: unknown foo = true // ok foo = 123 //ok foo.toFixed(2) // error let foo1: string = foo // error any Demo:\nlet bar: any bar = true // ok bar = 123 //ok foo.toFixed(2) // ok let bar1:string = bar // ok 如上，用了 any 就相当于完全丢失了类型检查，所以尽量少用 any ，对于未知类型可以用 unknown\nunknown 的正确用法 可以通过不同的方式将 unknown 类型缩小为更具体的类型范围:\nfunction getLen(value: unknown): number { if (typeof value === 'string') { // 因为类型保护的原因，此处 value 被判断为 string 类型 return value.length } return 0 } 这个过程叫类型收窄(type narrowing)\n1.3 never never 类型表示的是那些永不存在的值的类型。 never类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型；变量也可能是 never类型，当它们被永不为真的类型保护所约束时。\nnever 类型是任何类型的子类型，也可以赋值给任何类型 没有类型是never的子类型或可以赋值给never类型（除了never本身之外），即使 any也不可以赋值给never\n在最新的 typescript 3.7 中，下面代码会报错:\n// never 用户控制流分析 function neverReach (): never { throw new Error('an error') } const x = neverReach() x.toFixed(2) // x is unreachable never 还可以用于联合类型的幺元:\ntype T0 = string | number | never // T0 is string | number 2、高级类型 2.1 联合类型与交叉类型 联合类型(union type)表示多种类型的 “或” 关系\nfunction genLen(x: string | any[]) { return x.length } genLen('') // ok genLen([]) // ok genLen(1) // error 交叉类型表示多种类型的 “与” 关系\ninterface Person { name: string age: number } interface Animal { name: string color: string } const x: Person \u0026 Animal = { name: 'x', age: 1, color: 'red } 使用联合类型表示枚举\ntype Position = 'UP' | 'DOWN' | 'LEFT' | 'RIGHT' const position: Position = 'UP' // 具值联合类型 // type 关键词可以声明一个类型 type positionType = 'top' | 'center' | 'bottom' let position: positionType = 'top' // ok position = 'left' // error 不能将类型“\"left\"”分配给类型“positionType” position = 'bottom' // ok // 数组联合类型 let arr: (number | string)[] = [] arr.push(1) // ok arr.push('hello') // ok arr.push(true) // error 类型“true”的参数不能赋给类型“string | number”的参数。 可以避免使用 enum 侵入了运行时。\n2.2 类型保护和类型断言 ts 初学者很容易写出下面的代码:\nfunction isString (value) { return Object.prototype.toString.call(value) === '[object String]' } function fn (x: string | number) { if (isString(x)) { return x.length // error 类型“string | number”上不存在属性“length”。 } else { // ..... } } 如何让 ts 推断出来 x 是 string 类型呢?\n2.2.1 使用ts的 is 关键词 function isString (value: unknown): value is string { return Object.prototype.toString.call(value) === '[object String]' } function fn (x: string | number) { if (isString(x)) { return x.length } else { // ..... } } 2.2.2 类型保护 (1) js typeof 关键词 typeof 关系词可以从实现 推出类型，这是一个类型关键词\nfunction getLen(x: string | any[]) { return x.length } type GetLen = typeof getLen function callback(fn: GetLen) { fn(1) // 类型“1”的参数不能赋给类型“string | any[]”的参数 } (2) js instanceof 关键词 在 ts 中，instanceof 关键词能够帮助 ts 判断出构造函数的类型:\nfunction fn1 (x: XMLHttpRequest | string) { if (x instanceof XMLHttpRequest) { // x is XMLHttpRequest return x.getAllResponseHeaders() } else { // x is string return x.length } } (3) 针对 null 和 undefined 的类型保护 在条件判断中，ts 会自动对 null 和 undefined 进行类型保护:\nfunction fn2 (x?: string) { if (x) { return x.length } } 2.2.3 类型断言 (1) 针对 null 和 undefined 的类型断言 如果我们已经知道的参数不为空，可以使用!来手动标记:\nfunction fn2 (x?: string) { return x!.length } 2.3 索引类型（Index types） keyof in [] (1) keyof keyof 也是一个 类型关键词 ，可以用来取得一个对象接口的所有 key 值:\ninterface Person { name: string age: number } type PersonAttrs = keyof Person // 'name' | 'age' (2) in in 也是一个 类型关键词 ，可以对 联合类型 进行遍历，只可以用在 type 关键词下面。\ntype Person = { [key in 'name' | 'age']: number } // ===\u003e type Person = { name: number; age: number; } (3) [] 使用 [] 操作符可以进行索引访问，也是一个 类型关键词\ninterface Person { name: string age: number } type x = Person['name'] // x is string 示例 写一个类型复制的类型工具:\ntype Copy = { [key in keyof T]: T[key] } interface Person { name: string age: number } type Person1 = Copy 3、类型推断 ts 中的类型推断是非常强大，而且其内部实现也是非常复杂的。\n基本类型推断:\n// ts 推导出 x 是 number 类型 let x = 10 对象类型推断:\n// ts 推断出 myObj 的类型: myObj: { x: number; y: string; z: boolean; const myObj = { x:1, y: '2', z: true } 函数类型推断:\n// ts 推导出函数返回值是 number 类型 function len (str: string) { return str.length } 上下文类型推断:\n// ts 推导出 event 是 ProgressEvent 类型 const xhr = new XMLHttpRequest() xhr.onload = function (event) {} 写 ts 代码的时候，对于基本类型我们可以不用手动声明其类型，让 ts 自己去推断\n知乎 - typescript上下文相关类型浅析 https://zhuanlan.zhihu.com/p/84481228\n4、类型兼容性 typescript 的子类型是基于 结构子类型 的，只要结构可以兼容，就是子类型。(Duck Type)\nclass Point { x: number } function getPointX(point: Point) { return point.x } class Point2 { x: number } let point2 = new Point2() getPointX(point2) // OK java 、 c++ 等传统静态类型语言是基于 名义子类型 的，必须显示声明子类型关系(继承)，才可以兼容。\npublic class Main { public static void main (String[] args) { getPointX(new Point()); // ok getPointX(new ChildPoint()); // ok getPointX(new Point1()); // error } public static void getPointX (Point point) { System.out.println(point.x); } static class Point { public int x = 1; } static class Point2 { public int x = 2; } static class ChildPoint extends Point { public int x = 3; } } 4.1 对象子类型 子类型中必须包含源类型所有的属性和方法:\nfunction getPointX(point: { x: number }) { return point.x } const point = { x: 1, y: '2' } getPointX(point) // OK 注意，如果直接传入一个对象字面量是会报错的:\nfunction getPointX(point: { x: number }) { return point.x } getPointX({ x: 1, y: '2' }) // error 这是 ts 中的另一个特性，叫做: excess property check ，当传入的参数是一个对象字面量时，会进行额外属性检查。\n4.2 协变与逆变 介绍类型兼容和类型安全就非常有必要介绍一下逆变与协变的概念:\n在介绍之前，先约定如下标记:\nA ≼ B 表示A是B的子类型，A包含B的所有属性和方法。 A =\u003e B 表示以 A 为参数，B 为返回值的方法。 (param: A) =\u003e B 一个问题 如果我现在有三个类型 Animal 、 Dog 、 WangCai(旺财) ，那么肯定存在下面的关系: WangCai ≼ Dog ≼ Animal 即 旺财属于狗属于动物。\n问题:以下哪种类型是 Dog =\u003e Dog 的子类呢?\nWangCai =\u003e WangCai WangCai =\u003e Animal Animal =\u003e Animal Animal =\u003e WangCai 从代码来看 class Animal { sleep: Function } class Dog extends Animal { // 吠 bark: Function } class WangCai extends Dog { dance: Function } type DogCbFn = (dog: Dog) =\u003e Dog function getDogName (cb: DogCbFn) { const dog = new Dog() const myDog = cb(dog) myDog.bark() } const animal = new Animal() const wangcai = new WangCai() getDogName(wangcai =\u003e { wangcai.dance() return wangcai }) // error getDogName(wangcai =\u003e { wangcai.dance() return animal }) // error getDogName(animal =\u003e { animal.sleep() return wangcai }) // ok getDogName(animal =\u003e { animal.sleep() return animal }) // error 可以看到只有 Animal =\u003e WangCai 才是 Dog =\u003e Dog 的子类型，可以得到一个结论，对于函数类型来说，函数参数的类型兼容是反向的，我们称之为 逆变 ，返回值的类型兼容是正向的，称之为 协变 。\n(1) 函数子类型 上面逆变与协变的例子介绍了函数参数只有一个时的情况，如果函数参数有多个时该如何区分?\n其实函数的参数可以转化为 Tuple 的类型兼容性:\ntype Tuple1 = [string, number] type Tuple2 = [string, number, boolean] let tuple1: Tuple1 = ['1', 1] let tuple2: Tuple2 = ['1', 1, true] let t1: Tuple1 = tuple2 // ok let t2: Tuple2 = tuple1 // error 可以看到 Tuple2 =\u003e Tuple1 ，即长度大的是长度小的子类型，再由于函数参数的逆变特性，所以函数参数少的可以赋值给参数多的(参数从前往后需一一对应):\n[1, 2].forEach((item, index) =\u003e { console.log(item) }) // ok [1, 2].forEach((item, index, arr, other) =\u003e { console.log(other) }) // error 四、接口 写过java的同学应该都知道接口的概念，java中的接口是用来描述类的功能的\ninterface BabyInter { void cry(); } class Baby implements BabyInter { @Override public void cry() { System.out.print(\"crying\") } } 但是ts里面的接口还是有一点不一样的，同样是用来描述数据的结构，ts的接口不仅可以描述类，还可以描述变量，描述方法, 使用interface关键词来声明接口:\ninterface BabyInter { name: string, cry () : void } let baby: BabyInter = { name: 'apple', cry () : void { console.log(this.name + 'is crying') } } let getBaby = () : BabyInter =\u003e { return { name: 'apple', cry () {} } } 1、可选属性 接口里的属性不全都是必需的，可以是可选的。\ninterface FontStyleOptions { size: number; color?: string; } const getFontStyle = (options: FontStyleOptions) =\u003e { options.color = options.color || '#000000' return options } const fontStyle = getFontStyle({ size: 16 }) 可选属性的好处之一是可以对可能存在的属性进行预定义，好处之二是在引用了不存在的属性时可以捕获错误。\n2、可索引的类型 额外的属性检查 如果FontStyleOptions接口中除了有size属性，还有一些不确定的其它属性，那么可以这样定义它:\ninterface FontStyleOptions { size: number; [prop: string]: number; } let obj: FontStyleOptions = { size: 16, border: 1 } obj.height = 18 // ok obj.background = '#ffffff' // error 不能将类型“\"#ffffff\"”分配给类型“number” 要注意的是，对于可索引的类型来说，索引签名的参数类型必须为 “string” 或 “number”:\ninterface FontStyleOptions { size: number; [prop: boolean]: string; // error } 这也很容易理解，因为对象的键值要么是字符串要么是数字。 还要注意的是，索引的类型必须是其他属性的联合类型:\ninterface FontStyleOptions { size: number; // error 类型“number”的属性“size”不能赋给字符串索引类型“string” [prop: string]: string; } interface FontStyleOptions { size: number; [prop: string]: string | number; // ok } 五、类 1、继承 class Animal { name: string; constructor(theName: string) { this.name = theName; } move(distanceInMeters: number = 0) { console.log(`${this.name} moved ${distanceInMeters}m.`); } } class Snake extends Animal { constructor(name: string) { super(name); } move(distanceInMeters = 5) { console.log(\"Slithering...\"); super.move(distanceInMeters); } } class Horse extends Animal { constructor(name: string) { super(name); } move(distanceInMeters = 45) { console.log(\"Galloping...\"); super.move(distanceInMeters); } } let sam = new Snake(\"Sammy the Python\"); let tom: Animal = new Horse(\"Tommy the Palomino\"); sam.move(); tom.move(34); 输出\nSlithering... Sammy the Python moved 5m. Galloping... Tommy the Palomino moved 34m. 关键点\n使用extends关键字创建了Animal的两个子类： Horse和 Snake 派生类包含了一个构造函数，它必须调用 super()，它会执行基类的构造函数。 而且，在构造函数里访问 this的属性之前，一定要调用 super() 重写从 Animal继承来的 move方法，使得 move方法根据不同的类而具有不同的功能 ts中的类和es6的类没有什么太大的区别，主要是增加了类成员和方法的修饰符(private, protected, public)和对接口的实现。\n2、修饰符 public 修饰符: 类成员和方法能在该类和该类的子类中被使用，也能在外部被使用。TypeScript里，成员都默认为 public private 修饰符: 类成员和方法只能在该类中被使用，不能在外部被使用。 protected 修饰符: 类成员和方法只能在该类和该类的子类中被使用，不能在外部被使用。 readonly关键字将属性设置为只读的，只读属性必须在声明时或构造函数里被初始化 class Person { private age: number protected name: string constructor (name: string, age: number) { this.name = name this.age = age } } class Student extends Person { constructor (name: string, age: number) { super(name, age) } learn () :void { console.log(this.name + 'is learning') // ok console.log(this.age) // error } } let student = new Student('Lucy', 18) student.name // error 注意 如果其中一个类型里包含一个 private成员，那么只有当另外一个类型中也存在这样一个 private成员， 并且它们都是来自同一处声明时，我们才认为这两个类型是兼容的。 对于 protected成员也使用这个规则\n3、存取器 通过getters/setters来截取对对象成员的访问。 它能帮助你有效的控制对对象成员的访问\nlet passcode = \"secret passcode\"; class Employee { private _fullName: string; get fullName(): string { return this._fullName; } set fullName(newName: string) { if (passcode \u0026\u0026 passcode == \"secret passcode\") { this._fullName = newName; } else { console.log(\"Error: Unauthorized update of employee!\"); } } } let employee = new Employee(); employee.fullName = \"Bob Smith\"; if (employee.fullName) { alert(employee.fullName); } 注意\n存取器要求将编译器设置为输出ECMAScript 5或更高。 不支持降级到ECMAScript 3 只带有 get不带有 set的存取器自动被推断为 readonly（这在从代码生成 .d.ts文件时是有帮助的，因为利用这个属性的用户会看到不允许够改变它的值） 4、静态属性 前面讨论了类的实例成员，那些仅当类被实例化的时候才会被初始化的属性。 我们也可以使用static关键词创建类的静态成员，这些属性存在于类本身上面而不是类的实例上\nclass Grid { static origin = {x: 0, y: 0}; calculateDistanceFromOrigin(point: {x: number; y: number;}) { let xDist = (point.x - Grid.origin.x); let yDist = (point.y - Grid.origin.y); return Math.sqrt(xDist * xDist + yDist * yDist) / this.scale; } constructor (public scale: number) { } } let grid1 = new Grid(1.0); // 1x scale let grid2 = new Grid(5.0); // 5x scale console.log(grid1.calculateDistanceFromOrigin({x: 10, y: 10})); console.log(grid2.calculateDistanceFromOrigin({x: 10, y: 10})); 5、抽象类 抽象类做为其它派生类的基类使用。一般不会直接被实例化 不同于接口，抽象类可以包含成员的实现细节 abstract关键字是用于定义抽象类和在抽象类内部定义抽象方法 抽象类中的抽象方法不包含具体实现并且必须在派生类中实现 abstract class Department { constructor(public name: string) { } printName(): void { console.log('Department name: ' + this.name); } abstract printMeeting(): void; // 必须在派生类中实现 } class AccountingDepartment extends Department { constructor() { super('Accounting and Auditing'); // 在派生类的构造函数中必须调用 super() } printMeeting(): void { console.log('The Accounting Department meets each Monday at 10am.'); } generateReports(): void { console.log('Generating accounting reports...'); } } let department: AccountingDepartment = new AccountingDepartment(); // 允许对一个抽象子类进行实例化和赋值 department.printName(); department.printMeeting(); let department2: Department; // 允许创建一个对抽象类型的引用 department2 = new Department(); // 错误: 不能创建一个抽象类的实例 department2.generateReports(); // 错误: 方法在声明的抽象类中不存在 6、类和接口 ts中类可以使用关键词implements来实现接口:\ninterface BabyInter { name: string cry () : void } class Baby implements BabyInter { name: string constructor (name: string) { this.name = name } cry () :void { console.log(this.name + 'is crying') } } 如果 Baby 类中没有声明 cry 方法会怎样:\ninterface BabyInter { name: string cry () : void } class Baby implements BabyInter { name: string constructor (name: string) { this.name = name } } 会报一个编译错误: [ts] 类“Baby”错误实现接口“BabyInter”。类型“Baby”中缺少属性“cry”。\n六、函数 1、函数类型 (1) 几种函数类型的返回值类型写法 记住在 () 后面添加返回值类型即可\nfunction fn(): number { return 1 } const fn = function (): number { return 1 } const fn = (): number =\u003e { return 1 } const obj = { fn (): number { return 1 } } (2) 函数类型 ts 中也有函数类型，用来描述一个函数:\ntype FnType = (x: number, y: number) =\u003e number 完整的函数写法\nlet myAdd: (x: number, y: number) =\u003e number = function(x: number, y: number): number { return x + y } // 使用 FnType let myAdd: FnType = function(x: number, y: number): number { return x + y } // ts 自动推导参数类型 let myAdd: FnType = function(x, y) { return x + y } 2、函数重载? js因为是动态类型，本身不需要支持重载，ts为了保证类型安全，支持了函数签名的类型重载。即:\n多个 重载签名 和一个 实现签名\nfunction len(s: string): string; function len(arr: any[]): number; function len(x: string | any[]) { if (typeof x === 'string') { return x.length.toString() } return x.length } let a = len('').trim() // error let b = len([]).toFixed(2) // ok let c = len(2) // error ts 函数重载的其他特性:\n如果定义了 重载签名 ，则 实现签名 对外不可见 实现签名 必须兼容 重载签名 重载签名 的类型不会合并 TS 中的函数重载其实并不是真的重载。\n七、泛型 1、什么是泛型 软件工程中，我们不仅要创建一致的定义良好的API，同时也要考虑代码块的重用性。 组件不仅能够支持当前的数据类型，同时也能支持未来的数据类型。\n通过字面意思来看，泛型有“广泛的类型”之意，即数据的类型也可以通过一个变量来动态确定，一般用 \u003c\u003e 操作符来声明泛型的使用。\n小试牛刀 // 泛型方法\nfunction createList(): T[] { return [] as T[] } const numberList = createList() // number[] const stringList = createList() // string[] 2、泛型接口 interface GenericIdentityFn { (arg: T): T; } function identity(arg: T): T { return arg; } let myIdentity: GenericIdentityFn = identity; 3、泛型类 // 泛型类的定义 class ArrayList { list: T[] push (item: T) :void { this.list.push(item) } pop () :T { return this.list.pop() } } // 泛型类的使用 const list = new ArrayList() list.push('hello') // ok list.push(1) //error 小知识:K，V，T，E等泛型名称不是固定写死了，是可以随意定义的，为了语义化，是有特殊含义的:\nT表示 type 类型。 K、V:分别代表键值中的 Key、Value。 E:表示 enum 枚举。 4、泛型约束 如果我们只希望 createList 函数只能生成指定的类型数组，该如何做，可以使用 extends 关键词来约束泛型的范围和形状。\n此时 extends 约束的是输入值\ninterface Lengthwise { length: number } function createList(): T[] { return [] as T[] } const numberList = createList() // ok const arrayList = createList() // ok const stringList = createList() // error console.log(numberList) // [] console.log(arrayList) // [] 4.1 条件控制 extends 除了做约束类型，还可以做条件控制，相当于与一个三元运算符，只不过是针对类型的。\nT extends U ? X : Y 如果 T 可以被分配给 U，则返回 X，否则返回 Y。\ntype IsNumber = T extends number ? true : false type x = IsNumber // false 4.2 类型映射 类型映射相当与一个类型的函数，可以做一些类型运算，输入一个类型，输出另一个类型，前文我们举了个 Copy 的例子。\n(1) 内置的映射类型 // 每一个属性都变成可选 type Partial = { [P in keyof T]?: T[P] } // 每一个属性都变成可选 type Readonly = { readonly [P in keyof T]: T[P] } // 选则对象中的某些属性 type Pick = { [P in K]: T[P]; } // ...... typescript 2.8 在 lib.d.ts 中内置了几个映射类型:\nExclude – 从 T 中剔除可以赋值给 U 的类型。 Extract – 提取 T 中可以赋值给 U 的类型。 NonNullable – 从 T 中剔除 null 和 undefined 。 ReturnType – 获取函数返回值类型。 InstanceType – 获取构造函数类型的实例类型。 (2) extends 条件分发 对于 T extends U ? X : Y 来说，还存在一个特性，当 T 是一个联合类型时，会进行条件分发。\ntype Union = string | number type ParamType = T extends number ? 'isNumber' : 'isString' type UnionType = ParamType // 'isNumber' | 'isString' 实际上，extends 运算会变成如下形式:\n(string extends number ? 'number' : 'string') | (number extends number ? 'number' : 'string') Extract 就是基于此特性实现的，再配合 never 幺元的特性:\ntype Exclude = T extends K ? never : T type T1 = Exclude // number (3) infer 关键词 infer 关键词常在条件类型中和 extends 关键词一同出现，表示将要推断的类型，作为类型变量可以在三元表达式的 True 部分引用\nts 中内置的一个映射类型 ReturnType ，用于获取函数类型的返回值:\nfunction len (str: string) { return str.length } type LenFn = typeof len // (str: string) =\u003e number type LenFnReturn = ReturnType // number ReturnType 的实现:\ntype ReturnType any\u003e = T extends (...args: any) =\u003e infer R ? R : any; 八、模块 1、全局模块 vs. 文件模块 默认情况下，我们所写的代码是位于全局模块下的:\nconst foo = 2 此时，如果我们创建了另一个文件，并写下如下代码，ts 认为是正常的:\nconst bar = foo // ok 如果要打破这种限制，只要文件中有 import 或者 export 表达式即可:\nexport const bar = foo // error 2、模块解析策略 Tpescript 有两种模块的解析策略: Node 和 Classic 。\n当 tsconfig.json 中 module 设置成 AMD、System、ES2015 时，默认为 classic ，否则为 Node ，也可以使用 moduleResolution 手动指定模块解析策略。\n两种模块解析策略的区别在于:\nimport { a } from 'moduleB' Classic:\n/root/src/folder/moduleB.ts /root/src/folder/moduleB.d.ts /root/src/moduleB.ts /root/src/moduleB.d.ts /root/moduleB.ts /root/moduleB.d.ts /moduleB.ts /moduleB.d.ts Node:\n/root/src/node_modules/moduleB.ts /root/src/node_modules/moduleB.tsx /root/src/node_modules/moduleB.d.ts /root/src/node_modules/moduleB/package.json (如果指定了\"types\"属性) /root/src/node_modules/moduleB/index.ts /root/src/node_modules/moduleB/index.tsx /root/src/node_modules/moduleB/index.d.ts /root/node_modules/moduleB.ts /root/node_modules/moduleB.tsx /root/node_modules/moduleB.d.ts /root/node_modules/moduleB/package.json (如果指定了\"types\"属性) /root/node_modules/moduleB/index.ts /root/node_modules/moduleB/index.tsx /root/node_modules/moduleB/index.d.ts /node_modules/moduleB.ts /node_modules/moduleB.tsx /node_modules/moduleB.d.ts /node_modules/moduleB/package.json (如果指定了\"types\"属性) /node_modules/moduleB/index.ts /node_modules/moduleB/index.tsx /node_modules/moduleB/index.d.ts 参考:\n可参考文章-语雀 TypeScript官方文档 最后， 希望大家早日实现：成为编程高手的伟大梦想！ 欢迎交流~\n本文版权归原作者曜灵所有！未经允许，严禁转载！对非法转载者, 原作者保留采用法律手段追究的权利！ 若需转载，请联系微信公众号：连先生有猫病，可获取作者联系方式！\n","wordCount":"7604","inLanguage":"zh","datePublished":"2021-03-13T17:59:58+08:00","dateModified":"2021-03-13T17:59:58+08:00","author":{"@type":"Person","name":"曜灵"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://lianpf.github.io/posts/frontend-develop/03.ts-basic-grammar/"},"publisher":{"@type":"Organization","name":"曜灵（SUN）Site","logo":{"@type":"ImageObject","url":"https://lianpf.github.io/img-common/favicon.png"}}}</script></head><body id=top><script>(function(){let e,t=new RegExp("(^| )change-themes=([^;]*)(;|$)");(e=document.cookie.match(t))||((new Date).getHours()>=19||(new Date).getHours()<6?(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark")):(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")))})(),localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://lianpf.github.io/ accesskey=h title="曜灵（SUN）Site (Alt + H)"><img src=https://lianpf.github.io/img-common/avatar.jpeg alt=logo aria-label=logo height=35>曜灵（SUN）Site</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://lianpf.github.io/search title="🔍 搜索 (Alt + /)" accesskey=/><span>🔍 搜索</span></a></li><li><a href=https://lianpf.github.io/ title="🏠 主页"><span>🏠 主页</span></a></li><li><a href=https://lianpf.github.io/archives/ title="⏱️ 归档"><span>⏱️ 归档</span></a></li><li><a href=https://lianpf.github.io/tags title="🧩 标签"><span>🧩 标签</span></a></li><li><a href=https://lianpf.github.io/about title="🙋🏻‍♂️ 关于"><span>🙋🏻‍♂️ 关于</span></a></li></ul></nav></header><main class="main page"><style>i[id*=post_meta_style]{display:flex;align-items:center;margin:0 0 10px}</style><article class=post-single><div id=single-content><header class=post-header><div class=breadcrumbs><a href=https://lianpf.github.io/>🏠 主页</a>&nbsp;»&nbsp;<a href=https://lianpf.github.io/posts/>📚文章</a>&nbsp;»&nbsp;<a href=https://lianpf.github.io/posts/frontend-develop/>👨🏻‍💻 前端</a></div><h1 class=post-title>vue3+ts(2)：TypeScript 语法汇总</h1><div class=post-meta><style>i[id*=post_meta_style]{display:flex;align-items:center;margin:0 0 10px}.parent-post-meta{display:flex;flex-wrap:wrap;opacity:.8}</style><span class=parent-post-meta><span id=post_meta_style_1><span class="fa fa-calendar-check-o"></span>
<span>2021-03-13
&nbsp;&nbsp;</span></span>
<span id=post_meta_style_3><span class="fa fa-file-word-o"></span>
<span>7604字
&nbsp;&nbsp;</span></span>
<span id=post_meta_style_4><span class="fa fa-clock-o"></span>
<span>16分钟
&nbsp;&nbsp;</span></span>
<span id=post_meta_style_5><span class="fa fa-user-o"></span>
<span>曜灵
&nbsp;&nbsp;</span></span>
<span id=post_meta_style_6><span class="fa fa-tags" style=opacity:.8></span>
<span><span class=post-tags-meta><a href=https://lianpf.github.io/tags/ts/ style=color:var(--secondary)!important>TS</a></span></span></span></span>
<span style=opacity:.8><span id=post_meta_style_7>&nbsp;&nbsp;
<span class="fa fa-eye"></span>
<span><span id=busuanzi_container_page_pv><span id=busuanzi_value_page_pv></span></span>
&nbsp;&nbsp;</span></span>
<span id=post_meta_style_8><span class="fa fa-commenting-o"></span>
<span><script src=https://cdn.staticfile.org/twikoo/1.5.8/twikoo.all.min.js></script>
<script>let url=document.documentURI,dnsUrl="https://lianpf.github.io/",urlSplit=url.split(dnsUrl),finalUrl=urlSplit[1];finalUrl[0]!=="/"&&(finalUrl="/"+finalUrl),twikoo.getCommentsCount({envId:null,region:null,urls:[finalUrl],includeReply:!1}).then(function(e){let t=e[0].count;const n=document.getElementById("comment_count");n.innerText=t}).catch(function(e){console.error(e)})</script><span id=comment_count></span></span></span></span></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#%e4%b8%80%e8%83%8c%e6%99%af aria-label=一、背景>一、背景</a></li><li><a href=#%e4%ba%8c%e5%89%8d%e8%a8%80 aria-label=二、前言>二、前言</a><ul><li><a href=#1%e9%9d%99%e6%80%81%e7%b1%bb%e5%9e%8b%e5%8a%a8%e6%80%81%e7%b1%bb%e5%9e%8b%e5%bc%ba%e7%b1%bb%e5%9e%8b%e5%bc%b1%e7%b1%bb%e5%9e%8b aria-label=1、静态类型、动态类型、强类型、弱类型>1、静态类型、动态类型、强类型、弱类型</a></li><li><a href=#2typescript%e6%98%af%e4%bb%80%e4%b9%88 aria-label=2、Typescript是什么>2、Typescript是什么</a></li><li><a href=#3%e4%b8%ba%e4%bb%80%e4%b9%88%e4%bd%bf%e7%94%a8-typescript aria-label="3、为什么使用 Typescript">3、为什么使用 Typescript</a></li></ul></li><li><a href=#%e4%b8%89%e7%b1%bb%e5%9e%8b aria-label=三、类型>三、类型</a><ul><li><a href=#1%e5%9f%ba%e7%a1%80%e7%b1%bb%e5%9e%8b aria-label=1、基础类型>1、基础类型</a><ul><li><a href=#11-%e6%9e%9a%e4%b8%beenum aria-label="1.1 枚举（enum）">1.1 枚举（<code>enum</code>）</a></li><li><a href=#12-any-%e5%92%8c-unknown-%e7%9a%84%e5%8c%ba%e5%88%ab aria-label="1.2 any 和 unknown 的区别">1.2 <code>any</code> 和 <code>unknown</code> 的区别</a></li><li><a href=#13-never aria-label="1.3 never">1.3 <code>never</code></a></li></ul></li><li><a href=#2%e9%ab%98%e7%ba%a7%e7%b1%bb%e5%9e%8b aria-label=2、高级类型>2、高级类型</a><ul><li><a href=#21-%e8%81%94%e5%90%88%e7%b1%bb%e5%9e%8b%e4%b8%8e%e4%ba%a4%e5%8f%89%e7%b1%bb%e5%9e%8b aria-label="2.1 联合类型与交叉类型">2.1 联合类型与交叉类型</a></li><li><a href=#22-%e7%b1%bb%e5%9e%8b%e4%bf%9d%e6%8a%a4%e5%92%8c%e7%b1%bb%e5%9e%8b%e6%96%ad%e8%a8%80 aria-label="2.2 类型保护和类型断言">2.2 类型保护和类型断言</a><ul><li><a href=#221-%e4%bd%bf%e7%94%a8ts%e7%9a%84-is-%e5%85%b3%e9%94%ae%e8%af%8d aria-label="2.2.1 使用ts的 is 关键词">2.2.1 使用ts的 <code>is</code> 关键词</a></li><li><a href=#222-%e7%b1%bb%e5%9e%8b%e4%bf%9d%e6%8a%a4 aria-label="2.2.2 类型保护">2.2.2 类型保护</a><ul><li><a href=#1-js-typeof-%e5%85%b3%e9%94%ae%e8%af%8d aria-label="(1) js typeof 关键词">(1) js <code>typeof</code> 关键词</a></li><li><a href=#2-js-instanceof-%e5%85%b3%e9%94%ae%e8%af%8d aria-label="(2) js instanceof 关键词">(2) js <code>instanceof</code> 关键词</a></li><li><a href=#3-%e9%92%88%e5%af%b9-null-%e5%92%8c-undefined-%e7%9a%84%e7%b1%bb%e5%9e%8b%e4%bf%9d%e6%8a%a4 aria-label="(3) 针对 null 和 undefined 的类型保护">(3) 针对 null 和 undefined 的类型保护</a></li></ul></li><li><a href=#223-%e7%b1%bb%e5%9e%8b%e6%96%ad%e8%a8%80 aria-label="2.2.3 类型断言">2.2.3 类型断言</a><ul><li><a href=#1-%e9%92%88%e5%af%b9-null-%e5%92%8c-undefined-%e7%9a%84%e7%b1%bb%e5%9e%8b%e6%96%ad%e8%a8%80 aria-label="(1) 针对 null 和 undefined 的类型断言">(1) 针对 null 和 undefined 的类型断言</a></li></ul></li></ul></li><li><a href=#23-%e7%b4%a2%e5%bc%95%e7%b1%bb%e5%9e%8bindex-types aria-label="2.3 索引类型（Index types）">2.3 索引类型（Index types）</a><ul><li><a href=#1-keyof aria-label="(1) keyof">(1) keyof</a></li><li><a href=#2-in aria-label="(2) in">(2) in</a></li><li><a href=#3- aria-label="(3) []">(3) <code>[]</code></a></li></ul></li></ul></li><li><a href=#3%e7%b1%bb%e5%9e%8b%e6%8e%a8%e6%96%ad aria-label=3、类型推断>3、类型推断</a></li><li><a href=#4%e7%b1%bb%e5%9e%8b%e5%85%bc%e5%ae%b9%e6%80%a7 aria-label=4、类型兼容性>4、类型兼容性</a><ul><li><a href=#41-%e5%af%b9%e8%b1%a1%e5%ad%90%e7%b1%bb%e5%9e%8b aria-label="4.1 对象子类型">4.1 对象子类型</a></li><li><a href=#42-%e5%8d%8f%e5%8f%98%e4%b8%8e%e9%80%86%e5%8f%98 aria-label="4.2 协变与逆变">4.2 协变与逆变</a><ul><li><a href=#1-%e5%87%bd%e6%95%b0%e5%ad%90%e7%b1%bb%e5%9e%8b aria-label="(1) 函数子类型">(1) 函数子类型</a></li></ul></li></ul></li></ul></li><li><a href=#%e5%9b%9b%e6%8e%a5%e5%8f%a3 aria-label=四、接口>四、接口</a><ul><li><a href=#1%e5%8f%af%e9%80%89%e5%b1%9e%e6%80%a7 aria-label=1、可选属性>1、可选属性</a></li><li><a href=#2%e5%8f%af%e7%b4%a2%e5%bc%95%e7%9a%84%e7%b1%bb%e5%9e%8b aria-label=2、可索引的类型>2、可索引的类型</a></li></ul></li><li><a href=#%e4%ba%94%e7%b1%bb aria-label=五、类>五、类</a><ul><li><a href=#1%e7%bb%a7%e6%89%bf aria-label=1、继承>1、继承</a></li><li><a href=#2%e4%bf%ae%e9%a5%b0%e7%ac%a6 aria-label=2、修饰符>2、修饰符</a></li><li><a href=#3%e5%ad%98%e5%8f%96%e5%99%a8 aria-label=3、存取器>3、存取器</a></li><li><a href=#4%e9%9d%99%e6%80%81%e5%b1%9e%e6%80%a7 aria-label=4、静态属性>4、静态属性</a></li><li><a href=#5%e6%8a%bd%e8%b1%a1%e7%b1%bb aria-label=5、抽象类>5、抽象类</a></li><li><a href=#6%e7%b1%bb%e5%92%8c%e6%8e%a5%e5%8f%a3 aria-label=6、类和接口>6、类和接口</a></li></ul></li><li><a href=#%e5%85%ad%e5%87%bd%e6%95%b0 aria-label=六、函数>六、函数</a><ul><li><a href=#1%e5%87%bd%e6%95%b0%e7%b1%bb%e5%9e%8b aria-label=1、函数类型>1、函数类型</a><ul><li><a href=#1-%e5%87%a0%e7%a7%8d%e5%87%bd%e6%95%b0%e7%b1%bb%e5%9e%8b%e7%9a%84%e8%bf%94%e5%9b%9e%e5%80%bc%e7%b1%bb%e5%9e%8b%e5%86%99%e6%b3%95 aria-label="(1) 几种函数类型的返回值类型写法">(1) 几种函数类型的返回值类型写法</a></li><li><a href=#2-%e5%87%bd%e6%95%b0%e7%b1%bb%e5%9e%8b aria-label="(2) 函数类型">(2) 函数类型</a></li></ul></li><li><a href=#2%e5%87%bd%e6%95%b0%e9%87%8d%e8%bd%bd aria-label=2、函数重载?>2、函数重载<code>?</code></a></li></ul></li><li><a href=#%e4%b8%83%e6%b3%9b%e5%9e%8b aria-label=七、泛型>七、泛型</a><ul><li><a href=#1%e4%bb%80%e4%b9%88%e6%98%af%e6%b3%9b%e5%9e%8b aria-label=1、什么是泛型>1、什么是泛型</a></li><li><a href=#2%e6%b3%9b%e5%9e%8b%e6%8e%a5%e5%8f%a3 aria-label=2、泛型接口>2、泛型接口</a></li><li><a href=#3%e6%b3%9b%e5%9e%8b%e7%b1%bb aria-label=3、泛型类>3、泛型类</a></li><li><a href=#4%e6%b3%9b%e5%9e%8b%e7%ba%a6%e6%9d%9f aria-label=4、泛型约束>4、泛型约束</a><ul><li><a href=#41-%e6%9d%a1%e4%bb%b6%e6%8e%a7%e5%88%b6 aria-label="4.1 条件控制">4.1 条件控制</a></li><li><a href=#42-%e7%b1%bb%e5%9e%8b%e6%98%a0%e5%b0%84 aria-label="4.2 类型映射">4.2 类型映射</a><ul><li><a href=#1-%e5%86%85%e7%bd%ae%e7%9a%84%e6%98%a0%e5%b0%84%e7%b1%bb%e5%9e%8b aria-label="(1) 内置的映射类型">(1) 内置的映射类型</a></li><li><a href=#2-extends-%e6%9d%a1%e4%bb%b6%e5%88%86%e5%8f%91 aria-label="(2) extends 条件分发">(2) extends 条件分发</a></li><li><a href=#3-infer-%e5%85%b3%e9%94%ae%e8%af%8d aria-label="(3) infer 关键词">(3) infer 关键词</a></li></ul></li></ul></li></ul></li><li><a href=#%e5%85%ab%e6%a8%a1%e5%9d%97 aria-label=八、模块>八、模块</a><ul><li><a href=#1%e5%85%a8%e5%b1%80%e6%a8%a1%e5%9d%97-vs-%e6%96%87%e4%bb%b6%e6%a8%a1%e5%9d%97 aria-label="1、全局模块 vs. 文件模块">1、全局模块 vs. 文件模块</a></li><li><a href=#2%e6%a8%a1%e5%9d%97%e8%a7%a3%e6%9e%90%e7%ad%96%e7%95%a5 aria-label=2、模块解析策略>2、模块解析策略</a></li></ul></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{elements&&(activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")}))},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><p>本文是vue3+ts项目系列第2篇《TypeScript 语法汇总》，关于<code>TypeScript</code>的基础语法，你了解&mldr;</p><h2 id=一背景>一、背景<a hidden class=anchor aria-hidden=true href=#一背景>#</a></h2><p>在 react 和 vue 社区中也越来越多人开始使用TypeScript，使用 TS 可以增加代码的可读性和可维护性。从发布的 Vue3 正式版本来看， Vue3 的源码是用 TS 编写的，更好的 TypeScript 支持也是这次升级的一大亮点。当然，在实际开发中如何正确拥抱 TS 以及如何迁移到 Vue3 也是项目中我们不得不面对的问题，这里针对 Vue3 和 TS单独做了一个系列和大家做一下交流，本篇是 vue3+ts项目系列第2篇《TypeScript 语法汇总》。</p><p>本系列其他内容如下:</p><ul><li>vue3+ts项目系列第1篇<a href=https://lianpf.github.io/posts/%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0/10.vue3%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/>《vue3项目从0到1搭建》</a></li><li>vue3+ts项目系列第2篇<a href=https://lianpf.github.io/posts/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/03.ts%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/>《TypeScript 语法汇总》</a></li><li>vue3+ts项目系列第3篇<a href=https://lianpf.github.io/posts/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/07.vue3%E7%BB%84%E5%90%88%E5%BC%8Fapi%E5%8F%8A%E9%87%8D%E8%A6%81%E5%B1%9E%E6%80%A7%E5%8F%98%E6%9B%B4/>《vue3组合式api及重要属性变更》</a></li></ul><h2 id=二前言>二、前言<a hidden class=anchor aria-hidden=true href=#二前言>#</a></h2><h3 id=1静态类型动态类型强类型弱类型>1、静态类型、动态类型、强类型、弱类型<a hidden class=anchor aria-hidden=true href=#1静态类型动态类型强类型弱类型>#</a></h3><p>编译时就知道变量类型的是静态类型，运行时才知道一个变量类型的叫做动态类型。 java 是静态类型， js 是动态类型。</p><p>不允许隐式转换的是强类型，允许隐式转换的是弱类型。 java 是强类型， js 是弱类型。</p><p>那ts到底是什么类型的语言，很明显， ts 是静态类型语言，因为它需要经过编译。但是 ts不是强类型，因为它可以允许隐式类型转换。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>let isBool: boolean
</span></span><span style=display:flex><span>let num: number = 10
</span></span><span style=display:flex><span>isBool = !num // ok
</span></span></code></pre></div><h3 id=2typescript是什么>2、Typescript是什么<a hidden class=anchor aria-hidden=true href=#2typescript是什么>#</a></h3><ul><li>ECMAScript 的超集 (stage 3)</li><li>编译期的类型检查</li><li>不引入额外开销(零依赖，不扩展 js 语法，不侵入运行时)</li><li>编译出通用的、易读的 js 代码</li></ul><p><code>Typescript = Type + ECMAScript + Babel-Lite</code></p><p>Typescript 设计目标: <a href=https://github.com/Microsoft/TypeScript/wiki/TypeScript-Design-Goals>链接</a></p><h3 id=3为什么使用-typescript>3、为什么使用 Typescript<a hidden class=anchor aria-hidden=true href=#3为什么使用-typescript>#</a></h3><ul><li>增加了代码的可读性和可维护性</li><li>减少运行时错误，写出的代码更加安全，减少 BUG</li><li>享受到代码提示带来的快感</li><li>重构神器</li></ul><h2 id=三类型>三、类型<a hidden class=anchor aria-hidden=true href=#三类型>#</a></h2><h3 id=1基础类型>1、基础类型<a hidden class=anchor aria-hidden=true href=#1基础类型>#</a></h3><p>声明了变量的类型，那么这个变量就有了静态类型的特性，ts中使用<code>:</code>操作符来声明类型:</p><ul><li>boolean</li><li>number</li><li>string</li><li>array</li><li>tuple（元组）</li><li>enum（枚举）</li><li>any & unknown</li><li>void</li><li>null & undefined</li><li>never</li><li>Object</li></ul><p>声明变量的类型:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>let bool: boolean = false // boolean 类型
</span></span><span style=display:flex><span>let num: number = 12 // number 类型
</span></span><span style=display:flex><span>let str: string = &#39;hello world&#39; // string类型
</span></span><span style=display:flex><span>let numArr: number[] = [1, 2, 3] // number数组类型
</span></span><span style=display:flex><span>let numArr: Array&lt;number&gt; = [1, 2, 3] // 数组泛型形式：number数组类型
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>let unknow: any = 4 // any类型，即任一类型
</span></span><span style=display:flex><span>unknow = &#34;maybe a string instead&#34;
</span></span><span style=display:flex><span>unknow = false
</span></span></code></pre></div><h4 id=11-枚举enum>1.1 枚举（<code>enum</code>）<a hidden class=anchor aria-hidden=true href=#11-枚举enum>#</a></h4><ul><li>数字枚举</li><li>字符串枚举</li><li>常量枚举</li></ul><p>很多编程语言都有枚举的概念，枚举就是一组常量的集合，但是和集合不同，枚举可以通过变量的值来得到变量，它是一个双向的过程:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>enum Direction {
</span></span><span style=display:flex><span>  UP,
</span></span><span style=display:flex><span>  DOWN,
</span></span><span style=display:flex><span>  LEFT,
</span></span><span style=display:flex><span>  RIGHT
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Direction.UP // 0
</span></span><span style=display:flex><span>Direction[0] // &#39;UP&#39;
</span></span></code></pre></div><p><strong>数字枚举</strong><br></p><p>上例中的 Direction 就是一个数字枚举，默认的，第一个变量的值是0，后面的值会在前一个值上 +1 ，所以 DOWN 的值为1， LEFT 的值为2，以此类推。
如果想改变枚举的初始值，只需要给第一个变量赋值即可:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>enum Direction {
</span></span><span style=display:flex><span>  UP = 1,
</span></span><span style=display:flex><span>  DOWN,
</span></span><span style=display:flex><span>  LEFT,
</span></span><span style=display:flex><span>  RIGHT
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>字符串枚举</strong><br>字符串枚举的概念很简单， 在一个字符串枚举里，<strong>每个成员都必须初始化</strong>:</p><blockquote><p>如果某个成员没有被初始化，则会报错</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>enum Direction {
</span></span><span style=display:flex><span>  UP = &#39;UP&#39;,
</span></span><span style=display:flex><span>  DOWN = &#39;DOWN&#39;,
</span></span><span style=display:flex><span>  LEFT = &#39;LEFT&#39;,
</span></span><span style=display:flex><span>  RIGHT = &#39;RIGHT&#39;,
</span></span><span style=display:flex><span>  MIDDLE //error 枚举成员必须具有初始化表达式
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>常量枚举</strong><br>可以用 <code>const</code> 修饰符来声明枚举，这时候编译后的js代码将不会出现额外的声明代码:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>enum Direction {
</span></span><span style=display:flex><span>  UP,
</span></span><span style=display:flex><span>  DOWN,
</span></span><span style=display:flex><span>  LEFT,
</span></span><span style=display:flex><span>  RIGHT
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>const enum Seasons {
</span></span><span style=display:flex><span>  SPRING = &#39;SPRING&#39;,
</span></span><span style=display:flex><span>  SUMMER = &#39;SUMMER&#39;,
</span></span><span style=display:flex><span>  AUTUMN = &#39;AUTUMN&#39;,
</span></span><span style=display:flex><span>  WINTER = &#39;WINTER&#39;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>const up = Direction.UP
</span></span><span style=display:flex><span>const spring = Seasons.SPRING
</span></span></code></pre></div><p>生成的js:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>var Direction;
</span></span><span style=display:flex><span>(function (Direction) {
</span></span><span style=display:flex><span>  Direction[Direction[&#34;UP&#34;] = 0] = &#34;UP&#34;;
</span></span><span style=display:flex><span>  Direction[Direction[&#34;DOWN&#34;] = 1] = &#34;DOWN&#34;;
</span></span><span style=display:flex><span>  Direction[Direction[&#34;LEFT&#34;] = 2] = &#34;LEFT&#34;;
</span></span><span style=display:flex><span>  Direction[Direction[&#34;RIGHT&#34;] = 3] = &#34;RIGHT&#34;;
</span></span><span style=display:flex><span>})(Direction || (Direction = {}));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>var up = Direction.UP;
</span></span><span style=display:flex><span>var spring = &#34;SPRING&#34; /* SPRING */;
</span></span></code></pre></div><h4 id=12-any-和-unknown-的区别>1.2 <code>any</code> 和 <code>unknown</code> 的区别<a hidden class=anchor aria-hidden=true href=#12-any-和-unknown-的区别>#</a></h4><ul><li><code>any</code> : 任意类型</li><li><code>unknown</code> : 未知的类型</li></ul><p><strong>任何类型都能分配给 <code>unknown</code> ，但 <code>unknown</code> 不能分配给其他基本类型，而 <code>any</code> 啥都能分配和被分配</strong></p><p><code>unknown</code> Demo:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>let foo: unknown
</span></span><span style=display:flex><span>foo = true // ok
</span></span><span style=display:flex><span>foo = 123 //ok
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>foo.toFixed(2) // error
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>let foo1: string = foo // error
</span></span></code></pre></div><p><code>any</code> Demo:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>let bar: any
</span></span><span style=display:flex><span>bar = true // ok
</span></span><span style=display:flex><span>bar = 123 //ok
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>foo.toFixed(2) // ok
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>let bar1:string = bar // ok
</span></span></code></pre></div><p>如上，用了 <code>any</code> 就相当于完全丢失了类型检查，所以尽量少用 <code>any</code> ，对于未知类型可以用 <code>unknown</code></p><p><strong><code>unknown</code> 的正确用法</strong><br>可以通过不同的方式将 <code>unknown</code> 类型缩小为更具体的类型范围:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>function getLen(value: unknown): number {
</span></span><span style=display:flex><span>  if (typeof value === &#39;string&#39;) {
</span></span><span style=display:flex><span>    // 因为类型保护的原因，此处 value 被判断为 string 类型
</span></span><span style=display:flex><span>    return value.length
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  return 0
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><blockquote><p>这个过程叫类型收窄(type narrowing)</p></blockquote><h4 id=13-never>1.3 <code>never</code><a hidden class=anchor aria-hidden=true href=#13-never>#</a></h4><ul><li><code>never</code> 类型表示的是那些永不存在的值的类型。</li></ul><blockquote><p>never类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型；变量也可能是 never类型，当它们被永不为真的类型保护所约束时。</p></blockquote><ul><li><code>never</code> 类型是任何类型的子类型，也可以赋值给任何类型</li></ul><blockquote><p>没有类型是never的子类型或可以赋值给never类型（除了never本身之外），即使 any也不可以赋值给never</p></blockquote><p>在最新的 typescript 3.7 中，下面代码会报错:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>// never 用户控制流分析
</span></span><span style=display:flex><span>function neverReach (): never {
</span></span><span style=display:flex><span>  throw new Error(&#39;an error&#39;)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>const x = neverReach()
</span></span><span style=display:flex><span>x.toFixed(2) // x is unreachable
</span></span></code></pre></div><p>never 还可以用于联合类型的<a href="https://baike.baidu.com/item/%E5%8D%95%E4%BD%8D%E5%85%83/11035606?fromtitle=%E5%B9%BA%E5%85%83&amp;fromid=5122315&amp;fr=aladdin">幺元</a>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>type T0 = string | number | never // T0 is string | number
</span></span></code></pre></div><p><a id=ts-01-02-02></a></p><h3 id=2高级类型>2、高级类型<a hidden class=anchor aria-hidden=true href=#2高级类型>#</a></h3><h4 id=21-联合类型与交叉类型>2.1 联合类型与交叉类型<a hidden class=anchor aria-hidden=true href=#21-联合类型与交叉类型>#</a></h4><p>联合类型(union type)表示多种类型的 “或” 关系</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>function genLen(x: string | any[]) {
</span></span><span style=display:flex><span>  return x.length
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>genLen(&#39;&#39;) // ok
</span></span><span style=display:flex><span>genLen([]) // ok
</span></span><span style=display:flex><span>genLen(1) // error
</span></span></code></pre></div><p>交叉类型表示多种类型的 “与” 关系</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>interface Person {
</span></span><span style=display:flex><span>  name: string
</span></span><span style=display:flex><span>  age: number
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>interface Animal {
</span></span><span style=display:flex><span>  name: string
</span></span><span style=display:flex><span>  color: string
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>const x: Person &amp; Animal = {
</span></span><span style=display:flex><span>  name: &#39;x&#39;,
</span></span><span style=display:flex><span>  age: 1,
</span></span><span style=display:flex><span>  color: &#39;red
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>使用联合类型表示枚举</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>type Position = &#39;UP&#39; | &#39;DOWN&#39; | &#39;LEFT&#39; | &#39;RIGHT&#39;
</span></span><span style=display:flex><span>const position: Position = &#39;UP&#39;
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>// 具值联合类型
</span></span><span style=display:flex><span>// type 关键词可以声明一个类型
</span></span><span style=display:flex><span>type positionType = &#39;top&#39; | &#39;center&#39; | &#39;bottom&#39;
</span></span><span style=display:flex><span>let position: positionType = &#39;top&#39; // ok
</span></span><span style=display:flex><span>position = &#39;left&#39; // error 不能将类型“&#34;left&#34;”分配给类型“positionType”
</span></span><span style=display:flex><span>position = &#39;bottom&#39; // ok
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>// 数组联合类型
</span></span><span style=display:flex><span>let arr: (number | string)[] = []
</span></span><span style=display:flex><span>arr.push(1) // ok
</span></span><span style=display:flex><span>arr.push(&#39;hello&#39;) // ok
</span></span><span style=display:flex><span>arr.push(true) // error 类型“true”的参数不能赋给类型“string | number”的参数。
</span></span></code></pre></div><p>可以避免使用 enum 侵入了运行时。</p><p><a id=ts-01-02-03></a></p><h4 id=22-类型保护和类型断言>2.2 类型保护和类型断言<a hidden class=anchor aria-hidden=true href=#22-类型保护和类型断言>#</a></h4><p>ts 初学者很容易写出下面的代码:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>function isString (value) {
</span></span><span style=display:flex><span>  return Object.prototype.toString.call(value) === &#39;[object String]&#39;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>function fn (x: string | number) {
</span></span><span style=display:flex><span>  if (isString(x)) {
</span></span><span style=display:flex><span>    return x.length // error 类型“string | number”上不存在属性“length”。
</span></span><span style=display:flex><span>  } else {
</span></span><span style=display:flex><span>    // .....
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>如何让 ts 推断出来 x 是 string 类型呢?</p><h5 id=221-使用ts的-is-关键词>2.2.1 使用ts的 <code>is</code> 关键词<a hidden class=anchor aria-hidden=true href=#221-使用ts的-is-关键词>#</a></h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>function isString (value: unknown): value is string {
</span></span><span style=display:flex><span>  return Object.prototype.toString.call(value) === &#39;[object String]&#39;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>function fn (x: string | number) {
</span></span><span style=display:flex><span>  if (isString(x)) {
</span></span><span style=display:flex><span>    return x.length
</span></span><span style=display:flex><span>  } else {
</span></span><span style=display:flex><span>    // .....
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h5 id=222-类型保护>2.2.2 类型保护<a hidden class=anchor aria-hidden=true href=#222-类型保护>#</a></h5><h6 id=1-js-typeof-关键词>(1) js <code>typeof</code> 关键词<a hidden class=anchor aria-hidden=true href=#1-js-typeof-关键词>#</a></h6><p>typeof 关系词可以从实现 推出类型，这是一个类型关键词</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>function getLen(x: string | any[]) {
</span></span><span style=display:flex><span>  return x.length
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>type GetLen = typeof getLen
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>function callback(fn: GetLen) {
</span></span><span style=display:flex><span>  fn(1) // 类型“1”的参数不能赋给类型“string | any[]”的参数
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h6 id=2-js-instanceof-关键词>(2) js <code>instanceof</code> 关键词<a hidden class=anchor aria-hidden=true href=#2-js-instanceof-关键词>#</a></h6><p>在 ts 中，instanceof 关键词能够帮助 ts 判断出构造函数的类型:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>function fn1 (x: XMLHttpRequest | string) {
</span></span><span style=display:flex><span>  if (x instanceof XMLHttpRequest) { // x is XMLHttpRequest
</span></span><span style=display:flex><span>    return x.getAllResponseHeaders()
</span></span><span style=display:flex><span>  } else { // x is string
</span></span><span style=display:flex><span>    return x.length
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h6 id=3-针对-null-和-undefined-的类型保护>(3) 针对 null 和 undefined 的类型保护<a hidden class=anchor aria-hidden=true href=#3-针对-null-和-undefined-的类型保护>#</a></h6><p>在条件判断中，ts 会自动对 null 和 undefined 进行类型保护:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>function fn2 (x?: string) {
</span></span><span style=display:flex><span>  if (x) {
</span></span><span style=display:flex><span>    return x.length
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h5 id=223-类型断言>2.2.3 类型断言<a hidden class=anchor aria-hidden=true href=#223-类型断言>#</a></h5><h6 id=1-针对-null-和-undefined-的类型断言>(1) 针对 null 和 undefined 的类型断言<a hidden class=anchor aria-hidden=true href=#1-针对-null-和-undefined-的类型断言>#</a></h6><p>如果我们已经知道的参数不为空，可以使用<code>!</code>来手动标记:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>function fn2 (x?: string) {
</span></span><span style=display:flex><span>  return x!.length
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=23-索引类型index-types>2.3 索引类型（Index types）<a hidden class=anchor aria-hidden=true href=#23-索引类型index-types>#</a></h4><ul><li>keyof</li><li>in</li><li><code>[]</code></li></ul><h5 id=1-keyof>(1) keyof<a hidden class=anchor aria-hidden=true href=#1-keyof>#</a></h5><p>keyof 也是一个 类型关键词 ，可以用来取得一个对象接口的所有 key 值:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>interface Person {
</span></span><span style=display:flex><span>  name: string
</span></span><span style=display:flex><span>  age: number
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>type PersonAttrs = keyof Person // &#39;name&#39; | &#39;age&#39;
</span></span></code></pre></div><h5 id=2-in>(2) in<a hidden class=anchor aria-hidden=true href=#2-in>#</a></h5><p>in 也是一个 类型关键词 ，可以对 联合类型 进行遍历，只可以用在 type 关键词下面。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>type Person = {
</span></span><span style=display:flex><span>  [key in &#39;name&#39; | &#39;age&#39;]: number
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>// ===&gt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>type Person = {
</span></span><span style=display:flex><span>  name: number;
</span></span><span style=display:flex><span>  age: number;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h5 id=3->(3) <code>[]</code><a hidden class=anchor aria-hidden=true href=#3->#</a></h5><p>使用 <code>[]</code> 操作符可以进行索引访问，也是一个 类型关键词</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>interface Person {
</span></span><span style=display:flex><span>  name: string
</span></span><span style=display:flex><span>  age: number
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>type x = Person[&#39;name&#39;] // x is string
</span></span></code></pre></div><p><strong>示例</strong><br>写一个类型复制的类型工具:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>type Copy&lt;T&gt; = {
</span></span><span style=display:flex><span>  [key in keyof T]: T[key]
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>interface Person {
</span></span><span style=display:flex><span>  name: string
</span></span><span style=display:flex><span>  age: number
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>type Person1 = Copy&lt;Person&gt;
</span></span></code></pre></div><p><a id=ts-01-02-03></a></p><h3 id=3类型推断>3、类型推断<a hidden class=anchor aria-hidden=true href=#3类型推断>#</a></h3><p>ts 中的类型推断是非常强大，而且其内部实现也是非常复杂的。</p><p>基本类型推断:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>// ts 推导出 x 是 number 类型
</span></span><span style=display:flex><span>let x = 10
</span></span></code></pre></div><p>对象类型推断:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>// ts 推断出 myObj 的类型: myObj: { x: number; y: string; z: boolean;
</span></span><span style=display:flex><span>const myObj = {
</span></span><span style=display:flex><span>  x:1,
</span></span><span style=display:flex><span>  y: &#39;2&#39;,
</span></span><span style=display:flex><span>  z: true
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>函数类型推断:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>// ts 推导出函数返回值是 number 类型
</span></span><span style=display:flex><span>function len (str: string) {
</span></span><span style=display:flex><span>  return str.length
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>上下文类型推断:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>// ts 推导出 event 是 ProgressEvent 类型
</span></span><span style=display:flex><span>const xhr = new XMLHttpRequest()
</span></span><span style=display:flex><span>xhr.onload = function (event) {}
</span></span></code></pre></div><blockquote><p>写 ts 代码的时候，对于基本类型我们可以不用手动声明其类型，让 ts 自己去推断</p></blockquote><p>知乎 - typescript上下文相关类型浅析 <a href=https://zhuanlan.zhihu.com/p/84481228>https://zhuanlan.zhihu.com/p/84481228</a></p><h3 id=4类型兼容性>4、类型兼容性<a hidden class=anchor aria-hidden=true href=#4类型兼容性>#</a></h3><p>typescript 的子类型是基于 结构子类型 的，只要结构可以兼容，就是子类型。(Duck Type)</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>class Point {
</span></span><span style=display:flex><span>  x: number
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>function getPointX(point: Point) {
</span></span><span style=display:flex><span>  return point.x
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>class Point2 {
</span></span><span style=display:flex><span>  x: number
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>let point2 = new Point2()
</span></span><span style=display:flex><span>getPointX(point2) // OK
</span></span></code></pre></div><p>java 、 c++ 等传统静态类型语言是基于 名义子类型 的，必须显示声明子类型关系(继承)，才可以兼容。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>public class Main {
</span></span><span style=display:flex><span>  public static void main (String[] args) {
</span></span><span style=display:flex><span>    getPointX(new Point()); // ok
</span></span><span style=display:flex><span>    getPointX(new ChildPoint()); // ok
</span></span><span style=display:flex><span>    getPointX(new Point1()); // error
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  public static void getPointX (Point point) {
</span></span><span style=display:flex><span>    System.out.println(point.x);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  static class Point {
</span></span><span style=display:flex><span>    public int x = 1;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  static class Point2 {
</span></span><span style=display:flex><span>    public int x = 2;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  static class ChildPoint extends Point {
</span></span><span style=display:flex><span>    public int x = 3;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=41-对象子类型>4.1 对象子类型<a hidden class=anchor aria-hidden=true href=#41-对象子类型>#</a></h4><p>子类型中必须包含源类型所有的属性和方法:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>function getPointX(point: { x: number }) {
</span></span><span style=display:flex><span>  return point.x
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>const point = {
</span></span><span style=display:flex><span>  x: 1,
</span></span><span style=display:flex><span>  y: &#39;2&#39;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>getPointX(point) // OK
</span></span></code></pre></div><p>注意，如果直接传入一个对象字面量是会报错的:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>function getPointX(point: { x: number }) {
</span></span><span style=display:flex><span>  return point.x
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>getPointX({ x: 1, y: &#39;2&#39; }) // error
</span></span></code></pre></div><p>这是 ts 中的另一个特性，叫做: <code>excess property check</code> ，当传入的参数是一个对象字面量时，会进行额外属性检查。</p><h4 id=42-协变与逆变>4.2 协变与逆变<a hidden class=anchor aria-hidden=true href=#42-协变与逆变>#</a></h4><p>介绍类型兼容和类型安全就非常有必要介绍一下逆变与协变的概念:</p><p>在介绍之前，先约定如下标记:</p><ul><li><code>A ≼ B</code> 表示A是B的子类型，A包含B的所有属性和方法。</li><li><code>A => B</code> 表示以 A 为参数，B 为返回值的方法。 (param: A) => B</li></ul><p><strong>一个问题</strong><br>如果我现在有三个类型 Animal 、 Dog 、 WangCai(旺财) ，那么肯定存在下面的关系: WangCai ≼ Dog ≼ Animal 即 旺财属于狗属于动物。</p><p>问题:以下哪种类型是 Dog => Dog 的子类呢?</p><ul><li>WangCai => WangCai</li><li>WangCai => Animal</li><li>Animal => Animal</li><li>Animal => WangCai</li></ul><p><strong>从代码来看</strong><br></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>class Animal {
</span></span><span style=display:flex><span>  sleep: Function
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>class Dog extends Animal {
</span></span><span style=display:flex><span>  // 吠
</span></span><span style=display:flex><span>  bark: Function
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>class WangCai extends Dog {
</span></span><span style=display:flex><span>  dance: Function
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>type DogCbFn = (dog: Dog) =&gt; Dog
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>function getDogName (cb: DogCbFn) {
</span></span><span style=display:flex><span>  const dog = new Dog()
</span></span><span style=display:flex><span>  const myDog = cb(dog)
</span></span><span style=display:flex><span>  myDog.bark()
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>const animal = new Animal()
</span></span><span style=display:flex><span>const wangcai = new WangCai()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>getDogName(wangcai =&gt; {
</span></span><span style=display:flex><span>  wangcai.dance()
</span></span><span style=display:flex><span>  return wangcai
</span></span><span style=display:flex><span>}) // error
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>getDogName(wangcai =&gt; {
</span></span><span style=display:flex><span>  wangcai.dance()
</span></span><span style=display:flex><span>  return animal
</span></span><span style=display:flex><span>}) // error
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>getDogName(animal =&gt; {
</span></span><span style=display:flex><span>  animal.sleep()
</span></span><span style=display:flex><span>  return wangcai
</span></span><span style=display:flex><span>}) // ok
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>getDogName(animal =&gt; {
</span></span><span style=display:flex><span>  animal.sleep()
</span></span><span style=display:flex><span>  return animal
</span></span><span style=display:flex><span>}) // error
</span></span></code></pre></div><p>可以看到只有 Animal => WangCai 才是 Dog => Dog 的子类型，可以得到一个结论，对于函数类型来说，函数参数的类型兼容是反向的，我们称之为 逆变 ，返回值的类型兼容是正向的，称之为 协变 。</p><h5 id=1-函数子类型>(1) 函数子类型<a hidden class=anchor aria-hidden=true href=#1-函数子类型>#</a></h5><p>上面逆变与协变的例子介绍了函数参数只有一个时的情况，如果函数参数有多个时该如何区分?</p><p>其实函数的参数可以转化为 Tuple 的类型兼容性:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>type Tuple1 = [string, number]
</span></span><span style=display:flex><span>type Tuple2 = [string, number, boolean]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>let tuple1: Tuple1 = [&#39;1&#39;, 1]
</span></span><span style=display:flex><span>let tuple2: Tuple2 = [&#39;1&#39;, 1, true]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>let t1: Tuple1 = tuple2 // ok
</span></span><span style=display:flex><span>let t2: Tuple2 = tuple1 // error
</span></span></code></pre></div><p>可以看到 Tuple2 => Tuple1 ，即长度大的是长度小的子类型，再由于函数参数的逆变特性，所以函数参数少的可以赋值给参数多的(参数从前往后需一一对应):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>[1, 2].forEach((item, index) =&gt; {
</span></span><span style=display:flex><span>  console.log(item)
</span></span><span style=display:flex><span>}) // ok
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>[1, 2].forEach((item, index, arr, other) =&gt; {
</span></span><span style=display:flex><span>  console.log(other)
</span></span><span style=display:flex><span>}) // error
</span></span></code></pre></div><h2 id=四接口>四、接口<a hidden class=anchor aria-hidden=true href=#四接口>#</a></h2><blockquote><p>写过java的同学应该都知道接口的概念，java中的接口是用来描述类的功能的</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>interface BabyInter {
</span></span><span style=display:flex><span>  void cry();
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>class Baby implements BabyInter {
</span></span><span style=display:flex><span>  @Override
</span></span><span style=display:flex><span>  public void cry() {
</span></span><span style=display:flex><span>    System.out.print(&#34;crying&#34;)
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>但是<code>ts</code>里面的接口还是有一点不一样的，同样是用来描述数据的结构，<code>ts</code>的接口不仅可以描述类，还可以描述变量，描述方法, 使用<code>interface</code>关键词来声明接口:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>interface BabyInter {
</span></span><span style=display:flex><span>  name: string,
</span></span><span style=display:flex><span>  cry () : void
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>let baby: BabyInter = {
</span></span><span style=display:flex><span>  name: &#39;apple&#39;,
</span></span><span style=display:flex><span>  cry () : void {
</span></span><span style=display:flex><span>    console.log(this.name + &#39;is crying&#39;)
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>let getBaby = () : BabyInter =&gt; {
</span></span><span style=display:flex><span>  return {
</span></span><span style=display:flex><span>    name: &#39;apple&#39;,
</span></span><span style=display:flex><span>    cry () {}
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=1可选属性>1、可选属性<a hidden class=anchor aria-hidden=true href=#1可选属性>#</a></h3><p>接口里的属性不全都是必需的，可以是可选的。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>interface FontStyleOptions {
</span></span><span style=display:flex><span>  size: number;
</span></span><span style=display:flex><span>  color?: string;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>const getFontStyle = (options: FontStyleOptions) =&gt; {
</span></span><span style=display:flex><span>  options.color = options.color || &#39;#000000&#39;
</span></span><span style=display:flex><span>  return options
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>const fontStyle = getFontStyle({
</span></span><span style=display:flex><span>  size: 16
</span></span><span style=display:flex><span>})
</span></span></code></pre></div><p>可选属性的好处之一是可以对可能存在的属性进行预定义，好处之二是在引用了不存在的属性时可以捕获错误。</p><h3 id=2可索引的类型>2、可索引的类型<a hidden class=anchor aria-hidden=true href=#2可索引的类型>#</a></h3><blockquote><p>额外的属性检查
如果<code>FontStyleOptions</code>接口中除了有<code>size</code>属性，还有一些不确定的其它属性，那么可以这样定义它:</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>interface FontStyleOptions {
</span></span><span style=display:flex><span>  size: number;
</span></span><span style=display:flex><span>  [prop: string]: number;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>let obj: FontStyleOptions = {
</span></span><span style=display:flex><span>  size: 16,
</span></span><span style=display:flex><span>  border: 1
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>obj.height = 18 // ok
</span></span><span style=display:flex><span>obj.background = &#39;#ffffff&#39; // error 不能将类型“&#34;#ffffff&#34;”分配给类型“number”
</span></span></code></pre></div><p>要注意的是，对于可索引的类型来说，索引签名的参数类型必须为 &ldquo;string&rdquo; 或 &ldquo;number&rdquo;:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>interface FontStyleOptions {
</span></span><span style=display:flex><span>  size: number;
</span></span><span style=display:flex><span>  [prop: boolean]: string; // error
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这也很容易理解，因为对象的键值要么是字符串要么是数字。 还要注意的是，索引的类型必须是其他属性的联合类型:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>interface FontStyleOptions {
</span></span><span style=display:flex><span>  size: number; // error 类型“number”的属性“size”不能赋给字符串索引类型“string”
</span></span><span style=display:flex><span>  [prop: string]: string;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>interface FontStyleOptions {
</span></span><span style=display:flex><span>  size: number;
</span></span><span style=display:flex><span>  [prop: string]: string | number; // ok
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=五类>五、类<a hidden class=anchor aria-hidden=true href=#五类>#</a></h2><h3 id=1继承>1、继承<a hidden class=anchor aria-hidden=true href=#1继承>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>class Animal {
</span></span><span style=display:flex><span>    name: string;
</span></span><span style=display:flex><span>    constructor(theName: string) { this.name = theName; }
</span></span><span style=display:flex><span>    move(distanceInMeters: number = 0) {
</span></span><span style=display:flex><span>        console.log(`${this.name} moved ${distanceInMeters}m.`);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>class Snake extends Animal {
</span></span><span style=display:flex><span>    constructor(name: string) { super(name); }
</span></span><span style=display:flex><span>    move(distanceInMeters = 5) {
</span></span><span style=display:flex><span>        console.log(&#34;Slithering...&#34;);
</span></span><span style=display:flex><span>        super.move(distanceInMeters);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>class Horse extends Animal {
</span></span><span style=display:flex><span>    constructor(name: string) { super(name); }
</span></span><span style=display:flex><span>    move(distanceInMeters = 45) {
</span></span><span style=display:flex><span>        console.log(&#34;Galloping...&#34;);
</span></span><span style=display:flex><span>        super.move(distanceInMeters);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>let sam = new Snake(&#34;Sammy the Python&#34;);
</span></span><span style=display:flex><span>let tom: Animal = new Horse(&#34;Tommy the Palomino&#34;);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>sam.move();
</span></span><span style=display:flex><span>tom.move(34);
</span></span></code></pre></div><p>输出</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>Slithering...
</span></span><span style=display:flex><span>Sammy the Python moved 5m.
</span></span><span style=display:flex><span>Galloping...
</span></span><span style=display:flex><span>Tommy the Palomino moved 34m.
</span></span></code></pre></div><p><strong>关键点</strong></p><ul><li>使用<code>extends</code>关键字创建了Animal的两个子类： Horse和 Snake</li><li>派生类包含了一个构造函数，它必须调用 <code>super()</code>，它会执行基类的构造函数。 而且，在构造函数里访问 this的属性之前，一定要调用 <code>super()</code></li><li><code>重写</code>从 Animal继承来的 move方法，使得 move方法根据不同的类而具有不同的功能</li></ul><p>ts中的类和es6的类没有什么太大的区别，主要是增加了类成员和方法的修饰符(private, protected, public)和对接口的实现。</p><h3 id=2修饰符>2、修饰符<a hidden class=anchor aria-hidden=true href=#2修饰符>#</a></h3><ul><li><code>public</code> 修饰符: 类成员和方法能在该类和该类的子类中被使用，也能在外部被使用。TypeScript里，成员都默认为 public</li><li><code>private</code> 修饰符: 类成员和方法只能在该类中被使用，不能在外部被使用。</li><li><code>protected</code> 修饰符: 类成员和方法只能在该类和该类的子类中被使用，不能在外部被使用。</li><li><code>readonly</code>关键字将属性设置为只读的，只读属性必须在声明时或构造函数里被初始化</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>class Person {
</span></span><span style=display:flex><span>  private age: number
</span></span><span style=display:flex><span>  protected name: string
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  constructor (name: string, age: number) {
</span></span><span style=display:flex><span>    this.name = name
</span></span><span style=display:flex><span>    this.age = age
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>class Student extends Person {
</span></span><span style=display:flex><span>  constructor (name: string, age: number) {
</span></span><span style=display:flex><span>    super(name, age)
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  learn () :void {
</span></span><span style=display:flex><span>    console.log(this.name + &#39;is learning&#39;) // ok console.log(this.age) // error
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>let student = new Student(&#39;Lucy&#39;, 18)
</span></span><span style=display:flex><span>student.name // error
</span></span></code></pre></div><p><strong>注意</strong><br>如果其中一个类型里包含一个 private成员，那么只有当另外一个类型中也存在这样一个 private成员， 并且它们都是来自同一处声明时，我们才认为这两个类型是兼容的。 对于 protected成员也使用这个规则</p><h3 id=3存取器>3、存取器<a hidden class=anchor aria-hidden=true href=#3存取器>#</a></h3><blockquote><p>通过getters/setters来截取对对象成员的访问。 它能帮助你有效的控制对对象成员的访问</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>let passcode = &#34;secret passcode&#34;;
</span></span><span style=display:flex><span>class Employee {
</span></span><span style=display:flex><span>    private _fullName: string;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    get fullName(): string {
</span></span><span style=display:flex><span>        return this._fullName;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    set fullName(newName: string) {
</span></span><span style=display:flex><span>        if (passcode &amp;&amp; passcode == &#34;secret passcode&#34;) {
</span></span><span style=display:flex><span>            this._fullName = newName;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        else {
</span></span><span style=display:flex><span>            console.log(&#34;Error: Unauthorized update of employee!&#34;);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>let employee = new Employee();
</span></span><span style=display:flex><span>employee.fullName = &#34;Bob Smith&#34;;
</span></span><span style=display:flex><span>if (employee.fullName) {
</span></span><span style=display:flex><span>    alert(employee.fullName);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>注意</strong></p><ul><li>存取器要求将编译器设置为输出ECMAScript 5或更高。 不支持降级到ECMAScript 3</li><li>只带有 get不带有 set的存取器自动被推断为 readonly（这在从代码生成 .d.ts文件时是有帮助的，因为利用这个属性的用户会看到不允许够改变它的值）</li></ul><h3 id=4静态属性>4、静态属性<a hidden class=anchor aria-hidden=true href=#4静态属性>#</a></h3><blockquote><p>前面讨论了类的实例成员，那些仅当类被实例化的时候才会被初始化的属性。 我们也可以使用<code>static</code>关键词创建类的静态成员，这些属性存在于类本身上面而不是类的实例上</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>class Grid {
</span></span><span style=display:flex><span>    static origin = {x: 0, y: 0};
</span></span><span style=display:flex><span>    calculateDistanceFromOrigin(point: {x: number; y: number;}) {
</span></span><span style=display:flex><span>        let xDist = (point.x - Grid.origin.x);
</span></span><span style=display:flex><span>        let yDist = (point.y - Grid.origin.y);
</span></span><span style=display:flex><span>        return Math.sqrt(xDist * xDist + yDist * yDist) / this.scale;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    constructor (public scale: number) { }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>let grid1 = new Grid(1.0);  // 1x scale
</span></span><span style=display:flex><span>let grid2 = new Grid(5.0);  // 5x scale
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>console.log(grid1.calculateDistanceFromOrigin({x: 10, y: 10}));
</span></span><span style=display:flex><span>console.log(grid2.calculateDistanceFromOrigin({x: 10, y: 10}));
</span></span></code></pre></div><h3 id=5抽象类>5、抽象类<a hidden class=anchor aria-hidden=true href=#5抽象类>#</a></h3><ul><li>抽象类做为其它派生类的基类使用。一般不会直接被实例化</li><li>不同于接口，抽象类可以包含成员的实现细节</li><li>abstract关键字是用于定义抽象类和在抽象类内部定义抽象方法</li><li>抽象类中的抽象方法不包含具体实现并且必须在派生类中实现</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>abstract class Department {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    constructor(public name: string) {
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    printName(): void {
</span></span><span style=display:flex><span>        console.log(&#39;Department name: &#39; + this.name);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    abstract printMeeting(): void; // 必须在派生类中实现
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>class AccountingDepartment extends Department {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    constructor() {
</span></span><span style=display:flex><span>        super(&#39;Accounting and Auditing&#39;); // 在派生类的构造函数中必须调用 super()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    printMeeting(): void {
</span></span><span style=display:flex><span>        console.log(&#39;The Accounting Department meets each Monday at 10am.&#39;);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    generateReports(): void {
</span></span><span style=display:flex><span>        console.log(&#39;Generating accounting reports...&#39;);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>let department: AccountingDepartment = new AccountingDepartment(); // 允许对一个抽象子类进行实例化和赋值
</span></span><span style=display:flex><span>department.printName();
</span></span><span style=display:flex><span>department.printMeeting();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>let department2: Department; // 允许创建一个对抽象类型的引用
</span></span><span style=display:flex><span>department2 = new Department(); // 错误: 不能创建一个抽象类的实例
</span></span><span style=display:flex><span>department2.generateReports(); // 错误: 方法在声明的抽象类中不存在
</span></span></code></pre></div><h3 id=6类和接口>6、类和接口<a hidden class=anchor aria-hidden=true href=#6类和接口>#</a></h3><p>ts中类可以使用关键词<code>implements</code>来实现接口:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>interface BabyInter {
</span></span><span style=display:flex><span>  name: string
</span></span><span style=display:flex><span>  cry () : void
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>class Baby implements BabyInter {
</span></span><span style=display:flex><span>  name: string
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  constructor (name: string) {
</span></span><span style=display:flex><span>    this.name = name
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  cry () :void {
</span></span><span style=display:flex><span>    console.log(this.name + &#39;is crying&#39;)
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>如果 Baby 类中没有声明 cry 方法会怎样:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>interface BabyInter {
</span></span><span style=display:flex><span>  name: string
</span></span><span style=display:flex><span>  cry () : void
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>class Baby implements BabyInter {
</span></span><span style=display:flex><span>  name: string
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  constructor (name: string) {
</span></span><span style=display:flex><span>    this.name = name
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><blockquote><p>会报一个编译错误: <code>[ts] 类“Baby”错误实现接口“BabyInter”。类型“Baby”中缺少属性“cry”。</code></p></blockquote><h2 id=六函数>六、函数<a hidden class=anchor aria-hidden=true href=#六函数>#</a></h2><h3 id=1函数类型>1、函数类型<a hidden class=anchor aria-hidden=true href=#1函数类型>#</a></h3><h4 id=1-几种函数类型的返回值类型写法>(1) 几种函数类型的返回值类型写法<a hidden class=anchor aria-hidden=true href=#1-几种函数类型的返回值类型写法>#</a></h4><blockquote><p>记住在 () 后面添加返回值类型即可</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>function fn(): number {
</span></span><span style=display:flex><span>  return 1
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>const fn = function (): number {
</span></span><span style=display:flex><span>  return 1
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>const fn = (): number =&gt; {
</span></span><span style=display:flex><span>  return 1
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>const obj = {
</span></span><span style=display:flex><span>  fn (): number {
</span></span><span style=display:flex><span>    return 1
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=2-函数类型>(2) 函数类型<a hidden class=anchor aria-hidden=true href=#2-函数类型>#</a></h4><p>ts 中也有函数类型，用来描述一个函数:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>type FnType = (x: number, y: number) =&gt; number
</span></span></code></pre></div><p><strong>完整的函数写法</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>let myAdd: (x: number, y: number) =&gt; number = function(x: number, y: number): number {
</span></span><span style=display:flex><span>  return x + y
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>// 使用 FnType
</span></span><span style=display:flex><span>let myAdd: FnType = function(x: number, y: number): number {
</span></span><span style=display:flex><span>  return x + y
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>// ts 自动推导参数类型
</span></span><span style=display:flex><span>let myAdd: FnType = function(x, y) {
</span></span><span style=display:flex><span>  return x + y
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=2函数重载>2、函数重载<code>?</code><a hidden class=anchor aria-hidden=true href=#2函数重载>#</a></h3><p>js因为是动态类型，本身不需要支持重载，ts为了保证类型安全，支持了函数签名的类型重载。即:</p><p>多个 <code>重载签名</code> 和一个 <code>实现签名</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>function len(s: string): string;
</span></span><span style=display:flex><span>function len(arr: any[]): number;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>function len(x: string | any[]) {
</span></span><span style=display:flex><span>  if (typeof x === &#39;string&#39;) {
</span></span><span style=display:flex><span>    return x.length.toString()
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  return x.length
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>let a = len(&#39;&#39;).trim() // error
</span></span><span style=display:flex><span>let b = len([]).toFixed(2) // ok
</span></span><span style=display:flex><span>let c = len(2) // error
</span></span></code></pre></div><p>ts 函数重载的其他特性:</p><ul><li>如果定义了 <code>重载签名</code> ，则 <code>实现签名</code> 对外不可见</li><li><code>实现签名</code> 必须兼容 <code>重载签名</code></li><li><code>重载签名</code> 的类型不会合并</li></ul><blockquote><p>TS 中的函数重载其实并不是真的重载。</p></blockquote><p><a id=ts-01-06></a></p><h2 id=七泛型>七、泛型<a hidden class=anchor aria-hidden=true href=#七泛型>#</a></h2><h3 id=1什么是泛型>1、什么是泛型<a hidden class=anchor aria-hidden=true href=#1什么是泛型>#</a></h3><p>软件工程中，我们不仅要创建一致的定义良好的API，同时也要考虑代码块的重用性。 组件不仅能够支持当前的数据类型，同时也能支持未来的数据类型。</p><p>通过字面意思来看，泛型有“广泛的类型”之意，即数据的类型也可以通过一个变量来动态确定，一般用 <code>&lt;></code> 操作符来声明泛型的使用。</p><p><strong>小试牛刀</strong><br>// 泛型方法</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>function createList&lt;T&gt;(): T[] {
</span></span><span style=display:flex><span>  return [] as T[]
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>const numberList = createList&lt;number&gt;() // number[]
</span></span><span style=display:flex><span>const stringList = createList&lt;string&gt;() // string[]
</span></span></code></pre></div><h3 id=2泛型接口>2、泛型接口<a hidden class=anchor aria-hidden=true href=#2泛型接口>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>interface GenericIdentityFn&lt;T&gt; {
</span></span><span style=display:flex><span>    (arg: T): T;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>function identity&lt;T&gt;(arg: T): T {
</span></span><span style=display:flex><span>    return arg;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>let myIdentity: GenericIdentityFn&lt;number&gt; = identity;
</span></span></code></pre></div><h3 id=3泛型类>3、泛型类<a hidden class=anchor aria-hidden=true href=#3泛型类>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>// 泛型类的定义
</span></span><span style=display:flex><span>class ArrayList&lt;T&gt; {
</span></span><span style=display:flex><span>  list: T[]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  push (item: T) :void {
</span></span><span style=display:flex><span>    this.list.push(item)
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  pop () :T {
</span></span><span style=display:flex><span>    return this.list.pop()
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>// 泛型类的使用
</span></span><span style=display:flex><span>const list = new ArrayList&lt;string&gt;()
</span></span><span style=display:flex><span>list.push(&#39;hello&#39;) // ok
</span></span><span style=display:flex><span>list.push(1) //error
</span></span></code></pre></div><p>小知识:K，V，T，E等泛型名称不是固定写死了，是可以随意定义的，为了语义化，是有特殊含义的:</p><ul><li><code>T</code>表示 <code>type</code> 类型。</li><li><code>K、V</code>:分别代表键值中的 <code>Key、Value</code>。</li><li><code>E</code>:表示 enum 枚举。</li></ul><h3 id=4泛型约束>4、泛型约束<a hidden class=anchor aria-hidden=true href=#4泛型约束>#</a></h3><p>如果我们只希望 createList 函数只能生成指定的类型数组，该如何做，可以使用 <code>extends</code> 关键词来约束泛型的范围和形状。</p><blockquote><p>此时 extends 约束的是输入值</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>interface Lengthwise {
</span></span><span style=display:flex><span>  length: number
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>function createList&lt;T extends string | number | Lengthwise&gt;(): T[] {
</span></span><span style=display:flex><span>  return [] as T[]
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>const numberList = createList&lt;number&gt;() // ok
</span></span><span style=display:flex><span>const arrayList = createList&lt;any[1, 2, 3]&gt;() // ok
</span></span><span style=display:flex><span>const stringList = createList&lt;boolean&gt;() // error
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>console.log(numberList) // []
</span></span><span style=display:flex><span>console.log(arrayList) // []
</span></span></code></pre></div><h4 id=41-条件控制>4.1 条件控制<a hidden class=anchor aria-hidden=true href=#41-条件控制>#</a></h4><p><code>extends</code> 除了做约束类型，还可以做条件控制，相当于与一个三元运算符，只不过是针对类型的。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>T extends U ? X : Y
</span></span></code></pre></div><p>如果 T 可以被分配给 U，则返回 X，否则返回 Y。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>type IsNumber&lt;T&gt; = T extends number ? true : false
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>type x = IsNumber&lt;string&gt; // false
</span></span></code></pre></div><p><a id=ts-02-03></a></p><h4 id=42-类型映射>4.2 类型映射<a hidden class=anchor aria-hidden=true href=#42-类型映射>#</a></h4><p>类型映射相当与一个类型的函数，可以做一些类型运算，输入一个类型，输出另一个类型，前文我们举了个 <code>Copy</code> 的例子。</p><h5 id=1-内置的映射类型>(1) 内置的映射类型<a hidden class=anchor aria-hidden=true href=#1-内置的映射类型>#</a></h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>// 每一个属性都变成可选
</span></span><span style=display:flex><span>type Partial&lt;T&gt; = {
</span></span><span style=display:flex><span>  [P in keyof T]?: T[P]
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>// 每一个属性都变成可选
</span></span><span style=display:flex><span>type Readonly&lt;T&gt; = {
</span></span><span style=display:flex><span>  readonly [P in keyof T]: T[P]
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>// 选则对象中的某些属性
</span></span><span style=display:flex><span>type Pick&lt;T, K extends keyof T&gt; = {
</span></span><span style=display:flex><span>  [P in K]: T[P];
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>// ......
</span></span></code></pre></div><p>typescript 2.8 在 lib.d.ts 中内置了几个映射类型:</p><ul><li><code>Exclude&lt;T, U></code> &ndash; 从 T 中剔除可以赋值给 U 的类型。</li><li><code>Extract&lt;T, U></code> &ndash; 提取 T 中可以赋值给 U 的类型。</li><li><code>NonNullable&lt;T></code> &ndash; 从 T 中剔除 null 和 undefined 。</li><li><code>ReturnType&lt;T></code> &ndash; 获取函数返回值类型。</li><li><code>InstanceType&lt;T></code> &ndash; 获取构造函数类型的实例类型。</li></ul><h5 id=2-extends-条件分发>(2) extends 条件分发<a hidden class=anchor aria-hidden=true href=#2-extends-条件分发>#</a></h5><p>对于 <code>T extends U ? X : Y</code> 来说，还存在一个特性，当 T 是一个联合类型时，会进行条件分发。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>type Union = string | number
</span></span><span style=display:flex><span>type ParamType&lt;T&gt; = T extends number ? &#39;isNumber&#39; : &#39;isString&#39;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>type UnionType = ParamType&lt;Union&gt; // &#39;isNumber&#39; | &#39;isString&#39;
</span></span></code></pre></div><p>实际上，extends 运算会变成如下形式:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span> (string extends number ? &#39;number&#39; : &#39;string&#39;) | (number extends number ? &#39;number&#39; : &#39;string&#39;)
</span></span></code></pre></div><p><code>Extract</code> 就是基于此特性实现的，再配合 never 幺元的特性:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>type Exclude&lt;T, K&gt; = T extends K ? never : T
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>type T1 = Exclude&lt;string | number | boolean, string | boolean&gt; // number
</span></span></code></pre></div><h5 id=3-infer-关键词>(3) infer 关键词<a hidden class=anchor aria-hidden=true href=#3-infer-关键词>#</a></h5><blockquote><p>infer 关键词常在条件类型中和 extends 关键词一同出现，表示将要推断的类型，作为类型变量可以在三元表达式的 True 部分引用</p></blockquote><p>ts 中内置的一个映射类型 <code>ReturnType</code> ，用于获取函数类型的返回值:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>function len (str: string) {
</span></span><span style=display:flex><span>  return str.length
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>type LenFn = typeof len // (str: string) =&gt; number
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>type LenFnReturn = ReturnType&lt;LenFn&gt; // number
</span></span></code></pre></div><p>ReturnType 的实现:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>type ReturnType&lt;T extends (...args: any) =&gt; any&gt; = T extends (...args: any) =&gt; infer R ? R : any;
</span></span></code></pre></div><h2 id=八模块>八、模块<a hidden class=anchor aria-hidden=true href=#八模块>#</a></h2><h3 id=1全局模块-vs-文件模块>1、全局模块 vs. 文件模块<a hidden class=anchor aria-hidden=true href=#1全局模块-vs-文件模块>#</a></h3><p>默认情况下，我们所写的代码是位于全局模块下的:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>const foo = 2
</span></span></code></pre></div><p>此时，如果我们创建了另一个文件，并写下如下代码，ts 认为是正常的:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>const bar = foo // ok
</span></span></code></pre></div><p>如果要打破这种限制，只要文件中有 import 或者 export 表达式即可:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>export const bar = foo // error
</span></span></code></pre></div><h3 id=2模块解析策略>2、模块解析策略<a hidden class=anchor aria-hidden=true href=#2模块解析策略>#</a></h3><p>Tpescript 有两种模块的解析策略: <a href=https://www.tslang.cn/docs/handbook/module-resolution.html#node>Node</a> 和 <a href=https://www.tslang.cn/docs/handbook/module-resolution.html#classic>Classic</a> 。</p><p>当 <code>tsconfig.json</code> 中 <code>module</code> 设置成 <code>AMD</code>、<code>System</code>、<code>ES2015</code> 时，默认为 <code>classic</code> ，否则为 <code>Node</code> ，也可以使用 <code>moduleResolution</code> 手动指定模块解析策略。</p><p>两种模块解析策略的区别在于:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>import { a } from &#39;moduleB&#39;
</span></span></code></pre></div><p><code>Classic</code>:</p><ul><li><code>/root/src/folder/moduleB.ts</code></li><li><code>/root/src/folder/moduleB.d.ts</code></li><li><code>/root/src/moduleB.ts</code></li><li><code>/root/src/moduleB.d.ts</code></li><li><code>/root/moduleB.ts</code></li><li><code>/root/moduleB.d.ts</code></li><li><code>/moduleB.ts</code></li><li><code>/moduleB.d.ts</code></li></ul><p><code>Node</code>:</p><ul><li><code>/root/src/node_modules/moduleB.ts</code></li><li><code>/root/src/node_modules/moduleB.tsx</code></li><li><code>/root/src/node_modules/moduleB.d.ts</code></li><li><code>/root/src/node_modules/moduleB/package.json</code> (如果指定了"types"属性)</li><li><code>/root/src/node_modules/moduleB/index.ts</code></li><li><code>/root/src/node_modules/moduleB/index.tsx</code></li><li><code>/root/src/node_modules/moduleB/index.d.ts</code></li><li><code>/root/node_modules/moduleB.ts</code></li><li><code>/root/node_modules/moduleB.tsx</code></li><li><code>/root/node_modules/moduleB.d.ts</code></li><li><code>/root/node_modules/moduleB/package.json</code> (如果指定了"types"属性)</li><li><code>/root/node_modules/moduleB/index.ts</code></li><li><code>/root/node_modules/moduleB/index.tsx</code></li><li><code>/root/node_modules/moduleB/index.d.ts</code></li><li><code>/node_modules/moduleB.ts</code></li><li><code>/node_modules/moduleB.tsx</code></li><li><code>/node_modules/moduleB.d.ts</code></li><li><code>/node_modules/moduleB/package.json</code> (如果指定了"types"属性)</li><li><code>/node_modules/moduleB/index.ts</code></li><li><code>/node_modules/moduleB/index.tsx</code></li><li><code>/node_modules/moduleB/index.d.ts</code></li></ul><hr><p>参考:</p><ul><li><a href=https://www.yuque.com/fed/share/eggmow>可参考文章-语雀</a></li><li><a href=https://www.tslang.cn/docs/handbook/typescript-in-5-minutes.html>TypeScript官方文档</a></li></ul><hr><p><strong>最后， 希望大家早日实现：成为编程高手的伟大梦想！</strong><br><strong>欢迎交流~</strong></p><img src=/img-common/weChatPublic.jpg alt=微信公众号 width=600 height=286><p><strong>本文版权归原作者曜灵所有！未经允许，严禁转载！对非法转载者, 原作者保留采用法律手段追究的权利！</strong><br><strong>若需转载，请联系微信公众号：连先生有猫病，可获取作者联系方式！</strong></p></div><footer class=post-footer><nav class=paginav><a class=prev href=https://lianpf.github.io/posts/frontend-develop/vue3-composition-api-and-main-attrs/><span class=title>« 上一页</span><br><span>vue3+ts(3)：vue3组合式api及重要属性变更</span></a>
<a class=next href=https://lianpf.github.io/posts/frontend-develop/10.vue3%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/><span class=title>下一页 »</span><br><span>vue3+ts(1)：vue3项目从0到1搭建</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share vue3+ts(2)：TypeScript 语法汇总 on twitter" href="https://twitter.com/intent/tweet/?text=vue3%2bts%282%29%ef%bc%9aTypeScript%20%e8%af%ad%e6%b3%95%e6%b1%87%e6%80%bb&amp;url=https%3a%2f%2flianpf.github.io%2fposts%2ffrontend-develop%2f03.ts-basic-grammar%2f&amp;hashtags=TS"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share vue3+ts(2)：TypeScript 语法汇总 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2flianpf.github.io%2fposts%2ffrontend-develop%2f03.ts-basic-grammar%2f&amp;title=vue3%2bts%282%29%ef%bc%9aTypeScript%20%e8%af%ad%e6%b3%95%e6%b1%87%e6%80%bb&amp;summary=vue3%2bts%282%29%ef%bc%9aTypeScript%20%e8%af%ad%e6%b3%95%e6%b1%87%e6%80%bb&amp;source=https%3a%2f%2flianpf.github.io%2fposts%2ffrontend-develop%2f03.ts-basic-grammar%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share vue3+ts(2)：TypeScript 语法汇总 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2flianpf.github.io%2fposts%2ffrontend-develop%2f03.ts-basic-grammar%2f&title=vue3%2bts%282%29%ef%bc%9aTypeScript%20%e8%af%ad%e6%b3%95%e6%b1%87%e6%80%bb"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share vue3+ts(2)：TypeScript 语法汇总 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2flianpf.github.io%2fposts%2ffrontend-develop%2f03.ts-basic-grammar%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share vue3+ts(2)：TypeScript 语法汇总 on whatsapp" href="https://api.whatsapp.com/send?text=vue3%2bts%282%29%ef%bc%9aTypeScript%20%e8%af%ad%e6%b3%95%e6%b1%87%e6%80%bb%20-%20https%3a%2f%2flianpf.github.io%2fposts%2ffrontend-develop%2f03.ts-basic-grammar%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share vue3+ts(2)：TypeScript 语法汇总 on telegram" href="https://telegram.me/share/url?text=vue3%2bts%282%29%ef%bc%9aTypeScript%20%e8%af%ad%e6%b3%95%e6%b1%87%e6%80%bb&amp;url=https%3a%2f%2flianpf.github.io%2fposts%2ffrontend-develop%2f03.ts-basic-grammar%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></div><script src=https://utteranc.es/client.js repo=lianpf/lianpf.github.io issue-term=title label=comments theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>Copyright
&copy;
2016-2024
<a href=https://lianpf.github.io/ style=color:#939393>曜灵（SUN）Site</a>.
基于 Hugo 引擎和 PaperMod 主题</span>
<a href=https://beian.miit.gov.cn/ target=_blank style=color:#939393></a>&nbsp;</footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><span class=topInner><svg class="topSvg" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg><span id=read_progress></span></span></a>
<script>document.addEventListener("scroll",function(){const t=document.getElementById("read_progress"),n=document.documentElement.scrollHeight,s=document.documentElement.clientHeight,o=document.documentElement.scrollTop||document.body.scrollTop;t.innerText=((o/(n-s)).toFixed(2)*100).toFixed(0)})</script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>let mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>200||document.documentElement.scrollTop>200?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{(function(){document.cookie="change-themes="+escape("false")})(),document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.body.addEventListener("copy",function(e){if(window.getSelection().toString()&&window.getSelection().toString().length>50){let t=e.clipboardData||window.clipboardData;if(t){e.preventDefault();let n=window.getSelection().toString()+`

————————————————
版权声明：本文为「曜灵（SUN）Site」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：`+location.href,s=window.getSelection().toString()+`

————————————————
版权声明：本文为「曜灵（SUN）Site」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：`+location.href;t.setData("text/html",n),t.setData("text/plain",s)}}})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const s=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="复制";function i(){t.innerText="已复制！",setTimeout(()=>{t.innerText="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){let t=e.textContent+`
————————————————
版权声明：本文为「曜灵（SUN）Site」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：`+location.href;navigator.clipboard.writeText(t),i();return}const n=document.createRange();n.selectNodeContents(e);const s=window.getSelection();s.removeAllRanges(),s.addRange(n);try{document.execCommand("copy"),i()}catch{}s.removeRange(n)});let l=e.className.replaceAll("language-",""),n=document.createElement("div"),a=document.createElement("div"),r=document.createElement("div"),c=document.createElement("div"),o=document.createElement("div");o.innerText=l,n.setAttribute("class","mac-tool"),a.setAttribute("class","mac bb1"),r.setAttribute("class","mac bb2"),c.setAttribute("class","mac bb3"),o.setAttribute("class","language-type"),n.appendChild(a),n.appendChild(r),n.appendChild(c),n.appendChild(o),s.classList.contains("highlight")?(s.appendChild(t),s.appendChild(n)):s.parentNode.firstChild==s||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?(e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t),s.appendChild(n)):(e.parentNode.appendChild(t),s.appendChild(n)))})</script></body></html>