<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>对比 React Hooks 和 Vue Composition API | 曜灵（SUN）Site</title><meta name=keywords content="JS,React技术栈,Vue技术栈"><meta name=description content="目录 场景 hook 的时代意义 React Hooks Vue Composition API 差别 总结 场景 先理解&mldr;"><meta name=author content="曜灵"><link rel=canonical href=https://lianpf.github.io/posts/frontend-develop/react-hooks-compare-vue-composition-api/><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.js onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://lianpf.github.io/img-common/favicon.png><link rel=icon type=image/png sizes=16x16 href=https://lianpf.github.io/img-common/favicon.png><link rel=icon type=image/png sizes=32x32 href=https://lianpf.github.io/img-common/favicon.png><link rel=apple-touch-icon href=https://lianpf.github.io/img-common/avatar.jpeg><link rel=mask-icon href=https://lianpf.github.io/img-common/avatar.jpeg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css><script src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script>
<script src=https://cdn.jsdelivr.net/npm/jquery@3.6.3/dist/jquery.min.js></script>
<script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script><meta property="og:title" content="对比 React Hooks 和 Vue Composition API"><meta property="og:description" content="目录 场景 hook 的时代意义 React Hooks Vue Composition API 差别 总结 场景 先理解&mldr;"><meta property="og:type" content="article"><meta property="og:url" content="https://lianpf.github.io/posts/frontend-develop/react-hooks-compare-vue-composition-api/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-07-06T00:00:00+00:00"><meta property="article:modified_time" content="2020-09-04T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="对比 React Hooks 和 Vue Composition API"><meta name=twitter:description content="目录 场景 hook 的时代意义 React Hooks Vue Composition API 差别 总结 场景 先理解&mldr;"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"📚文章","item":"https://lianpf.github.io/posts/"},{"@type":"ListItem","position":2,"name":"👨🏻‍💻 前端","item":"https://lianpf.github.io/posts/frontend-develop/"},{"@type":"ListItem","position":3,"name":"对比 React Hooks 和 Vue Composition API","item":"https://lianpf.github.io/posts/frontend-develop/react-hooks-compare-vue-composition-api/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"对比 React Hooks 和 Vue Composition API","name":"对比 React Hooks 和 Vue Composition API","description":"目录 场景 hook 的时代意义 React Hooks Vue Composition API 差别 总结 场景 先理解\u0026hellip;\n","keywords":["JS","React技术栈","Vue技术栈"],"articleBody":"目录 场景 hook 的时代意义 React Hooks Vue Composition API 差别 总结 场景 先理解…\n目录\n场景 hook 的时代意义 React Hooks Vue Composition API 差别 总结 场景 先理解什么是hook，拿react的介绍来看，它的定义是：\n它可以让你在不编写 class 的情况下，让你在函数组件里“钩入” React state 及生命周期等特性的函数\n对于 Vue 提出的新的书写 Vue 组件的 API：Composition API RFC，作用也是类似，所以我们也可以像react一样叫做 vue hooks\n该 API 受到 React Hooks 的启发 但有一些有趣的差异，规避了一些react的问题 hook的时代意义 框架是服务于业务的，业务中很难避免的一个问题就是 – 逻辑复用，同样的功能，同样的组件，在不一样的场合下，我们有时候不得不去写2+次，为了避免耦合，后来各大框架纷纷想出了一些办法，比如 minix, render props, 高阶组件等实现逻辑上的复用，但是都有一些额外的问题\nminix 与组件之间存在隐式依赖，可能产生冲突。倾向于增加更多状态，降低了应用的可预测性 高阶组件 多层包裹嵌套组件，增加了复杂度和理解成本，对于外层是黑盒 Render Props 使用繁琐，不好维护, 代码体积过大，同样容易嵌套过深 … hook的出现是划时代的，通过function抽离的方式，实现了复杂逻辑的内部封装：\n逻辑代码的复用 减小了代码体积 没有this的烦恼 React Hooks React Hooks 允许你 “勾入” 诸如组件状态和副作用处理等 React 功能中。Hooks 只能用在函数组件中，并允许我们在不需要创建类的情况下将状态、副作用处理和更多东西带入组件中。\nReact 核心团队奉上的采纳策略是不反对类组件，所以你可以升级 React 版本、在新组件中开始尝试 Hooks，并保持既有组件不做任何更改\n例子：\nimport React, { useState, useEffect } from \"react\"; const NoteForm = ({ onNoteSent }) =\u003e { const [currentNote, setCurrentNote] = useState(\"\"); useEffect(() =\u003e { console.log(`Current note: ${currentNote}`); }); return ( ","wordCount":"4852","inLanguage":"zh","datePublished":"2020-07-06T00:00:00Z","dateModified":"2020-09-04T00:00:00Z","author":{"@type":"Person","name":"曜灵"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://lianpf.github.io/posts/frontend-develop/react-hooks-compare-vue-composition-api/"},"publisher":{"@type":"Organization","name":"曜灵（SUN）Site","logo":{"@type":"ImageObject","url":"https://lianpf.github.io/img-common/favicon.png"}}}</script></head><body id=top><script>(function(){let e,t=new RegExp("(^| )change-themes=([^;]*)(;|$)");(e=document.cookie.match(t))||((new Date).getHours()>=19||(new Date).getHours()<6?(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark")):(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")))})(),localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://lianpf.github.io/ accesskey=h title="曜灵（SUN）Site (Alt + H)"><img src=https://lianpf.github.io/img-common/avatar.jpeg alt=logo aria-label=logo height=35>曜灵（SUN）Site</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://lianpf.github.io/search title="🔍 搜索 (Alt + /)" accesskey=/><span>🔍 搜索</span></a></li><li><a href=https://lianpf.github.io/ title="🏠 主页"><span>🏠 主页</span></a></li><li><a href=https://lianpf.github.io/archives/ title="⏱️ 归档"><span>⏱️ 归档</span></a></li><li><a href=https://lianpf.github.io/tags title="🧩 标签"><span>🧩 标签</span></a></li><li><a href=https://lianpf.github.io/about title="🙋🏻‍♂️ 关于"><span>🙋🏻‍♂️ 关于</span></a></li></ul></nav></header><main class="main page"><style>i[id*=post_meta_style]{display:flex;align-items:center;margin:0 0 10px}</style><article class=post-single><div id=single-content><header class=post-header><div class=breadcrumbs><a href=https://lianpf.github.io/>🏠 主页</a>&nbsp;»&nbsp;<a href=https://lianpf.github.io/posts/>📚文章</a>&nbsp;»&nbsp;<a href=https://lianpf.github.io/posts/frontend-develop/>👨🏻‍💻 前端</a></div><h1 class=post-title>对比 React Hooks 和 Vue Composition API</h1><div class=post-meta><style>i[id*=post_meta_style]{display:flex;align-items:center;margin:0 0 10px}.parent-post-meta{display:flex;flex-wrap:wrap;opacity:.8}</style><span class=parent-post-meta><span id=post_meta_style_1><span class="fa fa-calendar-check-o"></span>
<span>2020-07-06
&nbsp;&nbsp;</span></span>
<span id=post_meta_style_3><span class="fa fa-file-word-o"></span>
<span>4852字
&nbsp;&nbsp;</span></span>
<span id=post_meta_style_4><span class="fa fa-clock-o"></span>
<span>10分钟
&nbsp;&nbsp;</span></span>
<span id=post_meta_style_5><span class="fa fa-user-o"></span>
<span>曜灵
&nbsp;&nbsp;</span></span>
<span id=post_meta_style_6><span class="fa fa-tags" style=opacity:.8></span>
<span><span class=post-tags-meta><a href=https://lianpf.github.io/tags/js/ style=color:var(--secondary)!important>JS</a>
&nbsp;<a href=https://lianpf.github.io/tags/react%E6%8A%80%E6%9C%AF%E6%A0%88/ style=color:var(--secondary)!important>React技术栈</a>
&nbsp;<a href=https://lianpf.github.io/tags/vue%E6%8A%80%E6%9C%AF%E6%A0%88/ style=color:var(--secondary)!important>Vue技术栈</a></span></span></span></span>
<span style=opacity:.8><span id=post_meta_style_7>&nbsp;&nbsp;
<span class="fa fa-eye"></span>
<span><span id=busuanzi_container_page_pv><span id=busuanzi_value_page_pv></span></span>
&nbsp;&nbsp;</span></span>
<span id=post_meta_style_8><span class="fa fa-commenting-o"></span>
<span><script src=https://cdn.staticfile.org/twikoo/1.5.8/twikoo.all.min.js></script>
<script>let url=document.documentURI,dnsUrl="https://lianpf.github.io/",urlSplit=url.split(dnsUrl),finalUrl=urlSplit[1];finalUrl[0]!=="/"&&(finalUrl="/"+finalUrl),twikoo.getCommentsCount({envId:null,region:null,urls:[finalUrl],includeReply:!1}).then(function(e){let t=e[0].count;const n=document.getElementById("comment_count");n.innerText=t}).catch(function(e){console.error(e)})</script><span id=comment_count></span></span></span></span></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#%e5%9c%ba%e6%99%af aria-label=场景>场景</a></li><li><a href=#hook%e7%9a%84%e6%97%b6%e4%bb%a3%e6%84%8f%e4%b9%89 aria-label=hook的时代意义>hook的时代意义</a></li><li><a href=#react-hooks aria-label="React Hooks">React Hooks</a><ul><li><a href=#vue-composition-api aria-label="Vue Composition API">Vue Composition API</a></li></ul></li><li><a href=#%e5%b7%ae%e5%88%ab aria-label=差别>差别</a><ul><li><a href=#%e5%8e%9f%e7%90%86 aria-label=原理>原理</a></li><li><a href=#%e4%bb%a3%e7%a0%81%e7%9a%84%e6%89%a7%e8%a1%8c aria-label=代码的执行>代码的执行</a></li><li><a href=#%e5%a3%b0%e6%98%8e%e7%8a%b6%e6%80%81declaring-state aria-label="声明状态(Declaring state)">声明状态(Declaring state)</a><ul><ul><li><a href=#react aria-label=react>react</a></li><li><a href=#vue aria-label=Vue>Vue</a></li></ul></ul></li><li><a href=#%e5%a6%82%e4%bd%95%e8%b7%9f%e8%b8%aa%e4%be%9d%e8%b5%96how-to-track-dependencies aria-label="如何跟踪依赖(How to track dependencies)">如何跟踪依赖(How to track dependencies)</a></li><li><a href=#%e8%ae%bf%e9%97%ae%e7%bb%84%e4%bb%b6%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9faccess-to-the-lifecycle-of-the-component aria-label="访问组件生命周期(Access to the lifecycle of the component)">访问组件生命周期(Access to the lifecycle of the component)</a></li><li><a href=#%e8%87%aa%e5%ae%9a%e4%b9%89%e4%bb%a3%e7%a0%81custom-code aria-label="自定义代码(Custom code)">自定义代码(Custom code)</a></li><li><a href=#refs aria-label=Refs>Refs</a></li><li><a href=#%e9%99%84%e5%8a%a0%e7%9a%84%e5%87%bd%e6%95%b0additional-functions aria-label="附加的函数(Additional functions)">附加的函数(Additional functions)</a></li><li><a href=#context-%e5%92%8c-provideinject aria-label="Context 和 provide/inject">Context 和 provide/inject</a></li><li><a href=#%e5%9c%a8%e6%b8%b2%e6%9f%93%e4%b8%8a%e4%b8%8b%e6%96%87%e4%b8%ad%e6%9a%b4%e9%9c%b2%e5%80%bcexposing-values-to-render-context aria-label="在渲染上下文中暴露值(Exposing values to render context)">在渲染上下文中暴露值(Exposing values to render context)</a></li><li><a href=#%e6%80%bb%e7%bb%93conclusion aria-label=总结(Conclusion)>总结(Conclusion)</a></li><li><a href=#%e5%8f%82%e8%80%83 aria-label=参考>参考</a></li></ul></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{elements&&(activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")}))},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><p>目录 场景 hook 的时代意义 React Hooks Vue Composition API 差别 总结 场景 先理解&mldr;</p><div class=box style=max-width:650><figure itemprop=associatedMedia itemscope itemtype=http://schema.org/ImageObject><div class=img><img itemprop=thumbnail src=/img-blogs/20200706-001.png alt="对比 React Hooks 和 Vue Composition API"></div><a href=/img-blogs/20200706-001.png target=_blank itemprop=contentUrl></a></figure></div><p><strong>目录</strong></p><ul><li>场景</li><li>hook 的时代意义</li><li>React Hooks</li><li>Vue Composition API</li><li>差别</li><li>总结</li></ul><hr><h2 id=场景>场景<a hidden class=anchor aria-hidden=true href=#场景>#</a></h2><p>先理解什么是hook，拿react的介绍来看，它的定义是：</p><blockquote><p>它可以让你在不编写 class 的情况下，让你在函数组件里“钩入” React state 及生命周期等特性的函数</p></blockquote><p>对于 Vue 提出的新的书写 Vue 组件的 API：Composition API RFC，作用也是类似，所以我们也可以像react一样叫做 vue hooks</p><ul><li>该 API 受到 React Hooks 的启发</li><li>但有一些有趣的差异，规避了一些react的问题</li></ul><h2 id=hook的时代意义>hook的时代意义<a hidden class=anchor aria-hidden=true href=#hook的时代意义>#</a></h2><p>框架是服务于业务的，业务中很难避免的一个问题就是 &ndash; 逻辑复用，同样的功能，同样的组件，在不一样的场合下，我们有时候不得不去写2+次，为了避免耦合，后来各大框架纷纷想出了一些办法，比如 minix, render props, 高阶组件等实现逻辑上的复用，但是都有一些额外的问题</p><ul><li>minix 与组件之间存在隐式依赖，可能产生冲突。倾向于增加更多状态，降低了应用的可预测性</li><li>高阶组件 多层包裹嵌套组件，增加了复杂度和理解成本，对于外层是黑盒</li><li>Render Props 使用繁琐，不好维护, 代码体积过大，同样容易嵌套过深</li><li>&mldr;</li></ul><p>hook的出现是划时代的，通过function抽离的方式，实现了复杂逻辑的内部封装：</p><ul><li>逻辑代码的复用</li><li>减小了代码体积</li><li>没有this的烦恼</li></ul><h2 id=react-hooks>React Hooks<a hidden class=anchor aria-hidden=true href=#react-hooks>#</a></h2><p>React Hooks 允许你 &ldquo;勾入&rdquo; 诸如组件状态和副作用处理等 React 功能中。Hooks 只能用在函数组件中，并允许我们在不需要创建类的情况下将状态、副作用处理和更多东西带入组件中。</p><p>React 核心团队奉上的采纳策略是不反对类组件，所以你可以升级 React 版本、在新组件中开始尝试 Hooks，并保持既有组件不做任何更改</p><p>例子：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>import React, { useState, useEffect } from &#34;react&#34;;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>const NoteForm = ({ onNoteSent }) =&gt; {
</span></span><span style=display:flex><span>  const [currentNote, setCurrentNote] = useState(&#34;&#34;);
</span></span><span style=display:flex><span>  useEffect(() =&gt; {
</span></span><span style=display:flex><span>    console.log(`Current note: ${currentNote}`);
</span></span><span style=display:flex><span>  });
</span></span><span style=display:flex><span>  return (
</span></span><span style=display:flex><span>    &lt;form
</span></span><span style=display:flex><span>      onSubmit={e =&gt; {
</span></span><span style=display:flex><span>        onNoteSent(currentNote);
</span></span><span style=display:flex><span>        setCurrentNote(&#34;&#34;);
</span></span><span style=display:flex><span>        e.preventDefault();
</span></span><span style=display:flex><span>      }}
</span></span><span style=display:flex><span>    &gt;
</span></span><span style=display:flex><span>      &lt;label&gt;
</span></span><span style=display:flex><span>        &lt;span&gt;Note: &lt;/span&gt;
</span></span><span style=display:flex><span>        &lt;input
</span></span><span style=display:flex><span>          value={currentNote}
</span></span><span style=display:flex><span>          onChange={e =&gt; {
</span></span><span style=display:flex><span>            const val = e.target.value &amp;&amp; e.target.value.toUpperCase()[0];
</span></span><span style=display:flex><span>            const validNotes = [&#34;A&#34;, &#34;B&#34;, &#34;C&#34;, &#34;D&#34;, &#34;E&#34;, &#34;F&#34;, &#34;G&#34;];
</span></span><span style=display:flex><span>            setCurrentNote(validNotes.includes(val) ? val : &#34;&#34;);
</span></span><span style=display:flex><span>          }}
</span></span><span style=display:flex><span>        /&gt;
</span></span><span style=display:flex><span>      &lt;/label&gt;
</span></span><span style=display:flex><span>      &lt;button type=&#34;submit&#34;&gt;Send&lt;/button&gt;
</span></span><span style=display:flex><span>    &lt;/form&gt;
</span></span><span style=display:flex><span>  );
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><ul><li>useState 和 useEffect 是 React Hooks 中的一些例子，使得函数组件中也能增加状态和运行副作用</li><li>还有更多其他 hooks， 甚至能自定义一个，hooks 打开了代码复用性和扩展性的新大门</li></ul><h3 id=vue-composition-api>Vue Composition API<a hidden class=anchor aria-hidden=true href=#vue-composition-api>#</a></h3><p>Vue Composition API 围绕一个新的组件选项 setup 而创建。<code>setup()</code> 为 Vue 组件提供了状态、计算值、watcher 和生命周期钩子</p><p>API 并没有让原来的 API（现在被称作 &ldquo;Options-based API&rdquo;）消失。允许开发者 结合使用新旧两种 APIs。可以在 Vue 2.x 中通过 <code>@vue/composition-api</code> 插件尝试新 API</p><p>例子：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>&lt;template&gt;
</span></span><span style=display:flex><span>  &lt;form @submit=&#34;handleSubmit&#34;&gt;
</span></span><span style=display:flex><span>    &lt;label&gt;
</span></span><span style=display:flex><span>      &lt;span&gt;Note:&lt;/span&gt;
</span></span><span style=display:flex><span>      &lt;input v-model=&#34;currentNote&#34; @input=&#34;handleNoteInput&#34;&gt;
</span></span><span style=display:flex><span>    &lt;/label&gt;
</span></span><span style=display:flex><span>    &lt;button type=&#34;submit&#34;&gt;Send&lt;/button&gt;
</span></span><span style=display:flex><span>  &lt;/form&gt;
</span></span><span style=display:flex><span>&lt;/template&gt;
</span></span><span style=display:flex><span>&lt;script&gt;
</span></span><span style=display:flex><span>import { ref, watch } from &#34;vue&#34;;
</span></span><span style=display:flex><span>export default {
</span></span><span style=display:flex><span>  props: [&#34;divRef&#34;],
</span></span><span style=display:flex><span>  setup(props, context) {
</span></span><span style=display:flex><span>    const currentNote = ref(&#34;&#34;);
</span></span><span style=display:flex><span>    const handleNoteInput = e =&gt; {
</span></span><span style=display:flex><span>      const val = e.target.value &amp;&amp; e.target.value.toUpperCase()[0];
</span></span><span style=display:flex><span>      const validNotes = [&#34;A&#34;, &#34;B&#34;, &#34;C&#34;, &#34;D&#34;, &#34;E&#34;, &#34;F&#34;, &#34;G&#34;];
</span></span><span style=display:flex><span>      currentNote.value = validNotes.includes(val) ? val : &#34;&#34;;
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>    const handleSubmit = e =&gt; {
</span></span><span style=display:flex><span>      context.emit(&#34;note-sent&#34;, currentNote.value);
</span></span><span style=display:flex><span>      currentNote.value = &#34;&#34;;
</span></span><span style=display:flex><span>      e.preventDefault();
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>    return {
</span></span><span style=display:flex><span>      currentNote,
</span></span><span style=display:flex><span>      handleNoteInput,
</span></span><span style=display:flex><span>      handleSubmit,
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>&lt;/script&gt;
</span></span></code></pre></div><h2 id=差别>差别<a hidden class=anchor aria-hidden=true href=#差别>#</a></h2><h3 id=原理>原理<a hidden class=anchor aria-hidden=true href=#原理>#</a></h3><p>React hook 底层是基于链表实现，调用的条件是每次组件被render的时候都会顺序执行所有的hooks，所以下面的代码会报错</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>function App(){
</span></span><span style=display:flex><span>  const [name, setName] = useState(&#39;demo&#39;);
</span></span><span style=display:flex><span>  if(condition){
</span></span><span style=display:flex><span>    const [val, setVal] = useState(&#39;&#39;);    
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>因为底层是链表，每一个hook的next是指向下一个hook的，if会导致顺序不正确，从而导致报错，所以react是不允许这样使用hook的。</p><p>vue hook 只会被注册调用一次，vue 能避开这些麻烦的问题，原因在于它对数据的响应是基于proxy的，对数据直接代理观察。这种场景下，只要任何一个更改data的地方，相关的function或者template都会被重新计算，因此避开了react可能遇到的性能上的问题</p><blockquote><p>react数据更改的时候，会导致重新render，重新render又会重新把hooks重新注册一次，所以react的上手难度更高一些</p></blockquote><p>当然react对这些都有自己的解决方案，比如useCallback，useMemo等hook的作用，这些官网都有介绍</p><h3 id=代码的执行>代码的执行<a hidden class=anchor aria-hidden=true href=#代码的执行>#</a></h3><p>Vue 中，“钩子”就是一个生命周期方法<br></p><ol><li>Vue Composition API 的 setup() 晚于 beforeCreate 钩子，早于 created 钩子被调用</li><li>React hooks 会在组件每次渲染时候运行，而 Vue setup() 只在组件创建时运行一次</li></ol><p>由于 React hooks 会多次运行，所以 render 方法必须遵守某些规则，比如: 不要在循环内部、条件语句中或嵌套函数里调用 Hooks</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>// React 文档中的示例代码：
</span></span><span style=display:flex><span>function Form() {
</span></span><span style=display:flex><span>  // 1. Use the name state variable
</span></span><span style=display:flex><span>  const [name, setName] = useState(&#39;Mary&#39;);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  // 2. Use an effect for persisting the form
</span></span><span style=display:flex><span>  if (name !== &#39;&#39;) {
</span></span><span style=display:flex><span>    useEffect(function persistForm() {
</span></span><span style=display:flex><span>      localStorage.setItem(&#39;formData&#39;, name);
</span></span><span style=display:flex><span>    });
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  // 3. Use the surname state variable
</span></span><span style=display:flex><span>  const [surname, setSurname] = useState(&#39;Poppins&#39;);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  // 4. Use an effect for updating the title
</span></span><span style=display:flex><span>  useEffect(function updateTitle() {
</span></span><span style=display:flex><span>    document.title = `${name} ${surname}`;
</span></span><span style=display:flex><span>  });
</span></span><span style=display:flex><span>  // ...
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>如果想要在 name 为空时也运行对应的副作用, 可以简单的将条件判断语句移入 useEffect 回调内部：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>useEffect(function persistForm() {
</span></span><span style=display:flex><span>  if (name !== &#39;&#39;) {
</span></span><span style=display:flex><span>    localStorage.setItem(&#39;formData&#39;, name);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>});
</span></span></code></pre></div><p>对于以上的实现，Vue 写法如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>export default {
</span></span><span style=display:flex><span>  setup() {
</span></span><span style=display:flex><span>    // 1. Use the name state variable
</span></span><span style=display:flex><span>    const name = ref(&#34;Mary&#34;);
</span></span><span style=display:flex><span>    // 2. Use a watcher for persisting the form
</span></span><span style=display:flex><span>    if(name.value !== &#39;&#39;) {
</span></span><span style=display:flex><span>      watch(function persistForm() =&gt; {
</span></span><span style=display:flex><span>        localStorage.setItem(&#39;formData&#39;, name.value);
</span></span><span style=display:flex><span>      });
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>   // 3. Use the surname state variable
</span></span><span style=display:flex><span>   const surname = ref(&#34;Poppins&#34;);
</span></span><span style=display:flex><span>   // 4. Use a watcher for updating the title
</span></span><span style=display:flex><span>   watch(function updateTitle() {
</span></span><span style=display:flex><span>     document.title = `${name.value} ${surname.value}`;
</span></span><span style=display:flex><span>   });
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Vue 中 setup() 只会运行一次，可以将 Composition API 中不同的函数 (reactive、ref、computed、watch、生命周期钩子等) 作为循环或条件语句的一部分</p><p>但 if 语句 和 react hooks 一样只运行一次，所以它在 name 改变时也无法作出反应，除非我们将其包含在 watch 回调的内部</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>watch(function persistForm() =&gt; {
</span></span><span style=display:flex><span>  if(name.value !== &#39;&#39;) {
</span></span><span style=display:flex><span>    localStorage.setItem(&#39;formData&#39;, name.value);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>});
</span></span></code></pre></div><h3 id=声明状态declaring-state>声明状态(Declaring state)<a hidden class=anchor aria-hidden=true href=#声明状态declaring-state>#</a></h3><h5 id=react>react<a hidden class=anchor aria-hidden=true href=#react>#</a></h5><p>useState 是 React Hooks 声明状态的主要途径</p><ul><li>可以向调用中传入一个初始值作为参数</li><li>如果初始值的计算代价比较昂贵，也可以将其表达为一个函数，就只会在初次渲染时才会被执行</li></ul><p>useState() 返回一个数组，第一项是 state，第二项是一个 setter 函数</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>const [name, setName] = useState(&#34;Mary&#34;);
</span></span><span style=display:flex><span>const [age, setAge] = useState(25);
</span></span><span style=display:flex><span>console.log(`${name} is ${age} years old.`);
</span></span></code></pre></div><p>useReducer 是个有用的替代选择，其常见形式是接受一个 Redux 样式的 reducer 函数和一个初始状态：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>const initialState = {count: 0};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>function reducer(state, action) {
</span></span><span style=display:flex><span>  switch (action.type) {
</span></span><span style=display:flex><span>    case &#39;increment&#39;:
</span></span><span style=display:flex><span>      return {count: state.count + 1};
</span></span><span style=display:flex><span>    case &#39;decrement&#39;:
</span></span><span style=display:flex><span>      return {count: state.count - 1};
</span></span><span style=display:flex><span>    default:
</span></span><span style=display:flex><span>      throw new Error();
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>const [state, dispatch] = useReducer(reducer, initialState);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>dispatch({type: &#39;increment&#39;}); // state 就会变为 {count: 1}
</span></span></code></pre></div><blockquote><p>useReducer 还有一种 延迟初始化 的形式，传入一个 init 函数作为第三个参数</p></blockquote><h5 id=vue>Vue<a hidden class=anchor aria-hidden=true href=#vue>#</a></h5><p>Vue 使用两个主要的函数来声明状态：ref 和 reactive。</p><p>ref() 返回一个反应式对象，其内部值可通过其 value 属性被访问到。可以将其用于基本类型，也可以用于对象</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>const name = ref(&#34;Mary&#34;);
</span></span><span style=display:flex><span>const age = ref(25);
</span></span><span style=display:flex><span>watch(() =&gt; {
</span></span><span style=display:flex><span>  console.log(`${name.value} is ${age.value} years old.`);
</span></span><span style=display:flex><span>});
</span></span></code></pre></div><p>reactive() 只将一个对象作为其输入并返回一个对其的反应式代理</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>const state = reactive({
</span></span><span style=display:flex><span>  name: &#34;Mary&#34;,
</span></span><span style=display:flex><span>  age: 25,
</span></span><span style=display:flex><span>});
</span></span><span style=display:flex><span>watch(() =&gt; {
</span></span><span style=display:flex><span>  console.log(`${state.name} is ${state.age} years old.`);
</span></span><span style=display:flex><span>});
</span></span></code></pre></div><p><strong>注意</strong>：</p><ul><li>使用 ref 时需要 用 value 属性访问其包含的值（除非在 template 中，Vue 允许你省略它）</li><li>用 reactive 时，要注意如果使用了对象解构（destructure），会失去其反应性。所以需要定义一个指向对象的引用，并通过其访问状态属性。</li></ul><p>总结使用这两个函数的处理方式：</p><ul><li>像在正常的 JavaScript 中声明基本类型变量和对象变量那样去使用 ref 和 reactive 即可</li><li>只要用到 reactive 的时候，要记住从 composition 函数中返回反应式对象时得使用 toRefs()。这样做减少了过多使用 ref 时的开销</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>// toRefs() 则将反应式对象转换为普通对象，该对象上的所有属性都自动转换为 ref
</span></span><span style=display:flex><span>function useFeatureX() {
</span></span><span style=display:flex><span>  const state = reactive({
</span></span><span style=display:flex><span>    foo: 1,
</span></span><span style=display:flex><span>    bar: 2
</span></span><span style=display:flex><span>  })
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>  return toRefs(state)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>const {foo, bar} = useFeatureX();
</span></span></code></pre></div><h3 id=如何跟踪依赖how-to-track-dependencies>如何跟踪依赖(How to track dependencies)<a hidden class=anchor aria-hidden=true href=#如何跟踪依赖how-to-track-dependencies>#</a></h3><blockquote><p>React 中的 useEffect hook 允许在每次渲染之后运行某些副作用（如请求数据或使用 storage 等 Web APIs），并在下次执行回调之前或当组件卸载时运行一些清理工作</p></blockquote><p>默认情况下，所有用 useEffect 注册的函数都会在每次渲染之后运行，但可以定义真实依赖的状态和属性，以使 React 在相关依赖没有改变的情况下（如由 state 中的其他部分引起的渲染）跳过某些 useEffect hook 执行</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>// 传递一个依赖项的数组作为 useEffect hook 的第二个参数，只有当 name 改变时才会更新 localStorage
</span></span><span style=display:flex><span>function Form() {
</span></span><span style=display:flex><span>  const [name, setName] = useState(&#39;Mary&#39;);
</span></span><span style=display:flex><span>  const [surname, setSurname] = useState(&#39;Poppins&#39;);
</span></span><span style=display:flex><span>  useEffect(function persistForm() {
</span></span><span style=display:flex><span>      localStorage.setItem(&#39;formData&#39;, name);
</span></span><span style=display:flex><span>  }, [name]);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  // ...
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>显然，使用 React Hooks 时忘记在依赖项数组中详尽地声明所有依赖项很容易发生，会导致 useEffect 回调 &ldquo;以依赖和引用了上一次渲染的陈旧数据而非最新数据&rdquo; 从而无法被更新而告终</p><p>解决方案：</p><ul><li>eslint-plugin-react-hooks 包含了一条 lint 提示关于丢失依赖项的规则</li><li>useCallback 和 useMemo 也使用依赖项数组参数，以分别决定其是否应该返回缓存过的（ memoized）与上一次执行相同的版本的回调或值。</li></ul><p>在 Vue Composition API 的情况下，可以使用 watch() 执行副作用以响应状态或属性的改变。依赖会被自动跟踪，注册过的函数也会在依赖改变时被反应性的调用</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>export default {
</span></span><span style=display:flex><span>  setup() {
</span></span><span style=display:flex><span>    const name = ref(&#34;Mary&#34;);
</span></span><span style=display:flex><span>    const lastName = ref(&#34;Poppins&#34;);
</span></span><span style=display:flex><span>    watch(function persistForm() =&gt; {
</span></span><span style=display:flex><span>      localStorage.setItem(&#39;formData&#39;, name.value);
</span></span><span style=display:flex><span>    });
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=访问组件生命周期access-to-the-lifecycle-of-the-component>访问组件生命周期(Access to the lifecycle of the component)<a hidden class=anchor aria-hidden=true href=#访问组件生命周期access-to-the-lifecycle-of-the-component>#</a></h3><p>Hooks 在处理 React 组件的生命周期、副作用和状态管理时表现出了心理模式上的完全转变。 React 文档中也指出：</p><blockquote><p>如果你熟悉 React 类生命周期方法，那么可以将 useEffect Hook 视为 componentDidMount、componentDidUpdate 及 componentWillUnmount 的合集</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>useEffect(() =&gt; {
</span></span><span style=display:flex><span>  console.log(&#34;This will only run after initial render.&#34;);
</span></span><span style=display:flex><span>  return () =&gt; { console.log(&#34;This will only run when component will unmount.&#34;); };
</span></span><span style=display:flex><span>}, []);
</span></span></code></pre></div><p>强调的是，使用 React Hooks 时停止从生命周期方法的角度思考，而是考虑副作用依赖什么状态，才更符合习惯</p><p>Vue Component API 通过 onMounted、onUpdated 和 onBeforeUnmount：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>setup() {
</span></span><span style=display:flex><span>  onMounted(() =&gt; {
</span></span><span style=display:flex><span>    console.log(`This will only run after initial render.`); 
</span></span><span style=display:flex><span>  });
</span></span><span style=display:flex><span>  onBeforeUnmount(() =&gt; {
</span></span><span style=display:flex><span>    console.log(`This will only run when component will unmount.`);
</span></span><span style=display:flex><span>  });
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>故在 Vue 的情况下的心理模式转变更多在停止通过<font color=#d10>组件选项</font>（data、computed, watch、methods、生命周期钩子等）管理代码，要转向用不同函数处理对应的特性</p><h3 id=自定义代码custom-code>自定义代码(Custom code)<a hidden class=anchor aria-hidden=true href=#自定义代码custom-code>#</a></h3><blockquote><p>React 团队聚焦于 Hooks 上的原因之一，Custom Hooks 是可以替代之前社区中采纳的诸如 Higher-Order Components 或 Render Props 等提供给开发者编写可复用代码的，一种更优秀的方式</p></blockquote><p>Custom Hooks 就是普通的 JavaScript 函数，在其内部利用了 React Hooks。它遵守的一个约定是其命名应该以 use 开头，以明示这是被用作一个 hook 的。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>// custom hook - 用于当 value 改变时向控制台打印日志
</span></span><span style=display:flex><span>export function useDebugState(label, initialValue) {
</span></span><span style=display:flex><span>  const [value, setValue] = useState(initialValue);
</span></span><span style=display:flex><span>  useEffect(() =&gt; {
</span></span><span style=display:flex><span>    console.log(`${label}: `, value);
</span></span><span style=display:flex><span>  }, [label, value]);
</span></span><span style=display:flex><span>  return [value, setValue];
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>// 调用 
</span></span><span style=display:flex><span>const [name, setName] = useDebugState(&#34;Name&#34;, &#34;Mary&#34;);
</span></span></code></pre></div><p>Vue 中，组合式函数（Composition Functions）与 Hooks 在逻辑提取和重用的目标上是一致的在 Vue 中实现一个类似的 useDebugState 组合式函数</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>export function useDebugState(label, initialValue) {
</span></span><span style=display:flex><span>  const state = ref(initialValue);
</span></span><span style=display:flex><span>  watch(() =&gt; {
</span></span><span style=display:flex><span>    console.log(`${label}: `, state.value);
</span></span><span style=display:flex><span>  });
</span></span><span style=display:flex><span>  return state;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>// elsewhere:
</span></span><span style=display:flex><span>const name = useDebugState(&#34;Name&#34;, &#34;Mary&#34;);
</span></span></code></pre></div><blockquote><p>注意：根据约定，组合式函数也像 React Hooks 一样使用 use 作为前缀以明示作用，并且表面该函数用于 setup() 中</p></blockquote><h3 id=refs>Refs<a hidden class=anchor aria-hidden=true href=#refs>#</a></h3><p>React 的 useRef 和 Vue 的 ref 都允许你引用一个子组件 或 要附加到的 DOM 元素。</p><p>React：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>const MyComponent = () =&gt; {
</span></span><span style=display:flex><span>  const divRef = useRef(null);
</span></span><span style=display:flex><span>  useEffect(() =&gt; {
</span></span><span style=display:flex><span>    console.log(&#34;div: &#34;, divRef.current)
</span></span><span style=display:flex><span>  }, [divRef]);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  return (
</span></span><span style=display:flex><span>    &lt;div ref={divRef}&gt;
</span></span><span style=display:flex><span>      &lt;p&gt;My div&lt;/p&gt;
</span></span><span style=display:flex><span>    &lt;/div&gt;
</span></span><span style=display:flex><span>  )
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Vue:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>export default {
</span></span><span style=display:flex><span>  setup() {
</span></span><span style=display:flex><span>    const divRef = ref(null);
</span></span><span style=display:flex><span>    onMounted(() =&gt; {
</span></span><span style=display:flex><span>      console.log(&#34;div: &#34;, divRef.value);
</span></span><span style=display:flex><span>    });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    return () =&gt; (
</span></span><span style=display:flex><span>      &lt;div ref={divRef}&gt;
</span></span><span style=display:flex><span>        &lt;p&gt;My div&lt;/p&gt;
</span></span><span style=display:flex><span>      &lt;/div&gt;
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=附加的函数additional-functions>附加的函数(Additional functions)<a hidden class=anchor aria-hidden=true href=#附加的函数additional-functions>#</a></h3><p>React Hooks 在每次渲染时都会运行，没有 一个等价于 Vue 中 computed 函数的方法。所以你可以自由地声明一个变量，其值基于状态或属性，并将指向每次渲染后的最新值：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>const [name, setName] = useState(&#34;Mary&#34;);
</span></span><span style=display:flex><span>const [age, setAge] = useState(25);
</span></span><span style=display:flex><span>const description = `${name} is ${age} years old`;
</span></span></code></pre></div><p>Vue 中，setup() 只运行一次。因此需要定义计算属性，其应该观察某些状态更改并作出相应的更新：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>const name = ref(&#34;Mary&#34;);
</span></span><span style=display:flex><span>const age = ref(25);
</span></span><span style=display:flex><span>const description = computed(() =&gt; `${name.value} is ${age.value} years old`);
</span></span></code></pre></div><p>计算一个值开销比较昂贵。你不会想在组件每次渲染时都计算它。React 包含了针对这点的 <code>useMemo hook</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>function fibNaive(n) {
</span></span><span style=display:flex><span>  if (n &lt;= 1) return n;
</span></span><span style=display:flex><span>  return fibNaive(n - 1) + fibNaive(n - 2);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>const Fibonacci = () =&gt; {
</span></span><span style=display:flex><span>  const [nth, setNth] = useState(1);
</span></span><span style=display:flex><span>  const nthFibonacci = useMemo(() =&gt; fibNaive(nth), [nth]);
</span></span><span style=display:flex><span>  return (
</span></span><span style=display:flex><span>    &lt;section&gt;
</span></span><span style=display:flex><span>      &lt;label&gt;
</span></span><span style=display:flex><span>        Number:
</span></span><span style=display:flex><span>        &lt;input
</span></span><span style=display:flex><span>          type=&#34;number&#34;
</span></span><span style=display:flex><span>          value={nth}
</span></span><span style=display:flex><span>          onChange={e =&gt; setNth(e.target.value)}
</span></span><span style=display:flex><span>        /&gt;
</span></span><span style=display:flex><span>      &lt;/label&gt;
</span></span><span style=display:flex><span>      &lt;p&gt;nth Fibonacci number: {nthFibonacci}&lt;/p&gt;
</span></span><span style=display:flex><span>    &lt;/section&gt;
</span></span><span style=display:flex><span>  );
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p><strong>React 建议你使用 useMemo 作为一个性能优化手段, 而非一个任何一个依赖项改变之前的缓存值</strong></p><blockquote><p>React advice you to use useMemo as a performance optimization and not as a guarantee that the value will remain memoized</p></blockquote><p>Vue 的 computed 执行自动的依赖追踪，所以它不需要一个依赖项数组</p><h3 id=context-和-provideinject>Context 和 provide/inject<a hidden class=anchor aria-hidden=true href=#context-和-provideinject>#</a></h3><p>React 中的 useContext hook，可以作为一种读取特定上下文当前值的新方式。返回的值通常由最靠近的一层 <code>&lt;MyContext.Provider></code> 祖先树的 value 属性确定</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>// context object
</span></span><span style=display:flex><span>const ThemeContext = React.createContext(&#39;light&#39;);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>// provider
</span></span><span style=display:flex><span>&lt;ThemeContext.Provider value=&#34;dark&#34;&gt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>// consumer
</span></span><span style=display:flex><span>const theme = useContext(ThemeContext);
</span></span></code></pre></div><p>Vue 中类似的 API 叫 <code>provide/inject</code>。在 Vue 2.x 中作为组件选项存在，在 Composition API 中增加了一对用在 setup() 中的 <code>provide 和 inject</code> 函数：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>// key to provide
</span></span><span style=display:flex><span>const ThemeSymbol = Symbol();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>// provider
</span></span><span style=display:flex><span>provide(ThemeSymbol, ref(&#34;dark&#34;));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>// consumer
</span></span><span style=display:flex><span>const value = inject(ThemeSymbol);
</span></span></code></pre></div><blockquote><p>如果你想保持反应性，必须明确提供一个 ref/reactive 作为值</p></blockquote><h3 id=在渲染上下文中暴露值exposing-values-to-render-context>在渲染上下文中暴露值(Exposing values to render context)<a hidden class=anchor aria-hidden=true href=#在渲染上下文中暴露值exposing-values-to-render-context>#</a></h3><p><strong>在 React 的情况下</strong><br></p><ul><li>所有 hooks 代码都在组件中定义</li><li>且你将在同一个函数中返回要渲染的 React 元素</li></ul><p>所以你对作用域中的任何值拥有完全访问能力，就像在任何 JavaScript 代码中的一样：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>const Fibonacci = () =&gt; {
</span></span><span style=display:flex><span>  const [nth, setNth] = useState(1);
</span></span><span style=display:flex><span>  const nthFibonacci = useMemo(() =&gt; fibNaive(nth), [nth]);
</span></span><span style=display:flex><span>  return (
</span></span><span style=display:flex><span>    &lt;section&gt;
</span></span><span style=display:flex><span>      &lt;label&gt;
</span></span><span style=display:flex><span>        Number:
</span></span><span style=display:flex><span>        &lt;input
</span></span><span style=display:flex><span>          type=&#34;number&#34;
</span></span><span style=display:flex><span>          value={nth}
</span></span><span style=display:flex><span>          onChange={e =&gt; setNth(e.target.value)}
</span></span><span style=display:flex><span>        /&gt;
</span></span><span style=display:flex><span>      &lt;/label&gt;
</span></span><span style=display:flex><span>      &lt;p&gt;nth Fibonacci number: {nthFibonacci}&lt;/p&gt;
</span></span><span style=display:flex><span>    &lt;/section&gt;
</span></span><span style=display:flex><span>  );
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p><strong>Vue 的情况下</strong><br></p><ul><li>第一，在 template 或 render 选项中定义模板</li><li>第二，使用单文件组件，就要从 setup() 中返回一个包含了你想输出到模板中的所有值的对象</li></ul><blockquote><p>由于要暴露的值很可能过多，返回语句也容易变得冗长</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>&lt;template&gt;
</span></span><span style=display:flex><span>  &lt;section&gt;
</span></span><span style=display:flex><span>    &lt;label&gt;
</span></span><span style=display:flex><span>      Number:
</span></span><span style=display:flex><span>      &lt;input
</span></span><span style=display:flex><span>        type=&#34;number&#34;
</span></span><span style=display:flex><span>        v-model=&#34;nth&#34;
</span></span><span style=display:flex><span>      /&gt;
</span></span><span style=display:flex><span>    &lt;/label&gt;
</span></span><span style=display:flex><span>    &lt;p&gt;nth Fibonacci number: {{nthFibonacci}}&lt;/p&gt;
</span></span><span style=display:flex><span>  &lt;/section&gt;
</span></span><span style=display:flex><span>&lt;/template&gt;
</span></span><span style=display:flex><span>&lt;script&gt;
</span></span><span style=display:flex><span>export default {
</span></span><span style=display:flex><span>  setup() {
</span></span><span style=display:flex><span>    const nth = ref(1);
</span></span><span style=display:flex><span>    const nthFibonacci = computed(() =&gt; fibNaive(nth.value));
</span></span><span style=display:flex><span>    return { nth, nthFibonacci };
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>&lt;/script&gt;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><blockquote><p>要达到 React 同样简洁表现的一种方式是从 setup() 自身中返回一个渲染函数。不过，模板在 Vue 中是更常用的一种做法，所以暴露一个包含值的对象，是你使用 Vue Composition API 时必然会多多遭遇的情况。</p></blockquote><h3 id=总结conclusion>总结(Conclusion)<a hidden class=anchor aria-hidden=true href=#总结conclusion>#</a></h3><p>React 和 Vue都有属于属于自己的“惊喜”，无优劣之分，自 React Hooks 在 2018 年被引入，社区利用其产出了很多优秀的作品，自定义 Hooks 的可扩展性也催生了许多开源贡献。</p><p>Vue 受 React Hooks 启发将其调整为适用于自己框架的方式，这也成为这些<strong>不同的技术如何拥抱变化且分享灵感和解决方案的成功案例</strong></p><hr><h3 id=参考>参考<a hidden class=anchor aria-hidden=true href=#参考>#</a></h3><ul><li><a href=https://composition-api.vuejs.org/#summary>Composition API RFC</a></li><li><a href=https://reactjs.org/docs/hooks-intro.html>React hooks</a></li><li><a href=https://dev.to/voluntadpear/comparing-react-hooks-with-vue-composition-api-4b32>Comparing React Hooks with Vue Composition API</a></li></ul><hr><p><strong>最后， 希望大家早日实现：成为编程高手的伟大梦想！</strong><br><strong>欢迎交流~</strong></p><img src=/img-common/weChatPublic.jpg alt=微信公众号 width=600><p><strong>本文版权归原作者曜灵所有！未经允许，严禁转载！对非法转载者, 原作者保留采用法律手段追究的权利！</strong><br><strong>若需转载，请联系微信公众号：连先生有猫病，可获取作者联系方式！</strong></p></div><footer class=post-footer><nav class=paginav><a class=prev href=https://lianpf.github.io/posts/computer-basics/chrome-url-navigation-process/><span class=title>« 上一页</span><br><span>浏览器：导航流程-输入URL到页面展示，中间发生了什么(http)</span></a>
<a class=next href=https://lianpf.github.io/posts/frontend-develop/css-html-codefragment/><span class=title>下一页 »</span><br><span>代码片段和常见问题: html & css & less & sass</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share 对比 React Hooks 和 Vue Composition API on twitter" href="https://twitter.com/intent/tweet/?text=%e5%af%b9%e6%af%94%20React%20Hooks%20%e5%92%8c%20Vue%20Composition%20API&amp;url=https%3a%2f%2flianpf.github.io%2fposts%2ffrontend-develop%2freact-hooks-compare-vue-composition-api%2f&amp;hashtags=JS%2cReact%e6%8a%80%e6%9c%af%e6%a0%88%2cVue%e6%8a%80%e6%9c%af%e6%a0%88"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 对比 React Hooks 和 Vue Composition API on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2flianpf.github.io%2fposts%2ffrontend-develop%2freact-hooks-compare-vue-composition-api%2f&amp;title=%e5%af%b9%e6%af%94%20React%20Hooks%20%e5%92%8c%20Vue%20Composition%20API&amp;summary=%e5%af%b9%e6%af%94%20React%20Hooks%20%e5%92%8c%20Vue%20Composition%20API&amp;source=https%3a%2f%2flianpf.github.io%2fposts%2ffrontend-develop%2freact-hooks-compare-vue-composition-api%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 对比 React Hooks 和 Vue Composition API on reddit" href="https://reddit.com/submit?url=https%3a%2f%2flianpf.github.io%2fposts%2ffrontend-develop%2freact-hooks-compare-vue-composition-api%2f&title=%e5%af%b9%e6%af%94%20React%20Hooks%20%e5%92%8c%20Vue%20Composition%20API"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 对比 React Hooks 和 Vue Composition API on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2flianpf.github.io%2fposts%2ffrontend-develop%2freact-hooks-compare-vue-composition-api%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 对比 React Hooks 和 Vue Composition API on whatsapp" href="https://api.whatsapp.com/send?text=%e5%af%b9%e6%af%94%20React%20Hooks%20%e5%92%8c%20Vue%20Composition%20API%20-%20https%3a%2f%2flianpf.github.io%2fposts%2ffrontend-develop%2freact-hooks-compare-vue-composition-api%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 对比 React Hooks 和 Vue Composition API on telegram" href="https://telegram.me/share/url?text=%e5%af%b9%e6%af%94%20React%20Hooks%20%e5%92%8c%20Vue%20Composition%20API&amp;url=https%3a%2f%2flianpf.github.io%2fposts%2ffrontend-develop%2freact-hooks-compare-vue-composition-api%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></div><script src=https://utteranc.es/client.js repo=lianpf/lianpf.github.io issue-term=title label=comments theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>Copyright
&copy;
2016-2025
<a href=https://lianpf.github.io/ style=color:#939393>曜灵（SUN）Site</a>.
基于 Hugo 引擎和 PaperMod 主题</span>
<a href=https://beian.miit.gov.cn/ target=_blank style=color:#939393></a>&nbsp;</footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><span class=topInner><svg class="topSvg" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg><span id=read_progress></span></span></a>
<script>document.addEventListener("scroll",function(){const t=document.getElementById("read_progress"),n=document.documentElement.scrollHeight,s=document.documentElement.clientHeight,o=document.documentElement.scrollTop||document.body.scrollTop;t.innerText=((o/(n-s)).toFixed(2)*100).toFixed(0)})</script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>let mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>200||document.documentElement.scrollTop>200?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{(function(){document.cookie="change-themes="+escape("false")})(),document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.body.addEventListener("copy",function(e){if(window.getSelection().toString()&&window.getSelection().toString().length>50){let t=e.clipboardData||window.clipboardData;if(t){e.preventDefault();let n=window.getSelection().toString()+`

————————————————
版权声明：本文为「曜灵（SUN）Site」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：`+location.href,s=window.getSelection().toString()+`

————————————————
版权声明：本文为「曜灵（SUN）Site」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：`+location.href;t.setData("text/html",n),t.setData("text/plain",s)}}})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const s=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="复制";function i(){t.innerText="已复制！",setTimeout(()=>{t.innerText="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){let t=e.textContent+`
————————————————
版权声明：本文为「曜灵（SUN）Site」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：`+location.href;navigator.clipboard.writeText(t),i();return}const n=document.createRange();n.selectNodeContents(e);const s=window.getSelection();s.removeAllRanges(),s.addRange(n);try{document.execCommand("copy"),i()}catch{}s.removeRange(n)});let l=e.className.replaceAll("language-",""),n=document.createElement("div"),a=document.createElement("div"),r=document.createElement("div"),c=document.createElement("div"),o=document.createElement("div");o.innerText=l,n.setAttribute("class","mac-tool"),a.setAttribute("class","mac bb1"),r.setAttribute("class","mac bb2"),c.setAttribute("class","mac bb3"),o.setAttribute("class","language-type"),n.appendChild(a),n.appendChild(r),n.appendChild(c),n.appendChild(o),s.classList.contains("highlight")?(s.appendChild(t),s.appendChild(n)):s.parentNode.firstChild==s||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?(e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t),s.appendChild(n)):(e.parentNode.appendChild(t),s.appendChild(n)))})</script></body></html>